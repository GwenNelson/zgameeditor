
Listing
-------
0 errors and 37 warnings
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      destructor Destroy; override;
   15      procedure CheckHomograph(var sym: Integer); override;
   16  .)
   17  private = (.
   18      IsInIdent,IsInInvokeArg : boolean;
   19      CurrentFunction : TZcOpFunctionUserDefined;
   20      procedure CleanUp;
   21      procedure ZError(const S : string);
   22      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   23      function MakeTempName : string;
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      .)
   26  precreate = (.
   27      ZFunctions := TObjectList.Create(False);
   28      Self.OnError := OnParserError;
   29  .)
   30  
   31  semErrors = (.
   32      200 : Result := 'Not a floating point value';
   33      201 : Result := 'Name already defined in this scope';
   34      202 : Result := 'Return value expected';
   35      203 : Result := 'Function should not return a value';
   36      204 : Result := 'Only function definitions are allowed here';
   37      205 : Result := 'Syntax not supported';
   38  .)
   39  
   40  implementation = (.
   41  
   42  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   43  begin
   44    ZError(Msg + ' ' + Data);
   45  end;
   46  
   47  procedure TZc.CheckHomograph(var sym: Integer);
   48  begin
   49    //Only Homographs are name of component datatypes
   50    //If inside identifier "x.y.z" then let it refer to identifier instead
   51    if IsInIdent or IsInInvokeArg then
   52      sym := identSym;
   53  end;
   54  
   55  destructor TZc.Destroy;
   56  begin
   57    inherited;
   58    CleanUp;
   59  end;
   60  
   61  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   62  begin
   63    if Op=nil then
   64    begin
   65      if SwitchOp.HasDefault then
   66        ZError('Only one default statement is allowed.');
   67      SwitchOp.HasDefault := True;
   68    end else
   69      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   70    SwitchOp.CaseOps.Last.Children.Add( Op );
   71    Op := nil;
   72  end;
   73  
   74  procedure TZc.CleanUp;
   75  begin
   76    Zc_Ops.FunctionCleanUps.Clear;
   77    ZFunctions.Free;
   78  end;
   79  
   80  function TZc.MakeTempName : string;
   81  begin
   82    Inc(TempCounter);
   83    Result := '#temp' + IntToStr(TempCounter);
   84  end;
   85  
   86  procedure TZc.ZError(const S : string);
   87  var
   88    E : EParseError;
   89    P : TSymbolRec;
   90  begin
   91    E := EParseError.Create(S);
   92    E.Message := S;
   93    Scanner.GetPosition(P);
   94    E.Line := P.Line;
   95    E.Col := P.Col;
   96    raise E;
   97  end;
   98  
   99  .)
  100  
  101  END
  102  
  103  
  104  CHARACTERS
  105  
  106          tab                = CHR(9). /*  9 = tabulator */
  107          eol                = CHR(10). /* 10 = line feed */
  108          cr                 = CHR(13). /* 13 = carriage return */
  109          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  110  
  111          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  112          digit              = "0123456789".
  113          hexDigit           = digit + "ABCDEFabcdef".
  114          notDigit           = ANY - digit.
  115  
  116          char               = ANY - "'" - '\' - newLine.
  117          verbatimStringChar = ANY - '"'.
  118          regularStringChar  = ANY - '"' - '\' - newLine.
  119          notNewLine         = ANY - newLine .
  120  
  121  
  122  TOKENS
  123  
  124    /*--------------------------------------------------------------------------------*/
  125          intCon =
  126                  ( digit {digit}
  127                  | ("0x" | "0X") hexDigit {hexDigit}
  128                  )
  129                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  130                  .
  131    /*--------------------------------------------------------------------------------*/
  132          realCon =
  133                  "." digit {digit}
  134                  [("e" | "E") ["+" | "-"] digit {digit}]
  135                  ["F" | "f" | "D" | "d" | "M" | "m"]
  136          | digit {digit}
  137                  ( "." digit {digit}
  138                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  139                          ["F" | "f" | "D" | "d" | "M" | "m"]
  140                  | ("e" | "E") ["+" | "-"] digit {digit}
  141                          ["F" | "f" | "D" | "d" | "M" | "m"]
  142                  | "F" | "f" | "D" | "d" | "M" | "m"
  143                  ).
  144    /*--------------------------------------------------------------------------------*/
  145          stringCon =
  146                  '"'    { regularStringChar
  147            | "\'" | '\"' | "\\" | "\n"
  148            }
  149                  '"'.
  150  
  151          ident = letter { letter | digit }.
  152  
  153  
  154          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  155          and    = "&".
  156          assgn  = "=".
  157          colon  = ":".
  158          comma  = ",".
  159          dec    = "--".
  160          div    = "/".
  161          dot    = ".".
  162          eq     = "==".
  163          gt     = ">".
  164          gte    = ">=".
  165          inc    = "++".
  166          lbrace = "{".
  167          lbrack = "[".
  168          lpar   = "(".
  169          lshift = "<<".
  170          lt     = "<".
  171          lte    = "<=".
  172          minus  = "-".
  173          mod    = "%".
  174          neq    = "!=".
  175          not    = "!".
  176          or     = "|".
  177          plus   = "+".
  178          rbrace = "}".
  179          rbrack = "]".
  180          rpar   = ")".
  181          rshift = ">>".
  182          scolon = ";".
  183          tilde  = "~".
  184          times  = "*".
  185          xor    = "^".
  186  
  187  
  188  
  189  COMMENTS FROM "/*" TO "*/"
  190  COMMENTS FROM "//" TO eol
  191  
  192  IGNORE eol + cr + tab
  193  
  194  HOMOGRAPHS
  195    "Material"
  196    "Sound"
  197    "Shader" 
  198    "Bitmap" 
  199    "Mesh"
  200    "Camera" 
  201    "Font"
  202    "Sample"
  203  
  204  
  205  PRODUCTIONS
  206  
  207  /*------------------------------------------------------------------------*
  208   *--------------------------- Declarations -------------------------------*
  209   *------------------------------------------------------------------------*/
  210  
  211  Zc (. var
  212          Func : TZcOpFunctionUserDefined;
  213          Typ : TZcDataType;
  214      .)
  215  =
  216    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  217    {
  218      ConstantDeclaration
  219      |
  220      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (.
  221            if SymTab.Contains(LexString) then
  222              ZError('Name already defined: ' + LexString);
  223  
  224            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  225            Func.Id := LexString;
  226            Func.ReturnType := Typ;
  227            SymTab.Add(Func.Id,Func);
  228            ZFunctions.Add(Func);
  229            Self.CurrentFunction := Func;
  230            SymTab.PushScope;
  231            try
  232         .)
  233      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"
  234          (.
  235            finally
  236              SymTab.PopScope;
  237            end;
  238          .)
  239    }
  240    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  241    {
  242  
  243    (.
  244         Func := TZcOpFunctionUserDefined.Create(nil);
  245         Func.ReturnType := Self.ReturnType;
  246         Self.CurrentFunction := Func;
  247         try
  248           SymTab.PushScope;
  249           try
  250             ZFunctions.Add(Func);
  251    .)
  252    /* A zc-expression is treated like the body of a nameless function
  253       to allow local var declarations  */
  254  
  255    ZcFuncBody
  256    (.
  257           finally
  258             SymTab.PopScope;
  259           end;
  260         except on E: Exception do
  261           ZError(E.Message);
  262         end;
  263    .)
  264    }
  265  
  266  .
  267  
  268  /*------------------------------------------------------------------------*/
  269  
  270  ZcFuncBody (. var Op : TZcOp; .)
  271  =  {  (. Op:=nil; .)
  272        Statement<Op>
  273        (. if Op<>nil then
  274             CurrentFunction.Statements.Add(Op);
  275           Op := nil;
  276        .)
  277     }
  278  .
  279  
  280  /*------------------------------------------------------------------------*/
  281  FormalParams                    
  282  = ( Par ["," FormalParams] )
  283  .
  284  /*------------------------------------------------------------------------*/
  285  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  286  = Type<Typ> ident
  287       (.
  288          if SymTab.ScopeContains(LexString) then
  289            SynError(201)
  290          else
  291          begin
  292            Arg := TZcOpArgumentVar.Create(GlobalNames);
  293            Arg.Id := LexString;
  294            Arg.Typ := Typ;
  295            CurrentFunction.AddArgument(Arg);
  296            SymTab.Add(Arg.Id,Arg);
  297          end;
  298       .)
  299  .
  300  /*------------------------------------------------------------------------*/
  301  
  302  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  303  = (. OutOp := nil; .)
  304    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  305  .
  306  
  307  /*------------------------------------------------------------------------*/
  308  
  309  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  310  = ident
  311       (. 
  312          if SymTab.ScopeContains(LexString) then
  313            ZError('Name already defined: ' + LexString);
  314  
  315          Loc := TZcOpLocalVar.Create(nil);
  316          Loc.Id := LexString;
  317          Loc.Typ := Typ;
  318       .)
  319       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  320       (.
  321          SymTab.Add(Loc.Id,Loc);
  322          CurrentFunction.AddLocal(Loc);
  323  
  324          if Assigned(Loc.InitExpression) then
  325          begin
  326            //Generate tree for initial assignment
  327            if OutOp=nil then
  328              OutOp := MakeOp(zcBlock);
  329            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  330          end;
  331          
  332       .)
  333  .
  334  
  335  /*------------------------------------------------------------------------*/
  336  
  337  Init<var OutOp : TZcOp>
  338  = Expr<OutOp>
  339  .
  340  
  341  /*------------------------------------------------------------------------*/
  342  Argument<var OutOp : TZcOp>
  343  = /* ["ref" | "out"] */
  344    (. OutOp := nil; .)
  345    Expr<OutOp>
  346    (. if OutOp=nil then ZError('Missing argument'); .)
  347  .
  348  
  349  /*------------------------------------------------------------------------*
  350   *-------------------------------- Types ---------------------------------*
  351   *------------------------------------------------------------------------*/
  352  
  353  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  354   * and for array creation expressions                                     */
  355  
  356  
  357  Type<var Typ : TZcDataType>
  358  = ( SimpleType<Typ> )
  359  .
  360  
  361  /*------------------------------------------------------------------------*/
  362  
  363  SimpleType<var Typ : TZcDataType>
  364  /* = IntType | "float" | "double" | "decimal" | "bool" */
  365  = "float" (. Typ.Kind := zctFloat; .)
  366    | "int" (. Typ.Kind := zctInt; .)
  367    | "string" (. Typ.Kind := zctString; .)
  368    | "model" (. Typ.Kind := zctModel; .)
  369  
  370    /* Changes below also must be made in homographs-section */
  371    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  372    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .) 
  373    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  374    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  375    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  376    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  377    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  378    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  379  .
  380  
  381  /*------------------------------------------------------------------------*/
  382  
  383  /* IntType
  384  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  385  . */
  386  
  387  
  388  ConstantDeclaration
  389  (.
  390  var
  391    Cns : TDefineConstant;
  392    Typ : TZcDataType;
  393    Op : TZcOp;
  394    Lit : TZcOpLiteral;
  395    CnsName : string;
  396  .)
  397  =
  398  "const" Type<Typ> ident (. CnsName := LexString; .)"=" Expr<Op>
  399    (.
  400     Op := Op.Optimize;
  401     if not (Op is TZcOpLiteral) then
  402       ZError('Constant expression expected: ' + Op.ToString);
  403  
  404     Lit := Op as TZcOpLiteral;
  405  
  406     if Lit.Typ.Kind<>Typ.Kind then
  407       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  408  
  409     Cns := TDefineConstant.Create(nil);
  410     Cns.SetString('Name',AnsiString(CnsName));
  411     GlobalNames.Add(Cns);
  412  
  413     case Typ.Kind of
  414       zctInt:
  415         begin
  416           Cns._Type := dvbInt;
  417           Cns.IntValue := Round(Lit.Value);
  418         end;
  419       zctFloat:
  420         begin
  421           Cns._Type := dvbFloat;
  422           Cns.Value := Lit.Value;
  423         end;
  424       zctString:
  425         begin
  426           Cns._Type := dvbString;
  427           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  428         end;
  429       else
  430         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  431     end;
  432     SymTab.Add(CnsName,Cns);
  433    .)
  434  /* {"," ident "=" Expr<Op>} */
  435    ";"
  436  .
  437  
  438  /*------------------------------------------------------------------------*
  439   *------------------------------ Statements ------------------------------*
  440   *------------------------------------------------------------------------*/
  441  
  442  Statement<var OutOp : TZcOp>
  443  = (. OutOp := nil; .)
  444  
  445  ConstantDeclaration
  446  
  447  /*IF IsLocalVarDecl THEN
  448  BEGIN
  449    LocalVarDecl ";"
  450  END
  451  |  EmbeddedStatement<OutOp> */
  452  
  453  | LocalVarDecl<OutOp> ";"
  454  | EmbeddedStatement<OutOp>
  455    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  456     * ident {"." ident} { "[" ...                           */
  457  .
  458  
  459  /*------------------------------------------------------------------------*/
  460  EmbeddedStatement<var OutOp : TZcOp>
  461    (. var
  462         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  463         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  464         WhileCondOp,WhileBodyOp : TZcOp;
  465         SwitchOp : TZcOpSwitch;
  466         Loc : TZcOpLocalVar;
  467    .)
  468  = Block<OutOp>
  469  | ";"   (. OutOp := MakeOp(zcNop); .)
  470  | StatementExpr<OutOp> ";"
  471  | "if" (. ElseOp := nil; .)
  472    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  473          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  474   | "switch" "(" Expr<SwitchValueOp> ")"
  475        (.
  476           Loc := TZcOpLocalVar.Create(nil);
  477           Loc.Id := MakeTempName;
  478           Loc.Typ := SwitchValueOp.GetDataType;
  479           SymTab.Add(Loc.Id,Loc);
  480           CurrentFunction.AddLocal(Loc);
  481  
  482           OutOp := MakeOp(zcBlock);
  483           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  484  
  485           SwitchOp := TZcOpSwitch.Create(nil);
  486           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  487           OutOp.Children.Add(SwitchOp);
  488        .)
  489     "{" {
  490       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  491       SwitchSection<SwitchOp>
  492     } "}"
  493   | "while"
  494       (. try
  495           SymTab.PushScope;
  496           WhileCondOp := nil; WhileBodyOp := nil; .)
  497     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  498     (.
  499           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  500         finally
  501           SymTab.PopScope;
  502         end;
  503     .)
  504   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  505   | "for"
  506      (. try
  507           SymTab.PushScope;
  508           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  509     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  510     (.
  511           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  512         finally
  513           SymTab.PopScope;
  514         end;
  515     .)
  516  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  517   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  518   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  519   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  520      (.
  521          if (Op=nil) then
  522          begin
  523            if CurrentFunction.ReturnType.Kind<>zctVoid then
  524              SynError(202)
  525            else
  526              OutOp := MakeOp(zcReturn);
  527          end else
  528          begin
  529            if CurrentFunction.ReturnType.Kind=zctVoid then
  530              SynError(203)
  531            else
  532              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  533          end;
  534      .)
  535  .
  536  /*------------------------------------------------------------------------*/
  537  
  538  Block<var OutOp : TZcOp>
  539    (. var
  540         Op : TZcOp;
  541    .)
  542  = (. Op := nil;
  543       OutOp := MakeOp(zcBlock);
  544    .)
  545    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  546  
  547  /*------------------------------------------------------------------------*/
  548  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  549  = (. Op1 :=nil; Op2 := nil; .)
  550    Unary<Op1>
  551    ( AssignOp<Kind> Expr<Op2>
  552      (.
  553        if Op2<>nil then
  554          OutOp := MakeAssign(Kind,Op1,Op2);
  555      .)
  556    |                             (. OutOp := Op1; .)
  557    )
  558  .
  559  
  560  /*------------------------------------------------------------------------*/
  561  AssignOp<var Kind : TZcAssignType>
  562  = "="     (. Kind := atAssign; .)
  563    | "+="  (. Kind := atPlusAssign; .)
  564    | "-="  (. Kind := atMinusAssign; .)
  565    | "*="  (. Kind := atMulAssign; .)
  566    | "/="  (. Kind := atDivAssign; .)
  567  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  568  .
  569  
  570  /*------------------------------------------------------------------------*/
  571  
  572  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  573  = (. Op := nil; .)
  574    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  575    {
  576      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  577    }
  578    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  579    {
  580       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  581    }
  582  .
  583  
  584  /*------------------------------------------------------------------------*/
  585  
  586  SwitchLabel<var OutOp : TZcOp>
  587  = "case" Expr<OutOp> ":"
  588  | "default" ":"
  589  .
  590  
  591  /*------------------------------------------------------------------------*/
  592  
  593  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  594  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  595  (
  596  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  597  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  598    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  599  )
  600  .  
  601  
  602  /*------------------------------------------------------------------------*/
  603  
  604  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  605  = (. Op:=nil; 
  606       OutOp := MakeOp(zcBlock);
  607    .) 
  608  (
  609  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  610  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  611  )
  612  . 
  613  
  614  
  615  /*------------------------------------------------------------------------*
  616   *----------------------------- Expressions ------------------------------*
  617   *------------------------------------------------------------------------*/
  618  
  619  
  620  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  621  = (. Op1 :=nil; Op2 := nil; .)
  622    Unary<Op1>
  623    ( OrExpr<Op1,OutOp>
  624        ["?" Expr<Op1> ":" Expr<Op2>
  625           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  626                SynError(205)
  627              else
  628                OutOp := MakeOp(zcConditional,[OutOp,Op1,Op2]);
  629           .)
  630        ]
  631    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  632    )
  633  .
  634  /*------------------------------------------------------------------------*/
  635  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  636  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  637      {"||" Unary<Op> AndExpr<Op,R>
  638        (. OutOp := MakeOp(zcOr,[L,R]);
  639           L := OutOp; .)
  640      }
  641  .
  642  
  643  
  644  /*------------------------------------------------------------------------*/
  645  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  646  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  647      {"&&" Unary<Op> BitOrExpr<Op,R>
  648        (. OutOp := MakeOp(zcAnd,[L,R]);
  649           L := OutOp; .)
  650      }
  651  .
  652  /*------------------------------------------------------------------------*/
  653  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  654  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  655    {"|" Unary<Op> BitXorExpr<Op,R>
  656      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  657         L := OutOp; .)
  658    }
  659  .
  660  
  661  /*------------------------------------------------------------------------*/
  662  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  663  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  664    {"^" Unary<Op> BitAndExpr<Op,R>
  665      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  666         L := OutOp; .)
  667    }
  668  .
  669  
  670  /*------------------------------------------------------------------------*/
  671  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  672  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  673    {"&" Unary<Op> EqlExpr<Op,R>
  674      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  675         L := OutOp; .)
  676    }
  677  .
  678  
  679  /*------------------------------------------------------------------------*/
  680  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  681  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  682    {( "!="   (. Kind := zcCompNE; .)
  683     | "=="   (. Kind := zcCompEQ; .)
  684     )
  685     Unary<Op> RelExpr<Op,R>
  686           (. OutOp := MakeBinary(Kind, L,R);
  687              L := OutOp;
  688           .)
  689    }
  690  .
  691  /*------------------------------------------------------------------------*/
  692  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  693  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  694    { ( "<"       (. Kind := zcCompLT; .)
  695      | ">"       (. Kind := zcCompGT; .)
  696      | "<="      (. Kind := zcCompLE; .)
  697      | ">="      (. Kind := zcCompGE; .)
  698       )
  699      Unary<Op> ShiftExpr<Op,R>
  700           (. OutOp := MakeBinary(Kind, L,R );
  701              L := OutOp;
  702           .)
  703    }
  704  .
  705  /*------------------------------------------------------------------------*/
  706  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  707  = AddExpr<InOp,OutOp> (. L := OutOp; .)
  708    { ("<<"  (. Kind := zcBinaryShiftL; .)
  709      | ">>" (. Kind := zcBinaryShiftR; .)
  710      )
  711      Unary<Op> AddExpr<Op,R>
  712      (. OutOp := MakeOp(Kind,[L,R]);
  713         L := OutOp; .)
  714    }
  715  .
  716  /*------------------------------------------------------------------------*/
  717  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  718  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  719      {( "+"    (. Kind := zcPlus; .)
  720       | "-"    (. Kind := zcMinus; .)
  721       ) Unary<Op> MulExpr<Op,R>
  722           (. 
  723              if (L=nil) or (R=nil) then
  724                ZError('Invalid syntax');
  725              OutOp := MakeBinary(Kind,L,R);
  726              L := OutOp;
  727           .)
  728      }
  729  .
  730  /*------------------------------------------------------------------------*/
  731  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  732  =       (. OutOp := InOp; .)
  733    { ("*"      (. Kind := zcMul; .)
  734      | "/"     (. Kind := zcDiv; .)
  735    /*  | "%" */
  736      ) Unary<Tmp>
  737           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  738              InOp := OutOp;
  739           .)
  740      }
  741  .
  742  /*------------------------------------------------------------------------*/
  743  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  744  =       (. LastOp := nil; Kind := zcNop; .)
  745    {
  746      (
  747        /* "+" | */
  748        "-"   (. Kind := zcNegate; .) |
  749        "++"  (. Kind := zcPreInc; .) |    
  750        "--"  (. Kind := zcPreDec; .) |
  751        "!"   (. Kind := zcNot; .)
  752        /* | "~" | "*" */
  753      )
  754      (.
  755         if Kind in [zcNegate,zcNot] then
  756         begin
  757           Tmp := MakeOp(Kind);
  758           if LastOp<>nil then
  759             LastOp.Children.Add(Tmp);
  760           LastOp := Tmp;
  761         end else if Assigned(LastOp) then
  762           ZError('-- and ++ cannot be combined with other unary ops');
  763      .)
  764    }
  765    Primary<Tmp>
  766      (.
  767         if Kind in [zcNop,zcNegate,zcNot] then
  768         begin
  769           if LastOp<>nil then
  770           begin
  771             LastOp.Children.Add(Tmp);
  772             OutOp := LastOp;
  773           end else
  774             OutOp := Tmp;
  775         end else
  776         begin
  777           OutOp := MakePrePostIncDec(Kind,Tmp);
  778         end;
  779      .)
  780  .
  781  
  782  
  783  
  784  /*------------------------------------------------------------------------*/
  785  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  786  (.
  787    var
  788      Op : TZcOp;
  789      Prop : TZProperty;
  790  .)
  791  = (. OutOp := nil; Op := nil; .)
  792    ident (.
  793      Prop := Ci.GetProperties.GetByName(LexString);
  794      if Prop=nil then
  795        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  796      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  797        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  798      OutOp := MakeOp(zcIdentifier);
  799      OutOp.Id := LexString;
  800    .)
  801    ":" Expr<Op>
  802    (. if Op=nil then
  803         ZError('Missing argument');
  804       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  805       OutOp.Children.Add(Op);
  806    .)
  807  .
  808  
  809  
  810  
  811  /*------------------------------------------------------------------------*/
  812  Primary<var OutOp : TZcOp>
  813  (. var Op : TZcOp; S : string; V : single;
  814       Typ : TZcDataType;
  815       Ci : TZComponentInfo;
  816  .)
  817  =            (. OutOp := nil; .)
  818    (
  819      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  820    | "@" ident (.
  821         Ci := ComponentManager.GetInfoFromName(LexString);
  822         if not Ci.ZClass.InheritsFrom(TCommand) then
  823           ZError('Class must inherit TCommand: ' + LexString);
  824         OutOp := TZcOpInvokeComponent.Create(nil);
  825         OutOp.Id := LexString;
  826      .)
  827      "(" (. IsInInvokeArg := True; .)
  828          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
  829            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
  830            }
  831          ]
  832      ")" (. IsInInvokeArg := False; .)
  833    | Literal<Typ>  (.
  834          if Typ.Kind in [zctString,zctNull] then
  835            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  836          else
  837          begin
  838            try
  839              S := LexString;
  840              V := ZcStrToFloat(S);
  841              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  842            except on EConvertError do
  843              SynError(200);
  844            end;
  845          end;
  846       .)
  847    | "(" Expr<OutOp> ")"
  848  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
  849      | "float"  | "int"    | "long" | "object"  | "sbyte"
  850      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  851      ) "." ident */
  852    )
  853  
  854    {
  855    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
  856    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
  857  
  858  /*  | "->" ident */
  859  
  860    | "." (. IsInIdent := True; .) ident (.
  861  
  862        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
  863          ZError('Invalid use of "."');
  864  
  865        Op := MakeOp(zcSelect,LexString);
  866        Op.Children.Add(OutOp);
  867  
  868        OutOp := CheckPrimary(Op);
  869  
  870        IsInIdent := False;
  871  
  872      .)
  873  
  874    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  875             OutOp.Kind:=zcFuncCall;
  876           .)
  877          [Argument<Op> (. OutOp.Children.Add(Op); .)
  878            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  879            }
  880          ]
  881          (.
  882             if not VerifyFunctionCall(OutOp,S) then
  883               ZError(S);
  884          .)
  885      ")"
  886  
  887    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  888             OutOp.Kind:=zcArrayAccess;
  889           .)
  890      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
  891        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
  892      "]"
  893  
  894    }
  895  .
  896  /*------------------------------------------------------------------------*/
  897  Literal<var Typ : TZcDataType>
  898  = intCon (. Typ.Kind :=zctInt; .) |
  899    realCon (. Typ.Kind := zctFloat; .) |
  900    stringCon (. Typ.Kind := zctString; .)
  901    | "null" (. Typ.Kind := zctNull; .)
  902    /* | "true" | "false"  */
  903  .
  904  
  905  END Zc.



