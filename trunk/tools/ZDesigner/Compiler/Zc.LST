

Compiled: den 14 september 2011 - 13:30:37
Output sent to: C:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\Compiler\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 14 september 2011 @ 13:30:37

Statistics:
  number of terminals:        91 (limit  2561)
  number of non-terminals:    33 (limit  1281)
  number of pragmas:           0 (limit  2470)
  number of symbolnodes:     124 (limit  2561)
  number of graphnodes:      400 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    25 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) Compiler
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;
   16      TempCounter : integer;
   17    PRIVATE
   18      CurrentFunction : TZcOpFunctionUserDefined;
   19      procedure CleanUp;
   20      procedure ZError(const S : string);
   21      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   22      function MakeTempName : string;
   23    CREATE
   24      ZFunctions := TObjectList.Create(False);
   25    DESTROY
   26      CleanUp;
   27    ERRORS
   28      200 : Result := 'Not a floating point value';
   29      201 : Result := 'Name already defined in this scope';
   30      202 : Result := 'Return value expected';
   31      203 : Result := 'Function should not return a value';
   32      204 : Result := 'Only function definitions are allowed here';
   33      205 : Result := 'Syntax not supported';
   34  END_DELPHI
   35  
   36  (* Arbitrary Code *)
   37  
   38  
   39  
   40  
   41  procedure T-->Grammar<--.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   42  begin
   43    if Op=nil then
   44    begin
   45      if SwitchOp.HasDefault then
   46        ZError('Only one default statement is allowed.');
   47      SwitchOp.HasDefault := True;
   48    end else
   49      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   50    SwitchOp.CaseOps.Last.Children.Add( Op );
   51    Op := nil;
   52  end;
   53  
   54  procedure T-->Grammar<--.CleanUp;
   55  begin
   56    Zc_Ops.FunctionCleanUps.Clear;
   57    ZFunctions.Free;
   58  end;
   59  
   60  function T-->Grammar<--.MakeTempName : string;
   61  begin
   62    Inc(TempCounter);
   63    Result := '#temp' + IntToStr(TempCounter);
   64  end;
   65  
   66  
   67  procedure T-->Grammar<--.ZError(const S : string);
   68  var
   69    E : EParseError;
   70  begin
   71    E := EParseError.Create(S);
   72    E.Message := S;
   73    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   74    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   75    raise E;
   76  end;
   77  
   78  
   79  CHARACTERS
   80  
   81          tab                = CHR(9). /*  9 = tabulator */
   82          eol                = CHR(10). /* 10 = line feed */
   83          cr                 = CHR(13). /* 13 = carriage return */
   84          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   85  
   86          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   87          digit              = "0123456789".
   88          hexDigit           = digit + "ABCDEFabcdef".
   89          notDigit           = ANY - digit.
   90  
   91          char               = ANY - "'" - '\' - newLine.
   92          verbatimStringChar = ANY - '"'.
   93          regularStringChar  = ANY - '"' - '\' - newLine.
   94          notNewLine         = ANY - newLine .
   95  
   96  
   97  TOKENS
   98  
   99    /*--------------------------------------------------------------------------------*/
  100          intCon =
  101                  ( digit {digit}
  102                  | ("0x" | "0X") hexDigit {hexDigit}
  103                  )
  104                  (* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] *)
  105                  .
  106    /*--------------------------------------------------------------------------------*/
  107          realCon =
  108                  "." digit {digit}
  109                  [("e" | "E") ["+" | "-"] digit {digit}]
  110                  ["F" | "f" | "D" | "d" | "M" | "m"]
  111          | digit {digit}
  112                  ( "." digit {digit}
  113                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  114                          ["F" | "f" | "D" | "d" | "M" | "m"]
  115                  | ("e" | "E") ["+" | "-"] digit {digit}
  116                          ["F" | "f" | "D" | "d" | "M" | "m"]
  117                  | "F" | "f" | "D" | "d" | "M" | "m"
  118                  ).
  119    /*--------------------------------------------------------------------------------*/
  120          stringCon =
  121                  '"'    { regularStringChar
  122            | "\'" | '\"' | "\\" | "\n"
  123            }
  124                  '"'.
  125  
  126          ident = ['@'] letter { letter | digit }.
  127  
  128  
  129          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  130          and    = "&".
  131          assgn  = "=".
  132          colon  = ":".
  133          comma  = ",".
  134          dec    = "--".
  135          div    = "/".
  136          dot    = ".".
  137          eq     = "==".
  138          gt     = ">".
  139          gte    = ">=".
  140          inc    = "++".
  141          lbrace = "{".
  142          lbrack = "[".
  143          lpar   = "(".
  144          lshift = "<<".
  145          lt     = "<".
  146          lte    = "<=".
  147          minus  = "-".
  148          mod    = "%".
  149          neq    = "!=".
  150          not    = "!".
  151          or     = "|".
  152          plus   = "+".
  153          rbrace = "}".
  154          rbrack = "]".
  155          rpar   = ")".
  156          rshift = ">>".
  157          scolon = ";".
  158          tilde  = "~".
  159          times  = "*".
  160          xor    = "^".
  161  
  162  
  163  
  164  COMMENTS FROM "/*" TO "*/"
  165  COMMENTS FROM "//" TO eol
  166  
  167  IGNORE eol + cr + tab
  168  
  169  PRODUCTIONS
  170  
  171  /*------------------------------------------------------------------------*
  172   *--------------------------- Declarations -------------------------------*
  173   *------------------------------------------------------------------------*/
  174  
  175  Zc (. var 
  176          I : integer;
  177          Func : TZcOpFunctionUserDefined; 
  178          Typ : TZcDataType;
  179      .)
  180  = 
  181  
  182    IF AllowFunctions THEN 
  183    BEGIN { 
  184      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (.
  185            if SymTab.Contains(LexString) then
  186              ZError('Name already defined: ' + LexString);
  187              
  188            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  189            Func.Id := LexString;
  190            Func.ReturnType := Typ;
  191            SymTab.Add(Func.Id,Func);
  192            ZFunctions.Add(Func); 
  193            Self.CurrentFunction := Func;
  194            SymTab.PushScope;
  195            try
  196         .)
  197      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  198          (. 
  199            finally
  200            SymTab.PopScope;
  201            end;
  202          .)
  203      } 
  204    END ELSE
  205    BEGIN
  206  
  207  
  208    (. 
  209         Func := TZcOpFunctionUserDefined.Create(nil);
  210         Func.ReturnType := Self.ReturnType;
  211         Self.CurrentFunction := Func;
  212         SymTab.PushScope;
  213         try
  214         ZFunctions.Add(Func);
  215    .)
  216  
  217    /* A zc-expression is treated like the body of a nameless function
  218       to allow local var declarations  */
  219  
  220    ZcFuncBody
  221  
  222    (. 
  223         finally
  224         SymTab.PopScope;
  225         end;
  226    .)
  227    END
  228  
  229  (.  
  230         if Successful then
  231         begin
  232           for I:=0 to ZFunctions.Count-1 do
  233             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  234         end;
  235  .)
  236  .
  237  
  238  /*------------------------------------------------------------------------*/
  239  
  240  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  241  =  {  (. Op:=nil; .)
  242        Statement<Op>
  243        (. if Op<>nil then
  244             CurrentFunction.Statements.Add(Op);
  245           Op := nil;
  246        .)
  247     }
  248  .
  249  
  250  /*------------------------------------------------------------------------*/
  251  FormalParams                    
  252  = ( Par ["," FormalParams] )
  253  .
  254  /*------------------------------------------------------------------------*/
  255  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  256  = Type<Typ> ident
  257       (.
  258          if SymTab.ScopeContains(LexString) then
  259            SynError(201)
  260          else
  261          begin
  262            Arg := TZcOpArgumentVar.Create(GlobalNames);
  263            Arg.Id := LexString;
  264            Arg.Typ := Typ;
  265            CurrentFunction.AddArgument(Arg);
  266            SymTab.Add(Arg.Id,Arg);
  267          end;
  268       .)
  269  .
  270  /*------------------------------------------------------------------------*/
  271  
  272  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  273  = (. OutOp := nil; .)
  274    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  275  .
  276  
  277  /*------------------------------------------------------------------------*/
  278  
  279  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  280  = ident
  281       (. 
  282          if SymTab.ScopeContains(LexString) then
  283            ZError('Name already defined: ' + LexString);
  284  
  285          Loc := TZcOpLocalVar.Create(nil);
  286          Loc.Id := LexString;
  287          Loc.Typ := Typ;
  288       .)
  289       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  290       (.
  291          SymTab.Add(Loc.Id,Loc);
  292          CurrentFunction.AddLocal(Loc);
  293  
  294          if Assigned(Loc.InitExpression) then
  295          begin
  296            //Generate tree for initial assignment
  297            if OutOp=nil then
  298              OutOp := MakeOp(zcBlock);
  299            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  300          end;
  301          
  302       .)
  303  .
  304  
  305  /*------------------------------------------------------------------------*/
  306  
  307  Init<var OutOp : TZcOp>
  308  = Expr<OutOp>
  309  .
  310  
  311  /*------------------------------------------------------------------------*/
  312  Argument<var OutOp : TZcOp>
  313  = /* ["ref" | "out"] */
  314    (. OutOp := nil; .)
  315    Expr<OutOp>
  316    (. if OutOp=nil then ZError('Missing argument'); .)
  317  .
  318  
  319  /*------------------------------------------------------------------------*
  320   *-------------------------------- Types ---------------------------------*
  321   *------------------------------------------------------------------------*/
  322  
  323  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  324   * and for array creation expressions                                     */
  325  
  326  
  327  Type<var Typ : TZcDataType>
  328  = ( SimpleType<Typ> )
  329  .
  330  
  331  /*------------------------------------------------------------------------*/
  332  
  333  SimpleType<var Typ : TZcDataType>
  334  /* = IntType | "float" | "double" | "decimal" | "bool" */
  335  = "float" (. Typ.Kind := zctFloat; .)
  336    | "int" (. Typ.Kind := zctInt; .)
  337    | "string" (. Typ.Kind := zctString; .)
  338    | "model" (. Typ.Kind := zctModel; .)
  339    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  340    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  341  .
  342  
  343  /*------------------------------------------------------------------------*/
  344  
  345  /* IntType
  346  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  347  . */
  348  
  349  
  350  /*------------------------------------------------------------------------*
  351   *------------------------------ Statements ------------------------------*
  352   *------------------------------------------------------------------------*/
  353  
  354  Statement<var OutOp : TZcOp>
  355  = (. OutOp := nil; .)
  356  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  357  (*IF IsLocalVarDecl THEN
  358  BEGIN
  359    LocalVarDecl ";"
  360  END
  361  |  EmbeddedStatement<OutOp> *)
  362  
  363  LocalVarDecl<OutOp> ";"
  364  | EmbeddedStatement<OutOp>
  365    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  366     * ident {"." ident} { "[" ...                           */
  367  .
  368  
  369  /*------------------------------------------------------------------------*/
  370  EmbeddedStatement<var OutOp : TZcOp>
  371    (. var
  372         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  373         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  374         WhileCondOp,WhileBodyOp : TZcOp;
  375         SwitchOp : TZcOpSwitch;
  376         Loc : TZcOpLocalVar;
  377    .)
  378  = Block<OutOp>
  379  | ";"   (. OutOp := MakeOp(zcNop); .)
  380  | StatementExpr<OutOp> ";"
  381  | "if" (. ElseOp := nil; .)
  382    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  383          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  384   | "switch" "(" Expr<SwitchValueOp> ")"
  385        (.
  386           Loc := TZcOpLocalVar.Create(nil);
  387           Loc.Id := MakeTempName;
  388           Loc.Typ := SwitchValueOp.GetDataType;
  389           SymTab.Add(Loc.Id,Loc);
  390           CurrentFunction.AddLocal(Loc);
  391  
  392           OutOp := MakeOp(zcBlock);
  393           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  394  
  395           SwitchOp := TZcOpSwitch.Create(nil);
  396           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  397           OutOp.Children.Add(SwitchOp);
  398        .)
  399     "{" {
  400       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  401       SwitchSection<SwitchOp>
  402     } "}"
  403   | "while"
  404       (. try
  405           SymTab.PushScope;
  406           WhileCondOp := nil; WhileBodyOp := nil; .)
  407     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  408     (.
  409           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  410         finally
  411           SymTab.PopScope;
  412         end;
  413     .)
  414   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  415   | "for"
  416      (. try
  417           SymTab.PushScope;
  418           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  419     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  420     (.
  421           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  422         finally
  423           SymTab.PopScope;
  424         end;
  425     .)
  426  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  427   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  428   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  429   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  430      (.
  431          if (Op=nil) then
  432          begin
  433            if CurrentFunction.ReturnType.Kind<>zctVoid then
  434              SynError(202)
  435            else
  436              OutOp := MakeOp(zcReturn);
  437          end else
  438          begin
  439            if CurrentFunction.ReturnType.Kind=zctVoid then
  440              SynError(203)
  441            else
  442              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  443          end;
  444      .)
  445  .
  446  /*------------------------------------------------------------------------*/
  447  
  448  Block<var OutOp : TZcOp>
  449    (. var
  450         Op : TZcOp;
  451    .)
  452  = (. Op := nil;
  453       OutOp := MakeOp(zcBlock);
  454    .)
  455    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  456  
  457  /*------------------------------------------------------------------------*/
  458  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  459  = (. Op1 :=nil; Op2 := nil; .)
  460    Unary<Op1>
  461    ( AssignOp<Kind> Expr<Op2>
  462      (.
  463        if Op2<>nil then
  464          OutOp := MakeAssign(Kind,Op1,Op2);
  465      .)
  466    |                             (. OutOp := Op1; .)
  467    )
  468  .
  469  
  470  /*------------------------------------------------------------------------*/
  471  AssignOp<var Kind : TZcAssignType>
  472  = "="     (. Kind := atAssign; .)
  473    | "+="  (. Kind := atPlusAssign; .)
  474    | "-="  (. Kind := atMinusAssign; .)
  475    | "*="  (. Kind := atMulAssign; .)
  476    | "/="  (. Kind := atDivAssign; .)
  477  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  478  .
  479  
  480  /*------------------------------------------------------------------------*/
  481  
  482  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  483  = (. Op := nil; .)
  484    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  485    {
  486      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  487    }
  488    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  489    {
  490       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  491    }
  492  .
  493  
  494  /*------------------------------------------------------------------------*/
  495  
  496  SwitchLabel<var OutOp : TZcOp>
  497  = "case" Expr<OutOp> ":"
  498  | "default" ":"
  499  .
  500  
  501  /*------------------------------------------------------------------------*/
  502  
  503  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  504  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  505  (
  506  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  507  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  508    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  509  )
  510  .  
  511  
  512  /*------------------------------------------------------------------------*/
  513  
  514  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  515  = (. Op:=nil; 
  516       OutOp := MakeOp(zcBlock);
  517    .) 
  518  (
  519  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  520  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  521  )
  522  . 
  523  
  524  
  525  /*------------------------------------------------------------------------*
  526   *----------------------------- Expressions ------------------------------*
  527   *------------------------------------------------------------------------*/
  528  
  529  
  530  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  531  = (. Op1 :=nil; Op2 := nil; .)
  532    Unary<Op1>
  533    ( OrExpr<Op1,OutOp>
  534        ["?" Expr<Op1> ":" Expr<Op2>
  535           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  536                SynError(205)
  537              else
  538                OutOp := MakeOp(zcConditional,[OutOp,Op1,Op2]);
  539           .)
  540        ]
  541    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  542    )
  543  .
  544  /*------------------------------------------------------------------------*/
  545  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  546  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  547      {"||" Unary<Op> AndExpr<Op,R>
  548        (. OutOp := MakeOp(zcOr,[L,R]);
  549           L := OutOp; .)
  550      }
  551  .
  552  
  553  
  554  /*------------------------------------------------------------------------*/
  555  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  556  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  557      {"&&" Unary<Op> BitOrExpr<Op,R>
  558        (. OutOp := MakeOp(zcAnd,[L,R]);
  559           L := OutOp; .)
  560      }
  561  .
  562  /*------------------------------------------------------------------------*/
  563  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  564  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  565    {"|" Unary<Op> BitXorExpr<Op,R>
  566      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  567         L := OutOp; .)
  568    }
  569  .
  570  
  571  /*------------------------------------------------------------------------*/
  572  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  573  = BitAndExpr<InOp,OutOp> {"^" (. SynError(205); .) Unary<Op> BitAndExpr<InOp,OutOp>}
  574  .
  575  
  576  /*------------------------------------------------------------------------*/
  577  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  578  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  579    {"&" Unary<Op> EqlExpr<Op,R>
  580      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  581         L := OutOp; .)
  582    }
  583  .
  584  
  585  /*------------------------------------------------------------------------*/
  586  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  587  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  588    {( "!="   (. Kind := zcCompNE; .)
  589     | "=="   (. Kind := zcCompEQ; .)
  590     )
  591     Unary<Op> RelExpr<Op,R>
  592           (. OutOp := MakeBinary(Kind, L,R);
  593              L := OutOp;
  594           .)
  595    }
  596  .
  597  /*------------------------------------------------------------------------*/
  598  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  599  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  600    { ( "<"       (. Kind := zcCompLT; .)
  601      | ">"       (. Kind := zcCompGT; .)
  602      | "<="      (. Kind := zcCompLE; .)
  603      | ">="      (. Kind := zcCompGE; .)
  604       )
  605      Unary<Op> ShiftExpr<Op,R>
  606           (. OutOp := MakeBinary(Kind, L,R );
  607              L := OutOp;
  608           .)
  609    }
  610  .
  611  /*------------------------------------------------------------------------*/
  612  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ ShiftExpr is a deletable symbol
  613  = AddExpr<InOp,OutOp> (. L := OutOp; .)
  614    { ("<<"  (. Kind := zcBinaryShiftL; .)
  615      | ">>" (. Kind := zcBinaryShiftR; .)
  616      )
  617      Unary<Op> AddExpr<Op,R>
  618      (. OutOp := MakeOp(Kind,[L,R]);
  619         L := OutOp; .)
  620    }
  621  .
  622  /*------------------------------------------------------------------------*/
  623  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  624  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  625      {( "+"    (. Kind := zcPlus; .)
  626       | "-"    (. Kind := zcMinus; .)
  627       ) Unary<Op> MulExpr<Op,R>
  628           (. 
  629              if (L=nil) or (R=nil) then
  630                ZError('Invalid syntax');
  631              OutOp := MakeBinary(Kind,L,R);
  632              L := OutOp;
  633           .)
  634      }
  635  .
  636  /*------------------------------------------------------------------------*/
  637  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  638  =       (. OutOp := InOp; .)
  639    { ("*"      (. Kind := zcMul; .)
  640      | "/"     (. Kind := zcDiv; .)
  641    (*  | "%" *)
  642      ) Unary<Tmp>
  643           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  644              InOp := OutOp;
  645           .)
  646      }
  647  .
  648  /*------------------------------------------------------------------------*/
  649  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  650  =       (. LastOp := nil; Kind := zcNop; .)
  651    {
  652      (
  653        (* "+" | *)
  654        "-"   (. Kind := zcNegate; .) |
  655        "++"  (. Kind := zcPreInc; .) |    
  656        "--"  (. Kind := zcPreDec; .) |
  657        "!"   (. Kind := zcNot; .)
  658        (* | "~" | "*" *)
  659      )
  660      (.
  661         if Kind in [zcNegate,zcNot] then
  662         begin
  663           Tmp := MakeOp(Kind);
  664           if LastOp<>nil then
  665             LastOp.Children.Add(Tmp);
  666           LastOp := Tmp;
  667         end else if Assigned(LastOp) then
  668           ZError('-- and ++ cannot be combined with other unary ops');
  669      .)
  670    }
  671    Primary<Tmp>
  672      (.
  673         if Kind in [zcNop,zcNegate,zcNot] then
  674         begin
  675           if LastOp<>nil then
  676           begin
  677             LastOp.Children.Add(Tmp);
  678             OutOp := LastOp;
  679           end else
  680             OutOp := Tmp;
  681         end else
  682         begin
  683           OutOp := MakePrePostIncDec(Kind,Tmp);
  684         end;
  685      .)
  686  .
  687  /*------------------------------------------------------------------------*/
  688  Primary<var OutOp : TZcOp>
  689  (. var Op : TZcOp; S : string; V : single;
  690       Typ : TZcDataType;
  691  .)
  692  =            (. OutOp := nil; .)
  693    (
  694      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  695    | Literal<Typ>  (.
  696          if Typ.Kind in [zctString,zctNull] then
  697            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  698          else
  699          begin
  700            try
  701              S := LexString;
  702              V := ZcStrToFloat(S);
  703              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  704            except on EConvertError do
  705              SynError(200);
  706            end;
  707          end;
  708       .)
  709    | "(" Expr<OutOp> ")"
  710  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  711      | "float"  | "int"    | "long" | "object"  | "sbyte"
  712      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  713      ) "." ident *)
  714    )
  715  
  716    {
  717    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
  718    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
  719  
  720  /*  | "->" ident */
  721  
  722    | "." ident (.
  723  
  724        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
  725          ZError('Invalid use of "."');
  726  
  727        Op := MakeOp(zcSelect,LexString);
  728        Op.Children.Add(OutOp);
  729  
  730        OutOp := CheckPrimary(Op);
  731  
  732      .)
  733  
  734    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  735             OutOp.Kind:=zcFuncCall;
  736           .)
  737          [Argument<Op> (. OutOp.Children.Add(Op); .)
  738            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  739            }
  740          ]
  741          (.
  742             if not VerifyFunctionCall(OutOp,S) then
  743               ZError(S);
  744          .)
  745      ")"
  746  
  747    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  748             OutOp.Kind:=zcArrayAccess;
  749           .)
  750      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
  751        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
  752      "]"
  753  
  754    }
  755  .
  756  /*------------------------------------------------------------------------*/
  757  Literal<var Typ : TZcDataType>
  758  = intCon (. Typ.Kind :=zctInt; .) |
  759    realCon (. Typ.Kind := zctFloat; .) |
  760    stringCon (. Typ.Kind := zctString; .)
  761    | "null" (. Typ.Kind := zctNull; .)
  762    (* | "true" | "false"  *)
  763  .
  764  
  765  END Zc.

    1 LL(1) error
   11 warnings

