
Listing
-------
0 errors and 45 warnings
*****  Warning: LL1 warning in ZcFuncBody:"vec3" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec2" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"mat4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"byte" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"reinterpret_cast" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"File" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      ZApp : TZApplication;
   15      destructor Destroy; override;
   16      procedure CheckHomograph(var sym: Integer); override;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      .)
   26  precreate = (.
   27      ZFunctions := TObjectList.Create(False);
   28      Self.OnError := OnParserError;
   29  
   30  .)
   31  
   32  semErrors = (.
   33      200 : Result := 'Not a floating point value';
   34      201 : Result := 'Name already defined in this scope';
   35      202 : Result := 'Return value expected';
   36      203 : Result := 'Function should not return a value';
   37      204 : Result := 'Only function definitions are allowed here';
   38      205 : Result := 'Syntax not supported';
   39  .)
   40  
   41  implementation = (.
   42  
   43  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   44  begin
   45    ZError(Msg + ' ' + Data);
   46  end;
   47  
   48  procedure TZc.CheckHomograph(var sym: Integer);
   49  begin
   50    //Only Homographs are name of component datatypes
   51    //If inside identifier "x.y.z" then let it refer to identifier instead
   52    if IsInIdent or IsInInvokeArg then
   53      sym := identSym;
   54  end;
   55  
   56  destructor TZc.Destroy;
   57  begin
   58    inherited;
   59    CleanUp;
   60  end;
   61  
   62  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   63  begin
   64    if Op=nil then
   65    begin
   66      if SwitchOp.HasDefault then
   67        ZError('Only one default statement is allowed.');
   68      SwitchOp.HasDefault := True;
   69    end else
   70      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   71    SwitchOp.CaseOps.Last.Children.Add( Op );
   72    Op := nil;
   73  end;
   74  
   75  procedure TZc.CleanUp;
   76  begin
   77    Zc_Ops.FunctionCleanUps.Clear;
   78    ZFunctions.Free;
   79  end;
   80  
   81  procedure TZc.ZError(const S : string);
   82  var
   83    E : EParseError;
   84    P : TSymbolRec;
   85  begin
   86    E := EParseError.Create(S);
   87    E.Message := S;
   88    Scanner.GetPosition(P);
   89    E.Line := P.Line;
   90    E.Col := P.Col;
   91    if (E.Line<>0) or (E.Col<>0) then
   92      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   93    raise E;
   94  end;
   95  
   96  .)
   97  
   98  END
   99  
  100  
  101  CHARACTERS
  102  
  103          tab                = CHR(9). /*  9 = tabulator */
  104          eol                = CHR(10). /* 10 = line feed */
  105          cr                 = CHR(13). /* 13 = carriage return */
  106          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  107  
  108          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  109          digit              = "0123456789".
  110          hexDigit           = digit + "ABCDEFabcdef".
  111          notDigit           = ANY - digit.
  112  
  113          char               = ANY - "'" - '\' - newLine.
  114          verbatimStringChar = ANY - '"'.
  115          regularStringChar  = ANY - '"' - '\' - newLine.
  116          notNewLine         = ANY - newLine .
  117  
  118  
  119  TOKENS
  120  
  121    /*--------------------------------------------------------------------------------*/
  122          intCon =
  123                  ( digit {digit}
  124                  | ("0x" | "0X") hexDigit {hexDigit}
  125                  )
  126                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  127                  .
  128    /*--------------------------------------------------------------------------------*/
  129          realCon =
  130                  "." digit {digit}
  131                  [("e" | "E") ["+" | "-"] digit {digit}]
  132                  ["F" | "f" | "D" | "d" | "M" | "m"]
  133          | digit {digit}
  134                  ( "." digit {digit}
  135                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  136                          ["F" | "f" | "D" | "d" | "M" | "m"]
  137                  | ("e" | "E") ["+" | "-"] digit {digit}
  138                          ["F" | "f" | "D" | "d" | "M" | "m"]
  139                  | "F" | "f" | "D" | "d" | "M" | "m"
  140                  ).
  141    /*--------------------------------------------------------------------------------*/
  142          stringCon =
  143                  '"'    { regularStringChar
  144            | "\'" | '\"' | "\\" | "\n"
  145            }
  146                  '"'.
  147  
  148          ident = letter { letter | digit }.
  149  
  150  
  151          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  152          and    = "&".
  153          assgn  = "=".
  154          colon  = ":".
  155          comma  = ",".
  156          dec    = "--".
  157          div    = "/".
  158          dot    = ".".
  159          eq     = "==".
  160          gt     = ">".
  161          gte    = ">=".
  162          inc    = "++".
  163          lbrace = "{".
  164          lbrack = "[".
  165          lpar   = "(".
  166          lshift = "<<".
  167          lt     = "<".
  168          lte    = "<=".
  169          minus  = "-".
  170          mod    = "%".
  171          neq    = "!=".
  172          not    = "!".
  173          or     = "|".
  174          plus   = "+".
  175          rbrace = "}".
  176          rbrack = "]".
  177          rpar   = ")".
  178          rshift = ">>".
  179          scolon = ";".
  180          tilde  = "~".
  181          times  = "*".
  182          xor    = "^".
  183  
  184  
  185  
  186  COMMENTS FROM "/*" TO "*/"
  187  COMMENTS FROM "//" TO eol
  188  
  189  IGNORE eol + cr + tab
  190  
  191  HOMOGRAPHS
  192    "Material"
  193    "Sound"
  194    "Shader" 
  195    "Bitmap" 
  196    "Mesh"
  197    "Camera" 
  198    "Font"
  199    "Sample"
  200    "File"
  201  
  202  PRODUCTIONS
  203  
  204  /*------------------------------------------------------------------------*
  205   *--------------------------- Declarations -------------------------------*
  206   *------------------------------------------------------------------------*/
  207  
  208  ZcFuncRest<Typ : TZcDataType; const Name : string>
  209  (.
  210  var
  211    Func : TZcOpFunctionUserDefined;
  212  .)
  213  =
  214       (.
  215          if SymTab.Contains(Name) then
  216            ZError('Name already defined: ' + Name);
  217  
  218          Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  219          Func.Id := Name;
  220          Func.ReturnType := Typ;
  221          SymTab.Add(Func.Id,Func);
  222          ZFunctions.Add(Func);
  223          Self.CurrentFunction := Func;
  224          SymTab.PushScope;
  225          try
  226       .)
  227      [ FormalParams ] ")" "{" ZcFuncBody "}"
  228          (.
  229            finally
  230              SymTab.PopScope;
  231            end;
  232          .)
  233  .
  234  
  235  
  236  Zc (. var
  237          Typ : TZcDataType;
  238          Func : TZcOpFunctionUserDefined;
  239          Name : string;
  240      .)
  241  =
  242    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  243    {
  244      ConstantDeclarationList
  245      |
  246      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  247         /* Need to separate between global variable and method declarations */
  248         (
  249           "(" ZcFuncRest<Typ,Name>
  250           | GlobalVarDecl<Typ,Name> ";"
  251         )
  252    }
  253    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  254    {
  255  
  256    (.
  257         Func := TZcOpFunctionUserDefined.Create(nil);
  258         Func.ReturnType := Self.ReturnType;
  259         Self.CurrentFunction := Func;
  260         try
  261           SymTab.PushScope;
  262           try
  263             ZFunctions.Add(Func);
  264    .)
  265    /* A zc-expression is treated like the body of a nameless function
  266       to allow local var declarations  */
  267  
  268    ZcFuncBody
  269    (.
  270           finally
  271             SymTab.PopScope;
  272           end;
  273         except on E: Exception do
  274           ZError(E.Message);
  275         end;
  276    .)
  277    }
  278  
  279  .
  280  
  281  /*------------------------------------------------------------------------*/
  282  
  283  ZcFuncBody (. var Op : TZcOp; .)
  284  =  {  (. Op:=nil; .)
  285        Statement<Op>
  286        (. if Op<>nil then
  287             CurrentFunction.Statements.Add(Op);
  288           Op := nil;
  289        .)
  290     }
  291  .
  292  
  293  /*------------------------------------------------------------------------*/
  294  FormalParams
  295  = ( Par ["," FormalParams] )
  296  .
  297  /*------------------------------------------------------------------------*/
  298  Par (.
  299  var
  300    Typ : TZcDataType;
  301    Arg : TZcOpArgumentVar;
  302    IsPtr : boolean;
  303  .)
  304  =  (. IsPtr := False; .)
  305    ["ref" (. IsPtr := True; .) ]
  306    Type<Typ> ident
  307       (.
  308          Typ.IsPointer := IsPtr;
  309          if SymTab.ScopeContains(LexString) then
  310            SynError(201)
  311          else
  312          begin
  313            Arg := TZcOpArgumentVar.Create;
  314            Arg.Id := LexString;
  315            Arg.Typ := Typ;
  316            CurrentFunction.AddArgument(Arg);
  317            SymTab.Add(Arg.Id,Arg);
  318          end;
  319       .)
  320  .
  321  /*------------------------------------------------------------------------*/
  322  
  323  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  324  = (. OutOp := nil; .)
  325    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  326  .
  327  
  328  /*------------------------------------------------------------------------*/
  329  
  330  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  331  = ident
  332       (. 
  333          if SymTab.ScopeContains(LexString) then
  334            ZError('Name already defined: ' + LexString);
  335  
  336          Loc := TZcOpLocalVar.Create(nil);
  337          Loc.Id := LexString;
  338          Loc.Typ := Typ;
  339       .)
  340       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  341       (.
  342          SymTab.Add(Loc.Id,Loc);
  343          CurrentFunction.AddLocal(Loc);
  344  
  345          if Assigned(Loc.InitExpression) then
  346          begin
  347            //Generate tree for initial assignment
  348            if OutOp=nil then
  349              OutOp := MakeOp(zcBlock);
  350            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  351          end;
  352  
  353       .)
  354  .
  355  
  356  /*------------------------------------------------------------------------*/
  357  
  358  GlobalVarRest<Typ : TZcDataType; const Name : string> (. var V : TDefineVariableBase; .)
  359  =
  360       (.
  361          if SymTab.ScopeContains(Name) then
  362            ZError('Name already defined: ' + Name);
  363  
  364          if Typ.Kind=zctArray then
  365          begin
  366            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  367            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  368            Self.ZApp.GlobalVars.AddComponent(V);
  369          end
  370          else
  371          begin
  372            V := TDefineVariable.Create(Self.ZApp.GlobalVars);
  373            V._Type := Typ.Kind;
  374          end;
  375  
  376          V.SetString('Name', AnsiString(Name));
  377          V.DesignerReset; //Needed to init managed variables
  378          SymTab.Add(Name,V);
  379       .)
  380  .
  381  
  382  
  383  GlobalVar<Typ : TZcDataType>
  384  = ident GlobalVarRest<Typ,LexString>
  385  .
  386  
  387  GlobalVarDecl<Typ : TZcDataType; const Name : string>
  388  = GlobalVarRest<Typ,Name> {"," GlobalVar<Typ>}
  389  .
  390  
  391  /*------------------------------------------------------------------------*/
  392  
  393  Init<var OutOp : TZcOp>
  394  = Expr<OutOp>
  395  .
  396  
  397  /*------------------------------------------------------------------------*/
  398  Argument<var OutOp : TZcOp>
  399  = /* ["ref" | "out"] */
  400    (. OutOp := nil; .)
  401    Expr<OutOp>
  402    (. if OutOp=nil then ZError('Missing argument'); .)
  403  .
  404  
  405  /*------------------------------------------------------------------------*
  406   *-------------------------------- Types ---------------------------------*
  407   *------------------------------------------------------------------------*/
  408  
  409  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  410   * and for array creation expressions                                     */
  411  
  412  
  413  Type<var Typ : TZcDataType>
  414  (.
  415    var
  416      A : TDefineArray;
  417      SizeOp : TZcOp;
  418      I : integer;
  419  .)
  420  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  421    ( SimpleType<Typ> )
  422    {
  423      (
  424        "["       (.
  425                     A := TDefineArray.Create(nil);
  426                     GlobalNames.Add(A);
  427                     A._Type := Typ.Kind;
  428                     Typ.Kind := zctArray;
  429                     Typ.TheArray := A;
  430                  .)
  431  
  432           [ Expr<SizeOp> (.
  433              SizeOp := SizeOp.Optimize;
  434              if SizeOp.Kind<>zcConstLiteral then
  435                ZError('Array size must be a constant expression');
  436              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  437                           .)
  438           ]
  439  
  440           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  441             [ Expr<SizeOp> (.
  442                  SizeOp := SizeOp.Optimize;
  443                  if SizeOp.Kind<>zcConstLiteral then
  444                    ZError('Array size must be a constant expression');
  445                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  446                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  447             .) ]
  448           }
  449         "]"
  450      )
  451    }
  452  .
  453  
  454  /*------------------------------------------------------------------------*/
  455  
  456  SimpleType<var Typ : TZcDataType>
  457  (.
  458    var
  459      A : TDefineArray;
  460  .)
  461  /* = IntType | "float" | "double" | "decimal" | "bool" */
  462  = "float" (. Typ.Kind := zctFloat; .)
  463    | "int" (. Typ.Kind := zctInt; .)
  464    | "byte" (. Typ.Kind := zctByte; .)
  465    | "string" (. Typ.Kind := zctString; .)
  466    | "model" (. Typ.Kind := zctModel; .)
  467    | "xptr" (. Typ.Kind := zctXptr; .)
  468  
  469    | "mat4" (.
  470       A := Prototypes.Mat4Array;
  471       Typ.Kind := zctMat4;
  472       Typ.TheArray := A;
  473      .)
  474    | "vec2" (.
  475       A := Prototypes.Vec2Array;
  476       Typ.Kind := zctVec2;
  477       Typ.TheArray := A;
  478    .)
  479    | "vec3" (.
  480       A := Prototypes.Vec3Array;
  481       Typ.Kind := zctVec3;
  482       Typ.TheArray := A;
  483    .)
  484    | "vec4" (.
  485       A := Prototypes.Vec4Array;
  486       Typ.Kind := zctVec4;
  487       Typ.TheArray := A;
  488    .)
  489  
  490    /* Changes below also must be made in homographs-section */
  491    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  492    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  493    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  494    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  495    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  496    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  497    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  498    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  499    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  500  .
  501  
  502  /*------------------------------------------------------------------------*/
  503  
  504  /* IntType
  505  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  506  . */
  507  
  508  
  509  ConstantDeclarationList
  510  (.
  511  var
  512    Typ : TZcDataType;
  513  .)
  514  = "const" Type<Typ> ConstantDeclaration<Typ> {"," ConstantDeclaration<Typ> }
  515    ";"
  516  .
  517  
  518  ConstantDeclaration<var Typ : TZcDataType>
  519  (.
  520  var
  521    Cns : TDefineConstant;
  522    Op : TZcOp;
  523    Lit : TZcOpLiteral;
  524    CnsName : string;
  525  .)
  526  =
  527  ident (. CnsName := LexString; .) "=" Expr<Op>
  528    (.
  529     Op := Op.Optimize;
  530     if not (Op is TZcOpLiteral) then
  531       ZError('Constant expression expected: ' + Op.ToString);
  532  
  533     Lit := Op as TZcOpLiteral;
  534  
  535     if Lit.Typ.Kind<>Typ.Kind then
  536       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  537  
  538     Cns := TDefineConstant.Create(nil);
  539     Cns.SetString('Name',AnsiString(CnsName));
  540     GlobalNames.Add(Cns);
  541  
  542     case Typ.Kind of
  543       zctInt:
  544         begin
  545           Cns._Type := zctInt;
  546           Cns.IntValue := Round(Lit.Value);
  547         end;
  548       zctFloat:
  549         begin
  550           Cns._Type := zctFloat;
  551           Cns.Value := Lit.Value;
  552         end;
  553       zctString:
  554         begin
  555           Cns._Type := zctString;
  556           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  557         end;
  558       else
  559         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  560     end;
  561     SymTab.Add(CnsName,Cns);
  562    .)
  563  /* {"," ident "=" Expr<Op>} */
  564  .
  565  
  566  /*------------------------------------------------------------------------*
  567   *------------------------------ Statements ------------------------------*
  568   *------------------------------------------------------------------------*/
  569  
  570  Statement<var OutOp : TZcOp>
  571  = (. OutOp := nil; .)
  572  
  573  ConstantDeclarationList
  574  
  575  /*IF IsLocalVarDecl THEN
  576  BEGIN
  577    LocalVarDecl ";"
  578  END
  579  |  EmbeddedStatement<OutOp> */
  580  
  581  | LocalVarDecl<OutOp> ";"
  582  | EmbeddedStatement<OutOp>
  583    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  584     * ident {"." ident} { "[" ...                           */
  585  .
  586  
  587  /*------------------------------------------------------------------------*/
  588  EmbeddedStatement<var OutOp : TZcOp>
  589    (. var
  590         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  591         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  592         WhileCondOp,WhileBodyOp : TZcOp;
  593         SwitchOp : TZcOpSwitch;
  594         Loc : TZcOpLocalVar;
  595    .)
  596  = Block<OutOp>
  597  | ";"   (. OutOp := MakeOp(zcNop); .)
  598  | StatementExpr<OutOp> ";"
  599  | "if" (. ElseOp := nil; .)
  600    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  601          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  602   | "switch" "(" Expr<SwitchValueOp> ")"
  603        (.
  604           Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
  605           SymTab.Add(Loc.Id,Loc);
  606           CurrentFunction.AddLocal(Loc);
  607  
  608           OutOp := MakeOp(zcBlock);
  609           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  610  
  611           SwitchOp := TZcOpSwitch.Create(nil);
  612           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  613           OutOp.Children.Add(SwitchOp);
  614        .)
  615     "{" {
  616       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  617       SwitchSection<SwitchOp>
  618     } "}"
  619   | "while"
  620       (. try
  621           SymTab.PushScope;
  622           WhileCondOp := nil; WhileBodyOp := nil; .)
  623     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  624     (.
  625           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  626         finally
  627           SymTab.PopScope;
  628         end;
  629     .)
  630   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  631   | "for"
  632      (. try
  633           SymTab.PushScope;
  634           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  635     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  636     (.
  637           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  638         finally
  639           SymTab.PopScope;
  640         end;
  641     .)
  642  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  643   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  644   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  645   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  646      (.
  647          if (Op=nil) then
  648          begin
  649            if CurrentFunction.ReturnType.Kind<>zctVoid then
  650              SynError(202)
  651            else
  652              OutOp := MakeOp(zcReturn);
  653          end else
  654          begin
  655            if CurrentFunction.ReturnType.Kind=zctVoid then
  656              SynError(203)
  657            else
  658              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  659          end;
  660      .)
  661  .
  662  /*------------------------------------------------------------------------*/
  663  
  664  Block<var OutOp : TZcOp>
  665    (. var
  666         Op : TZcOp;
  667    .)
  668  = (. Op := nil;
  669       OutOp := MakeOp(zcBlock);
  670    .)
  671    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  672  
  673  /*------------------------------------------------------------------------*/
  674  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  675  = (. Op1 :=nil; Op2 := nil; .)
  676    Unary<Op1>
  677    ( AssignOp<Kind> Expr<Op2>
  678      (.
  679        if Op2<>nil then
  680          OutOp := MakeAssign(Kind,Op1,Op2);
  681      .)
  682    |                             (. OutOp := Op1; .)
  683    )
  684  .
  685  
  686  /*------------------------------------------------------------------------*/
  687  AssignOp<var Kind : TZcAssignType>
  688  = "="     (. Kind := atAssign; .)
  689    | "+="  (. Kind := atPlusAssign; .)
  690    | "-="  (. Kind := atMinusAssign; .)
  691    | "*="  (. Kind := atMulAssign; .)
  692    | "/="  (. Kind := atDivAssign; .)
  693  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  694  .
  695  
  696  /*------------------------------------------------------------------------*/
  697  
  698  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  699  = (. Op := nil; .)
  700    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  701    {
  702      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  703    }
  704    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  705    {
  706       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  707    }
  708  .
  709  
  710  /*------------------------------------------------------------------------*/
  711  
  712  SwitchLabel<var OutOp : TZcOp>
  713  = "case" Expr<OutOp> ":"
  714  | "default" ":"
  715  .
  716  
  717  /*------------------------------------------------------------------------*/
  718  
  719  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  720  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  721  (
  722  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  723  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  724    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  725  )
  726  .  
  727  
  728  /*------------------------------------------------------------------------*/
  729  
  730  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  731  = (. Op:=nil; 
  732       OutOp := MakeOp(zcBlock);
  733    .) 
  734  (
  735  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  736  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  737  )
  738  . 
  739  
  740  
  741  /*------------------------------------------------------------------------*
  742   *----------------------------- Expressions ------------------------------*
  743   *------------------------------------------------------------------------*/
  744  
  745  
  746  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  747  = (. Op1 :=nil; Op2 := nil; .)
  748    Unary<Op1>
  749    ( OrExpr<Op1,OutOp>
  750        ["?" Expr<Op1> ":" Expr<Op2>
  751           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  752                SynError(205)
  753              else
  754                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  755           .)
  756        ]
  757    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  758    )
  759  .
  760  /*------------------------------------------------------------------------*/
  761  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  762  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  763      {"||" Unary<Op> AndExpr<Op,R>
  764        (. OutOp := MakeOp(zcOr,[L,R]);
  765           L := OutOp; .)
  766      }
  767  .
  768  
  769  
  770  /*------------------------------------------------------------------------*/
  771  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  772  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  773      {"&&" Unary<Op> BitOrExpr<Op,R>
  774        (. OutOp := MakeOp(zcAnd,[L,R]);
  775           L := OutOp; .)
  776      }
  777  .
  778  /*------------------------------------------------------------------------*/
  779  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  780  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  781    {"|" Unary<Op> BitXorExpr<Op,R>
  782      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  783         L := OutOp; .)
  784    }
  785  .
  786  
  787  /*------------------------------------------------------------------------*/
  788  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  789  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  790    {"^" Unary<Op> BitAndExpr<Op,R>
  791      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  792         L := OutOp; .)
  793    }
  794  .
  795  
  796  /*------------------------------------------------------------------------*/
  797  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  798  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  799    {"&" Unary<Op> EqlExpr<Op,R>
  800      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  801         L := OutOp; .)
  802    }
  803  .
  804  
  805  /*------------------------------------------------------------------------*/
  806  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  807  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  808    {( "!="   (. Kind := zcCompNE; .)
  809     | "=="   (. Kind := zcCompEQ; .)
  810     )
  811     Unary<Op> RelExpr<Op,R>
  812           (. OutOp := MakeBinary(Kind, L,R);
  813              L := OutOp;
  814           .)
  815    }
  816  .
  817  /*------------------------------------------------------------------------*/
  818  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  819  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  820    { ( "<"       (. Kind := zcCompLT; .)
  821      | ">"       (. Kind := zcCompGT; .)
  822      | "<="      (. Kind := zcCompLE; .)
  823      | ">="      (. Kind := zcCompGE; .)
  824       )
  825      Unary<Op> ShiftExpr<Op,R>
  826           (. OutOp := MakeBinary(Kind, L,R );
  827              L := OutOp;
  828           .)
  829    }
  830  .
  831  /*------------------------------------------------------------------------*/
  832  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  833  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  834    { ("<<"  (. Kind := zcBinaryShiftL; .)
  835      | ">>" (. Kind := zcBinaryShiftR; .)
  836      )
  837      Unary<Op> AddExpr<Op,R>
  838      (. OutOp := MakeOp(Kind,[L,R]);
  839         L := OutOp; .)
  840    }
  841  .
  842  /*------------------------------------------------------------------------*/
  843  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  844  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  845      {( "+"    (. Kind := zcPlus; .)
  846       | "-"    (. Kind := zcMinus; .)
  847       ) Unary<Op> MulExpr<Op,R>
  848           (. 
  849              if (L=nil) or (R=nil) then
  850                ZError('Invalid syntax');
  851              OutOp := MakeBinary(Kind,L,R);
  852              L := OutOp;
  853           .)
  854      }
  855  .
  856  /*------------------------------------------------------------------------*/
  857  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  858  = (. OutOp := InOp; Kind := zcNop; .)
  859    { ("*"      (. Kind := zcMul; .)
  860      | "/"     (. Kind := zcDiv; .)
  861      | "%"     (. Kind := zcMod; .)
  862      ) Unary<Tmp>
  863           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  864              InOp := OutOp;
  865           .)
  866      }
  867  .
  868  /*------------------------------------------------------------------------*/
  869  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  870  =       (. LastOp := nil; Kind := zcNop; .)
  871    {
  872      (
  873        /* "+" | */
  874        "-"   (. Kind := zcNegate; .) |
  875        "++"  (. Kind := zcPreInc; .) |    
  876        "--"  (. Kind := zcPreDec; .) |
  877        "!"   (. Kind := zcNot; .)
  878        /* | "~" | "*" */
  879      )
  880      (.
  881         if Kind in [zcNegate,zcNot] then
  882         begin
  883           Tmp := MakeOp(Kind);
  884           if LastOp<>nil then
  885             LastOp.Children.Add(Tmp);
  886           LastOp := Tmp;
  887         end else if Assigned(LastOp) then
  888           ZError('-- and ++ cannot be combined with other unary ops');
  889      .)
  890    }
  891    Primary<Tmp>
  892      (.
  893         if Kind in [zcNop,zcNegate,zcNot] then
  894         begin
  895           if LastOp<>nil then
  896           begin
  897             LastOp.Children.Add(Tmp);
  898             OutOp := LastOp;
  899           end else
  900             OutOp := Tmp;
  901         end else
  902         begin
  903           OutOp := MakePrePostIncDec(Kind,Tmp);
  904         end;
  905      .)
  906  .
  907  
  908  
  909  
  910  /*------------------------------------------------------------------------*/
  911  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  912  (.
  913    var
  914      Op : TZcOp;
  915      Prop : TZProperty;
  916  .)
  917  = (. OutOp := nil; Op := nil; .)
  918    ident (.
  919      Prop := Ci.GetProperties.GetByName(LexString);
  920      if Prop=nil then
  921        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  922      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  923        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  924      OutOp := MakeOp(zcIdentifier);
  925      OutOp.Id := LexString;
  926    .)
  927    ":" Expr<Op>
  928    (. if Op=nil then
  929         ZError('Missing argument');
  930       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  931       OutOp.Children.Add(Op);
  932    .)
  933  .
  934  
  935  
  936  /*------------------------------------------------------------------------*/
  937  ReinterpretCast<var OutOp : TZcOp>
  938  (.
  939  var
  940    Op : TZcOp;
  941    Typ : TZcDataType;
  942  .)
  943  = "reinterpret_cast" "<" SimpleType<Typ> ">"
  944    "(" Expr<Op> ")"
  945    (.
  946       OutOp := TZcOpReinterpretCast.Create(nil);
  947       OutOp.Children.Add(Op);
  948       (OutOp as TZcOpReinterpretCast).Typ := Typ;
  949    .)
  950  .
  951  
  952  /*------------------------------------------------------------------------*/
  953  InlineComponent<var OutOp : TZcOp>
  954  (. var Op : TZcOp;
  955       Ci : TZComponentInfo;
  956  .)
  957  =  (. OutOp := nil;
  958        IsInInvokeArg := True;
  959     .)
  960     "@" ident (.
  961         Ci := ComponentManager.GetInfoFromName(LexString);
  962         OutOp := TZcOpInvokeComponent.Create(nil);
  963         OutOp.Id := LexString;
  964      .)
  965      "("
  966          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
  967            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
  968            }
  969          ]
  970      ")" (. IsInInvokeArg := False; .)
  971  .
  972  
  973  /*------------------------------------------------------------------------*/
  974  Primary<var OutOp : TZcOp>
  975  (. var Op : TZcOp; S : string; V : double;
  976       Typ : TZcDataType;
  977  .)
  978  =            (. OutOp := nil; .)
  979    (
  980      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  981    | InlineComponent<OutOp>
  982    | Literal<Typ>  (.
  983          if Typ.Kind in [zctString,zctNull] then
  984            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  985          else
  986          begin
  987            try
  988              S := LexString;
  989              V := ZcStrToFloat(S);
  990              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  991            except on EConvertError do
  992              SynError(200);
  993            end;
  994          end;
  995       .)
  996    | "(" Expr<OutOp> ")"
  997  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
  998      | "float"  | "int"    | "long" | "object"  | "sbyte"
  999      | "short"  | "string" | "uint" | "ulong"   | "ushort"
 1000      ) "." ident */
 1001    | ReinterpretCast<OutOp>
 1002    )
 1003  
 1004    {
 1005    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1006    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1007  
 1008  /*  | "->" ident */
 1009  
 1010    | "." (. IsInIdent := True; .) ident (.
 1011  
 1012        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1013          ZError('Invalid use of "."');
 1014  
 1015        Op := MakeOp(zcSelect,LexString);
 1016        Op.Children.Add(OutOp);
 1017  
 1018        OutOp := CheckPrimary(Op);
 1019  
 1020        IsInIdent := False;
 1021  
 1022      .)
 1023  
 1024    | "(" (.
 1025             if (OutOp=nil) or (OutOp.Kind<>zcIdentifier) then
 1026               ZError('Unexpected "("');
 1027             OutOp.Kind:=zcFuncCall;
 1028           .)
 1029          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1030            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1031            }
 1032          ]
 1033          (.
 1034             if not VerifyFunctionCall(OutOp,S) then
 1035               ZError(S);
 1036          .)
 1037      ")"
 1038  
 1039    | "[" (.
 1040             if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
 1041               ZError('Unexpected "["');
 1042             Op := MakeArrayAccess(OutOp);
 1043             OutOp := Op;
 1044           .)
 1045  
 1046          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1047            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1048          "]"
 1049    }
 1050  .
 1051  /*------------------------------------------------------------------------*/
 1052  Literal<var Typ : TZcDataType>
 1053  = intCon (. Typ.Kind :=zctInt; .) |
 1054    realCon (. Typ.Kind := zctFloat; .) |
 1055    stringCon (. Typ.Kind := zctString; .)
 1056    | "null" (. Typ.Kind := zctNull; .)
 1057    /* | "true" | "false"  */
 1058  .
 1059  
 1060  END Zc.



