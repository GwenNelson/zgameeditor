
Listing
-------
0 errors and 45 warnings
*****  Warning: LL1 warning in ZcFuncBody:"vec3" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec2" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"mat4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"byte" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"reinterpret_cast" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"File" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      ZApp : TZApplication;
   15      destructor Destroy; override;
   16      procedure CheckHomograph(var sym: Integer); override;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      .)
   26  precreate = (.
   27      ZFunctions := TObjectList.Create(False);
   28      Self.OnError := OnParserError;
   29  
   30  .)
   31  
   32  semErrors = (.
   33      200 : Result := 'Not a floating point value';
   34      201 : Result := 'Name already defined in this scope';
   35      202 : Result := 'Return value expected';
   36      203 : Result := 'Function should not return a value';
   37      204 : Result := 'Only function definitions are allowed here';
   38      205 : Result := 'Syntax not supported';
   39  .)
   40  
   41  implementation = (.
   42  
   43  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   44  begin
   45    ZError(Msg + ' ' + Data);
   46  end;
   47  
   48  procedure TZc.CheckHomograph(var sym: Integer);
   49  begin
   50    //Only Homographs are name of component datatypes
   51    //If inside identifier "x.y.z" then let it refer to identifier instead
   52    if IsInIdent or IsInInvokeArg then
   53      sym := identSym;
   54  end;
   55  
   56  destructor TZc.Destroy;
   57  begin
   58    inherited;
   59    CleanUp;
   60  end;
   61  
   62  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   63  begin
   64    if Op=nil then
   65    begin
   66      if SwitchOp.HasDefault then
   67        ZError('Only one default statement is allowed.');
   68      SwitchOp.HasDefault := True;
   69    end else
   70      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   71    SwitchOp.CaseOps.Last.Children.Add( Op );
   72    Op := nil;
   73  end;
   74  
   75  procedure TZc.CleanUp;
   76  begin
   77    Zc_Ops.FunctionCleanUps.Clear;
   78    ZFunctions.Free;
   79  end;
   80  
   81  procedure TZc.ZError(const S : string);
   82  var
   83    E : EParseError;
   84    P : TSymbolRec;
   85  begin
   86    E := EParseError.Create(S);
   87    E.Message := S;
   88    Scanner.GetPosition(P);
   89    E.Line := P.Line;
   90    E.Col := P.Col;
   91    if (E.Line<>0) or (E.Col<>0) then
   92      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   93    raise E;
   94  end;
   95  
   96  .)
   97  
   98  END
   99  
  100  
  101  CHARACTERS
  102  
  103          tab                = CHR(9). /*  9 = tabulator */
  104          eol                = CHR(10). /* 10 = line feed */
  105          cr                 = CHR(13). /* 13 = carriage return */
  106          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  107  
  108          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  109          digit              = "0123456789".
  110          hexDigit           = digit + "ABCDEFabcdef".
  111          notDigit           = ANY - digit.
  112  
  113          char               = ANY - "'" - '\' - newLine.
  114          verbatimStringChar = ANY - '"'.
  115          regularStringChar  = ANY - '"' - '\' - newLine.
  116          notNewLine         = ANY - newLine .
  117  
  118  
  119  TOKENS
  120  
  121    /*--------------------------------------------------------------------------------*/
  122          intCon =
  123                  ( digit {digit}
  124                  | ("0x" | "0X") hexDigit {hexDigit}
  125                  )
  126                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  127                  .
  128    /*--------------------------------------------------------------------------------*/
  129          realCon =
  130                  "." digit {digit}
  131                  [("e" | "E") ["+" | "-"] digit {digit}]
  132                  ["F" | "f" | "D" | "d" | "M" | "m"]
  133          | digit {digit}
  134                  ( "." digit {digit}
  135                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  136                          ["F" | "f" | "D" | "d" | "M" | "m"]
  137                  | ("e" | "E") ["+" | "-"] digit {digit}
  138                          ["F" | "f" | "D" | "d" | "M" | "m"]
  139                  | "F" | "f" | "D" | "d" | "M" | "m"
  140                  ).
  141    /*--------------------------------------------------------------------------------*/
  142          stringCon =
  143                  '"'    { regularStringChar
  144            | "\'" | '\"' | "\\" | "\n"
  145            }
  146                  '"'.
  147  
  148          ident = letter { letter | digit }.
  149  
  150  
  151          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  152          and    = "&".
  153          assgn  = "=".
  154          colon  = ":".
  155          comma  = ",".
  156          dec    = "--".
  157          div    = "/".
  158          dot    = ".".
  159          eq     = "==".
  160          gt     = ">".
  161          gte    = ">=".
  162          inc    = "++".
  163          lbrace = "{".
  164          lbrack = "[".
  165          lpar   = "(".
  166          lshift = "<<".
  167          lt     = "<".
  168          lte    = "<=".
  169          minus  = "-".
  170          mod    = "%".
  171          neq    = "!=".
  172          not    = "!".
  173          or     = "|".
  174          plus   = "+".
  175          rbrace = "}".
  176          rbrack = "]".
  177          rpar   = ")".
  178          rshift = ">>".
  179          scolon = ";".
  180          tilde  = "~".
  181          times  = "*".
  182          xor    = "^".
  183  
  184  
  185  
  186  COMMENTS FROM "/*" TO "*/"
  187  COMMENTS FROM "//" TO eol
  188  
  189  IGNORE eol + cr + tab
  190  
  191  HOMOGRAPHS
  192    "Material"
  193    "Sound"
  194    "Shader" 
  195    "Bitmap" 
  196    "Mesh"
  197    "Camera" 
  198    "Font"
  199    "Sample"
  200    "File"
  201  
  202  PRODUCTIONS
  203  
  204  /*------------------------------------------------------------------------*
  205   *--------------------------- Declarations -------------------------------*
  206   *------------------------------------------------------------------------*/
  207  
  208  ZcFuncRest<Typ : TZcDataType; const Name : string>
  209  (.
  210  var
  211    Func : TZcOpFunctionUserDefined;
  212  .)
  213  =
  214       (.
  215          if SymTab.Contains(Name) then
  216            ZError('Name already defined: ' + Name);
  217  
  218          Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  219          Func.Id := Name;
  220          Func.ReturnType := Typ;
  221          SymTab.Add(Func.Id,Func);
  222          ZFunctions.Add(Func);
  223          Self.CurrentFunction := Func;
  224          SymTab.PushScope;
  225          try
  226       .)
  227      [ FormalParams ] ")" "{" ZcFuncBody "}"
  228          (.
  229            finally
  230              SymTab.PopScope;
  231            end;
  232          .)
  233  .
  234  
  235  
  236  Zc (. var
  237          Typ : TZcDataType;
  238          Func : TZcOpFunctionUserDefined;
  239          Name : string;
  240      .)
  241  =
  242    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  243    {
  244      ConstantDeclarationList
  245      |
  246      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  247         /* Need to separate between global variable and method declarations */
  248         (
  249           "(" ZcFuncRest<Typ,Name>
  250           | GlobalVarDecl<Typ,Name> ";"
  251         )
  252    }
  253    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  254    {
  255  
  256    (.
  257         Func := TZcOpFunctionUserDefined.Create(nil);
  258         Func.ReturnType := Self.ReturnType;
  259         Self.CurrentFunction := Func;
  260         try
  261           SymTab.PushScope;
  262           try
  263             ZFunctions.Add(Func);
  264    .)
  265    /* A zc-expression is treated like the body of a nameless function
  266       to allow local var declarations  */
  267  
  268    ZcFuncBody
  269    (.
  270           finally
  271             SymTab.PopScope;
  272           end;
  273         except on E: Exception do
  274           ZError(E.Message);
  275         end;
  276    .)
  277    }
  278  
  279  .
  280  
  281  /*------------------------------------------------------------------------*/
  282  
  283  ZcFuncBody (. var Op : TZcOp; .)
  284  =  {  (. Op:=nil; .)
  285        Statement<Op>
  286        (. if Op<>nil then
  287             CurrentFunction.Statements.Add(Op);
  288           Op := nil;
  289        .)
  290     }
  291  .
  292  
  293  /*------------------------------------------------------------------------*/
  294  FormalParams
  295  = ( Par ["," FormalParams] )
  296  .
  297  /*------------------------------------------------------------------------*/
  298  Par (.
  299  var
  300    Typ : TZcDataType;
  301    Arg : TZcOpArgumentVar;
  302    IsPtr : boolean;
  303  .)
  304  =  (. IsPtr := False; .)
  305    ["ref" (. IsPtr := True; .) ]
  306    Type<Typ> ident
  307       (.
  308          Typ.IsPointer := IsPtr;
  309          if SymTab.ScopeContains(LexString) then
  310            SynError(201)
  311          else
  312          begin
  313            Arg := TZcOpArgumentVar.Create;
  314            Arg.Id := LexString;
  315            Arg.Typ := Typ;
  316            CurrentFunction.AddArgument(Arg);
  317            SymTab.Add(Arg.Id,Arg);
  318          end;
  319       .)
  320  .
  321  /*------------------------------------------------------------------------*/
  322  
  323  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  324  = (. OutOp := nil; .)
  325    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  326  .
  327  
  328  /*------------------------------------------------------------------------*/
  329  
  330  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  331  = ident
  332       (. 
  333          if SymTab.ScopeContains(LexString) then
  334            ZError('Name already defined: ' + LexString);
  335  
  336          Loc := TZcOpLocalVar.Create(nil);
  337          Loc.Id := LexString;
  338          Loc.Typ := Typ;
  339       .)
  340       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  341       (.
  342          SymTab.Add(Loc.Id,Loc);
  343          CurrentFunction.AddLocal(Loc);
  344  
  345          if Assigned(Loc.InitExpression) then
  346          begin
  347            //Generate tree for initial assignment
  348            if OutOp=nil then
  349              OutOp := MakeOp(zcBlock);
  350            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  351          end;
  352  
  353       .)
  354  .
  355  
  356  /*------------------------------------------------------------------------*/
  357  
  358  GlobalVarRest<Typ : TZcDataType; const Name : string> (. var V : TDefineVariableBase; .)
  359  =
  360       (.
  361          if SymTab.ScopeContains(Name) then
  362            ZError('Name already defined: ' + Name);
  363  
  364          if Typ.Kind=zctArray then
  365          begin
  366            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  367            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  368            Self.ZApp.GlobalVars.AddComponent(V);
  369          end
  370          else
  371          begin
  372            V := TDefineVariable.Create(Self.ZApp.GlobalVars);
  373            V._Type := Typ.Kind;
  374          end;
  375  
  376          V.SetString('Name', AnsiString(Name));
  377          SymTab.Add(Name,V);
  378       .)
  379  .
  380  
  381  
  382  GlobalVar<Typ : TZcDataType>
  383  = ident GlobalVarRest<Typ,LexString>
  384  .
  385  
  386  GlobalVarDecl<Typ : TZcDataType; const Name : string>
  387  = GlobalVarRest<Typ,Name> {"," GlobalVar<Typ>}
  388  .
  389  
  390  /*------------------------------------------------------------------------*/
  391  
  392  Init<var OutOp : TZcOp>
  393  = Expr<OutOp>
  394  .
  395  
  396  /*------------------------------------------------------------------------*/
  397  Argument<var OutOp : TZcOp>
  398  = /* ["ref" | "out"] */
  399    (. OutOp := nil; .)
  400    Expr<OutOp>
  401    (. if OutOp=nil then ZError('Missing argument'); .)
  402  .
  403  
  404  /*------------------------------------------------------------------------*
  405   *-------------------------------- Types ---------------------------------*
  406   *------------------------------------------------------------------------*/
  407  
  408  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  409   * and for array creation expressions                                     */
  410  
  411  
  412  Type<var Typ : TZcDataType>
  413  (.
  414    var
  415      A : TDefineArray;
  416      SizeOp : TZcOp;
  417      I : integer;
  418  .)
  419  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  420    ( SimpleType<Typ> )
  421    {
  422      (
  423        "["       (.
  424                     A := TDefineArray.Create(nil);
  425                     GlobalNames.Add(A);
  426                     A._Type := Typ.Kind;
  427                     Typ.Kind := zctArray;
  428                     Typ.TheArray := A;
  429                  .)
  430  
  431           [ Expr<SizeOp> (.
  432              SizeOp := SizeOp.Optimize;
  433              if SizeOp.Kind<>zcConstLiteral then
  434                ZError('Array size must be a constant expression');
  435              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  436                           .)
  437           ]
  438  
  439           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  440             [ Expr<SizeOp> (.
  441                  SizeOp := SizeOp.Optimize;
  442                  if SizeOp.Kind<>zcConstLiteral then
  443                    ZError('Array size must be a constant expression');
  444                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  445                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  446             .) ]
  447           }
  448         "]"
  449      )
  450    }
  451  .
  452  
  453  /*------------------------------------------------------------------------*/
  454  
  455  SimpleType<var Typ : TZcDataType>
  456  (.
  457    var
  458      A : TDefineArray;
  459  .)
  460  /* = IntType | "float" | "double" | "decimal" | "bool" */
  461  = "float" (. Typ.Kind := zctFloat; .)
  462    | "int" (. Typ.Kind := zctInt; .)
  463    | "byte" (. Typ.Kind := zctByte; .)
  464    | "string" (. Typ.Kind := zctString; .)
  465    | "model" (. Typ.Kind := zctModel; .)
  466    | "xptr" (. Typ.Kind := zctXptr; .)
  467  
  468    | "mat4" (.
  469       A := Prototypes.Mat4Array;
  470       Typ.Kind := zctMat4;
  471       Typ.TheArray := A;
  472      .)
  473    | "vec2" (.
  474       A := Prototypes.Vec2Array;
  475       Typ.Kind := zctVec2;
  476       Typ.TheArray := A;
  477    .)
  478    | "vec3" (.
  479       A := Prototypes.Vec3Array;
  480       Typ.Kind := zctVec3;
  481       Typ.TheArray := A;
  482    .)
  483    | "vec4" (.
  484       A := Prototypes.Vec4Array;
  485       Typ.Kind := zctVec4;
  486       Typ.TheArray := A;
  487    .)
  488  
  489    /* Changes below also must be made in homographs-section */
  490    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  491    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  492    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  493    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  494    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  495    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  496    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  497    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  498    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  499  .
  500  
  501  /*------------------------------------------------------------------------*/
  502  
  503  /* IntType
  504  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  505  . */
  506  
  507  
  508  ConstantDeclarationList
  509  (.
  510  var
  511    Typ : TZcDataType;
  512  .)
  513  = "const" Type<Typ> ConstantDeclaration<Typ> {"," ConstantDeclaration<Typ> }
  514    ";"
  515  .
  516  
  517  ConstantDeclaration<var Typ : TZcDataType>
  518  (.
  519  var
  520    Cns : TDefineConstant;
  521    Op : TZcOp;
  522    Lit : TZcOpLiteral;
  523    CnsName : string;
  524  .)
  525  =
  526  ident (. CnsName := LexString; .) "=" Expr<Op>
  527    (.
  528     Op := Op.Optimize;
  529     if not (Op is TZcOpLiteral) then
  530       ZError('Constant expression expected: ' + Op.ToString);
  531  
  532     Lit := Op as TZcOpLiteral;
  533  
  534     if Lit.Typ.Kind<>Typ.Kind then
  535       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  536  
  537     Cns := TDefineConstant.Create(nil);
  538     Cns.SetString('Name',AnsiString(CnsName));
  539     GlobalNames.Add(Cns);
  540  
  541     case Typ.Kind of
  542       zctInt:
  543         begin
  544           Cns._Type := zctInt;
  545           Cns.IntValue := Round(Lit.Value);
  546         end;
  547       zctFloat:
  548         begin
  549           Cns._Type := zctFloat;
  550           Cns.Value := Lit.Value;
  551         end;
  552       zctString:
  553         begin
  554           Cns._Type := zctString;
  555           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  556         end;
  557       else
  558         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  559     end;
  560     SymTab.Add(CnsName,Cns);
  561    .)
  562  /* {"," ident "=" Expr<Op>} */
  563  .
  564  
  565  /*------------------------------------------------------------------------*
  566   *------------------------------ Statements ------------------------------*
  567   *------------------------------------------------------------------------*/
  568  
  569  Statement<var OutOp : TZcOp>
  570  = (. OutOp := nil; .)
  571  
  572  ConstantDeclarationList
  573  
  574  /*IF IsLocalVarDecl THEN
  575  BEGIN
  576    LocalVarDecl ";"
  577  END
  578  |  EmbeddedStatement<OutOp> */
  579  
  580  | LocalVarDecl<OutOp> ";"
  581  | EmbeddedStatement<OutOp>
  582    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  583     * ident {"." ident} { "[" ...                           */
  584  .
  585  
  586  /*------------------------------------------------------------------------*/
  587  EmbeddedStatement<var OutOp : TZcOp>
  588    (. var
  589         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  590         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  591         WhileCondOp,WhileBodyOp : TZcOp;
  592         SwitchOp : TZcOpSwitch;
  593         Loc : TZcOpLocalVar;
  594    .)
  595  = Block<OutOp>
  596  | ";"   (. OutOp := MakeOp(zcNop); .)
  597  | StatementExpr<OutOp> ";"
  598  | "if" (. ElseOp := nil; .)
  599    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  600          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  601   | "switch" "(" Expr<SwitchValueOp> ")"
  602        (.
  603           Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
  604           SymTab.Add(Loc.Id,Loc);
  605           CurrentFunction.AddLocal(Loc);
  606  
  607           OutOp := MakeOp(zcBlock);
  608           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  609  
  610           SwitchOp := TZcOpSwitch.Create(nil);
  611           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  612           OutOp.Children.Add(SwitchOp);
  613        .)
  614     "{" {
  615       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  616       SwitchSection<SwitchOp>
  617     } "}"
  618   | "while"
  619       (. try
  620           SymTab.PushScope;
  621           WhileCondOp := nil; WhileBodyOp := nil; .)
  622     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  623     (.
  624           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  625         finally
  626           SymTab.PopScope;
  627         end;
  628     .)
  629   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  630   | "for"
  631      (. try
  632           SymTab.PushScope;
  633           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  634     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  635     (.
  636           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  637         finally
  638           SymTab.PopScope;
  639         end;
  640     .)
  641  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  642   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  643   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  644   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  645      (.
  646          if (Op=nil) then
  647          begin
  648            if CurrentFunction.ReturnType.Kind<>zctVoid then
  649              SynError(202)
  650            else
  651              OutOp := MakeOp(zcReturn);
  652          end else
  653          begin
  654            if CurrentFunction.ReturnType.Kind=zctVoid then
  655              SynError(203)
  656            else
  657              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  658          end;
  659      .)
  660  .
  661  /*------------------------------------------------------------------------*/
  662  
  663  Block<var OutOp : TZcOp>
  664    (. var
  665         Op : TZcOp;
  666    .)
  667  = (. Op := nil;
  668       OutOp := MakeOp(zcBlock);
  669    .)
  670    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  671  
  672  /*------------------------------------------------------------------------*/
  673  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  674  = (. Op1 :=nil; Op2 := nil; .)
  675    Unary<Op1>
  676    ( AssignOp<Kind> Expr<Op2>
  677      (.
  678        if Op2<>nil then
  679          OutOp := MakeAssign(Kind,Op1,Op2);
  680      .)
  681    |                             (. OutOp := Op1; .)
  682    )
  683  .
  684  
  685  /*------------------------------------------------------------------------*/
  686  AssignOp<var Kind : TZcAssignType>
  687  = "="     (. Kind := atAssign; .)
  688    | "+="  (. Kind := atPlusAssign; .)
  689    | "-="  (. Kind := atMinusAssign; .)
  690    | "*="  (. Kind := atMulAssign; .)
  691    | "/="  (. Kind := atDivAssign; .)
  692  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  693  .
  694  
  695  /*------------------------------------------------------------------------*/
  696  
  697  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  698  = (. Op := nil; .)
  699    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  700    {
  701      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  702    }
  703    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  704    {
  705       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  706    }
  707  .
  708  
  709  /*------------------------------------------------------------------------*/
  710  
  711  SwitchLabel<var OutOp : TZcOp>
  712  = "case" Expr<OutOp> ":"
  713  | "default" ":"
  714  .
  715  
  716  /*------------------------------------------------------------------------*/
  717  
  718  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  719  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  720  (
  721  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  722  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  723    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  724  )
  725  .  
  726  
  727  /*------------------------------------------------------------------------*/
  728  
  729  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  730  = (. Op:=nil; 
  731       OutOp := MakeOp(zcBlock);
  732    .) 
  733  (
  734  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  735  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  736  )
  737  . 
  738  
  739  
  740  /*------------------------------------------------------------------------*
  741   *----------------------------- Expressions ------------------------------*
  742   *------------------------------------------------------------------------*/
  743  
  744  
  745  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  746  = (. Op1 :=nil; Op2 := nil; .)
  747    Unary<Op1>
  748    ( OrExpr<Op1,OutOp>
  749        ["?" Expr<Op1> ":" Expr<Op2>
  750           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  751                SynError(205)
  752              else
  753                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  754           .)
  755        ]
  756    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  757    )
  758  .
  759  /*------------------------------------------------------------------------*/
  760  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  761  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  762      {"||" Unary<Op> AndExpr<Op,R>
  763        (. OutOp := MakeOp(zcOr,[L,R]);
  764           L := OutOp; .)
  765      }
  766  .
  767  
  768  
  769  /*------------------------------------------------------------------------*/
  770  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  771  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  772      {"&&" Unary<Op> BitOrExpr<Op,R>
  773        (. OutOp := MakeOp(zcAnd,[L,R]);
  774           L := OutOp; .)
  775      }
  776  .
  777  /*------------------------------------------------------------------------*/
  778  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  779  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  780    {"|" Unary<Op> BitXorExpr<Op,R>
  781      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  782         L := OutOp; .)
  783    }
  784  .
  785  
  786  /*------------------------------------------------------------------------*/
  787  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  788  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  789    {"^" Unary<Op> BitAndExpr<Op,R>
  790      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  791         L := OutOp; .)
  792    }
  793  .
  794  
  795  /*------------------------------------------------------------------------*/
  796  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  797  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  798    {"&" Unary<Op> EqlExpr<Op,R>
  799      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  800         L := OutOp; .)
  801    }
  802  .
  803  
  804  /*------------------------------------------------------------------------*/
  805  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  806  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  807    {( "!="   (. Kind := zcCompNE; .)
  808     | "=="   (. Kind := zcCompEQ; .)
  809     )
  810     Unary<Op> RelExpr<Op,R>
  811           (. OutOp := MakeBinary(Kind, L,R);
  812              L := OutOp;
  813           .)
  814    }
  815  .
  816  /*------------------------------------------------------------------------*/
  817  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  818  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  819    { ( "<"       (. Kind := zcCompLT; .)
  820      | ">"       (. Kind := zcCompGT; .)
  821      | "<="      (. Kind := zcCompLE; .)
  822      | ">="      (. Kind := zcCompGE; .)
  823       )
  824      Unary<Op> ShiftExpr<Op,R>
  825           (. OutOp := MakeBinary(Kind, L,R );
  826              L := OutOp;
  827           .)
  828    }
  829  .
  830  /*------------------------------------------------------------------------*/
  831  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  832  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  833    { ("<<"  (. Kind := zcBinaryShiftL; .)
  834      | ">>" (. Kind := zcBinaryShiftR; .)
  835      )
  836      Unary<Op> AddExpr<Op,R>
  837      (. OutOp := MakeOp(Kind,[L,R]);
  838         L := OutOp; .)
  839    }
  840  .
  841  /*------------------------------------------------------------------------*/
  842  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  843  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  844      {( "+"    (. Kind := zcPlus; .)
  845       | "-"    (. Kind := zcMinus; .)
  846       ) Unary<Op> MulExpr<Op,R>
  847           (. 
  848              if (L=nil) or (R=nil) then
  849                ZError('Invalid syntax');
  850              OutOp := MakeBinary(Kind,L,R);
  851              L := OutOp;
  852           .)
  853      }
  854  .
  855  /*------------------------------------------------------------------------*/
  856  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  857  = (. OutOp := InOp; Kind := zcNop; .)
  858    { ("*"      (. Kind := zcMul; .)
  859      | "/"     (. Kind := zcDiv; .)
  860      | "%"     (. Kind := zcMod; .)
  861      ) Unary<Tmp>
  862           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  863              InOp := OutOp;
  864           .)
  865      }
  866  .
  867  /*------------------------------------------------------------------------*/
  868  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  869  =       (. LastOp := nil; Kind := zcNop; .)
  870    {
  871      (
  872        /* "+" | */
  873        "-"   (. Kind := zcNegate; .) |
  874        "++"  (. Kind := zcPreInc; .) |    
  875        "--"  (. Kind := zcPreDec; .) |
  876        "!"   (. Kind := zcNot; .)
  877        /* | "~" | "*" */
  878      )
  879      (.
  880         if Kind in [zcNegate,zcNot] then
  881         begin
  882           Tmp := MakeOp(Kind);
  883           if LastOp<>nil then
  884             LastOp.Children.Add(Tmp);
  885           LastOp := Tmp;
  886         end else if Assigned(LastOp) then
  887           ZError('-- and ++ cannot be combined with other unary ops');
  888      .)
  889    }
  890    Primary<Tmp>
  891      (.
  892         if Kind in [zcNop,zcNegate,zcNot] then
  893         begin
  894           if LastOp<>nil then
  895           begin
  896             LastOp.Children.Add(Tmp);
  897             OutOp := LastOp;
  898           end else
  899             OutOp := Tmp;
  900         end else
  901         begin
  902           OutOp := MakePrePostIncDec(Kind,Tmp);
  903         end;
  904      .)
  905  .
  906  
  907  
  908  
  909  /*------------------------------------------------------------------------*/
  910  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  911  (.
  912    var
  913      Op : TZcOp;
  914      Prop : TZProperty;
  915  .)
  916  = (. OutOp := nil; Op := nil; .)
  917    ident (.
  918      Prop := Ci.GetProperties.GetByName(LexString);
  919      if Prop=nil then
  920        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  921      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  922        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  923      OutOp := MakeOp(zcIdentifier);
  924      OutOp.Id := LexString;
  925    .)
  926    ":" Expr<Op>
  927    (. if Op=nil then
  928         ZError('Missing argument');
  929       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  930       OutOp.Children.Add(Op);
  931    .)
  932  .
  933  
  934  
  935  /*------------------------------------------------------------------------*/
  936  ReinterpretCast<var OutOp : TZcOp>
  937  (.
  938  var
  939    Op : TZcOp;
  940    Typ : TZcDataType;
  941  .)
  942  = "reinterpret_cast" "<" SimpleType<Typ> ">"
  943    "(" Expr<Op> ")"
  944    (.
  945       OutOp := TZcOpReinterpretCast.Create(nil);
  946       OutOp.Children.Add(Op);
  947       (OutOp as TZcOpReinterpretCast).Typ := Typ;
  948    .)
  949  .
  950  
  951  /*------------------------------------------------------------------------*/
  952  InlineComponent<var OutOp : TZcOp>
  953  (. var Op : TZcOp;
  954       Ci : TZComponentInfo;
  955  .)
  956  =  (. OutOp := nil;
  957        IsInInvokeArg := True;
  958     .)
  959     "@" ident (.
  960         Ci := ComponentManager.GetInfoFromName(LexString);
  961         OutOp := TZcOpInvokeComponent.Create(nil);
  962         OutOp.Id := LexString;
  963      .)
  964      "("
  965          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
  966            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
  967            }
  968          ]
  969      ")" (. IsInInvokeArg := False; .)
  970  .
  971  
  972  /*------------------------------------------------------------------------*/
  973  Primary<var OutOp : TZcOp>
  974  (. var Op : TZcOp; S : string; V : double;
  975       Typ : TZcDataType;
  976  .)
  977  =            (. OutOp := nil; .)
  978    (
  979      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  980    | InlineComponent<OutOp>
  981    | Literal<Typ>  (.
  982          if Typ.Kind in [zctString,zctNull] then
  983            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  984          else
  985          begin
  986            try
  987              S := LexString;
  988              V := ZcStrToFloat(S);
  989              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  990            except on EConvertError do
  991              SynError(200);
  992            end;
  993          end;
  994       .)
  995    | "(" Expr<OutOp> ")"
  996  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
  997      | "float"  | "int"    | "long" | "object"  | "sbyte"
  998      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  999      ) "." ident */
 1000    | ReinterpretCast<OutOp>
 1001    )
 1002  
 1003    {
 1004    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1005    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1006  
 1007  /*  | "->" ident */
 1008  
 1009    | "." (. IsInIdent := True; .) ident (.
 1010  
 1011        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1012          ZError('Invalid use of "."');
 1013  
 1014        Op := MakeOp(zcSelect,LexString);
 1015        Op.Children.Add(OutOp);
 1016  
 1017        OutOp := CheckPrimary(Op);
 1018  
 1019        IsInIdent := False;
 1020  
 1021      .)
 1022  
 1023    | "(" (. Assert(OutOp.Kind=zcIdentifier);
 1024             OutOp.Kind:=zcFuncCall;
 1025           .)
 1026          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1027            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1028            }
 1029          ]
 1030          (.
 1031             if not VerifyFunctionCall(OutOp,S) then
 1032               ZError(S);
 1033          .)
 1034      ")"
 1035  
 1036    | "[" (. Assert(OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall]);
 1037             Op := MakeArrayAccess(OutOp);
 1038             OutOp := Op;
 1039           .)
 1040  
 1041          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1042            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1043          "]"
 1044    }
 1045  .
 1046  /*------------------------------------------------------------------------*/
 1047  Literal<var Typ : TZcDataType>
 1048  = intCon (. Typ.Kind :=zctInt; .) |
 1049    realCon (. Typ.Kind := zctFloat; .) |
 1050    stringCon (. Typ.Kind := zctString; .)
 1051    | "null" (. Typ.Kind := zctNull; .)
 1052    /* | "true" | "false"  */
 1053  .
 1054  
 1055  END Zc.



