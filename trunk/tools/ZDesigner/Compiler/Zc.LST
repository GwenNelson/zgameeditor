
Listing
-------
0 errors and 38 warnings
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:mtrl is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      destructor Destroy; override;
   15      procedure CheckHomograph(var sym: Integer); override;
   16  .)
   17  private = (.
   18      IsInIdent,IsInInvokeArg : boolean;
   19      CurrentFunction : TZcOpFunctionUserDefined;
   20      procedure CleanUp;
   21      procedure ZError(const S : string);
   22      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   23      function MakeTempName : string;
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      .)
   26  precreate = (.
   27      ZFunctions := TObjectList.Create(False);
   28      Self.OnError := OnParserError;
   29  .)
   30  
   31  semErrors = (.
   32      200 : Result := 'Not a floating point value';
   33      201 : Result := 'Name already defined in this scope';
   34      202 : Result := 'Return value expected';
   35      203 : Result := 'Function should not return a value';
   36      204 : Result := 'Only function definitions are allowed here';
   37      205 : Result := 'Syntax not supported';
   38  .)
   39  
   40  implementation = (.
   41  
   42  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   43  begin
   44    ZError(Msg + ' ' + Data);
   45  end;
   46  
   47  procedure TZc.CheckHomograph(var sym: Integer);
   48  begin
   49    //Only Homographs are name of component datatypes
   50    //If inside identifier "x.y.z" then let it refer to identifier instead
   51    if IsInIdent or IsInInvokeArg then
   52      sym := identSym;
   53  end;
   54  
   55  destructor TZc.Destroy;
   56  begin
   57    inherited;
   58    CleanUp;
   59  end;
   60  
   61  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   62  begin
   63    if Op=nil then
   64    begin
   65      if SwitchOp.HasDefault then
   66        ZError('Only one default statement is allowed.');
   67      SwitchOp.HasDefault := True;
   68    end else
   69      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   70    SwitchOp.CaseOps.Last.Children.Add( Op );
   71    Op := nil;
   72  end;
   73  
   74  procedure TZc.CleanUp;
   75  begin
   76    Zc_Ops.FunctionCleanUps.Clear;
   77    ZFunctions.Free;
   78  end;
   79  
   80  function TZc.MakeTempName : string;
   81  begin
   82    Inc(TempCounter);
   83    Result := '#temp' + IntToStr(TempCounter);
   84  end;
   85  
   86  procedure TZc.ZError(const S : string);
   87  var
   88    E : EParseError;
   89    P : TSymbolRec;
   90  begin
   91    E := EParseError.Create(S);
   92    E.Message := S;
   93    Scanner.GetPosition(P);
   94    E.Line := P.Line;
   95    E.Col := P.Col;
   96    raise E;
   97  end;
   98  
   99  .)
  100  
  101  END
  102  
  103  
  104  CHARACTERS
  105  
  106          tab                = CHR(9). /*  9 = tabulator */
  107          eol                = CHR(10). /* 10 = line feed */
  108          cr                 = CHR(13). /* 13 = carriage return */
  109          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  110  
  111          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  112          digit              = "0123456789".
  113          hexDigit           = digit + "ABCDEFabcdef".
  114          notDigit           = ANY - digit.
  115  
  116          char               = ANY - "'" - '\' - newLine.
  117          verbatimStringChar = ANY - '"'.
  118          regularStringChar  = ANY - '"' - '\' - newLine.
  119          notNewLine         = ANY - newLine .
  120  
  121  
  122  TOKENS
  123  
  124    /*--------------------------------------------------------------------------------*/
  125          intCon =
  126                  ( digit {digit}
  127                  | ("0x" | "0X") hexDigit {hexDigit}
  128                  )
  129                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  130                  .
  131    /*--------------------------------------------------------------------------------*/
  132          realCon =
  133                  "." digit {digit}
  134                  [("e" | "E") ["+" | "-"] digit {digit}]
  135                  ["F" | "f" | "D" | "d" | "M" | "m"]
  136          | digit {digit}
  137                  ( "." digit {digit}
  138                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  139                          ["F" | "f" | "D" | "d" | "M" | "m"]
  140                  | ("e" | "E") ["+" | "-"] digit {digit}
  141                          ["F" | "f" | "D" | "d" | "M" | "m"]
  142                  | "F" | "f" | "D" | "d" | "M" | "m"
  143                  ).
  144    /*--------------------------------------------------------------------------------*/
  145          stringCon =
  146                  '"'    { regularStringChar
  147            | "\'" | '\"' | "\\" | "\n"
  148            }
  149                  '"'.
  150  
  151          ident = letter { letter | digit }.
  152  
  153  
  154          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  155          and    = "&".
  156          assgn  = "=".
  157          colon  = ":".
  158          comma  = ",".
  159          dec    = "--".
  160          div    = "/".
  161          dot    = ".".
  162          eq     = "==".
  163          gt     = ">".
  164          gte    = ">=".
  165          inc    = "++".
  166          lbrace = "{".
  167          lbrack = "[".
  168          lpar   = "(".
  169          lshift = "<<".
  170          lt     = "<".
  171          lte    = "<=".
  172          minus  = "-".
  173          mod    = "%".
  174          neq    = "!=".
  175          not    = "!".
  176          or     = "|".
  177          plus   = "+".
  178          rbrace = "}".
  179          rbrack = "]".
  180          rpar   = ")".
  181          rshift = ">>".
  182          scolon = ";".
  183          tilde  = "~".
  184          times  = "*".
  185          xor    = "^".
  186  
  187    mtrl = HOMOGRAPH "Material".
  188  
  189  COMMENTS FROM "/*" TO "*/"
  190  COMMENTS FROM "//" TO eol
  191  
  192  IGNORE eol + cr + tab
  193  
  194  HOMOGRAPHS
  195    "Sound"
  196    "Shader" 
  197    "Bitmap" 
  198    "Mesh"
  199    "Camera" 
  200    "Font"
  201    "Sample"
  202  
  203  
  204  PRODUCTIONS
  205  
  206  /*------------------------------------------------------------------------*
  207   *--------------------------- Declarations -------------------------------*
  208   *------------------------------------------------------------------------*/
  209  
  210  Zc (. var
  211          Func : TZcOpFunctionUserDefined;
  212          Typ : TZcDataType;
  213      .)
  214  =
  215    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  216    {
  217      ConstantDeclarationList
  218      |
  219      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (.
  220            if SymTab.Contains(LexString) then
  221              ZError('Name already defined: ' + LexString);
  222  
  223            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  224            Func.Id := LexString;
  225            Func.ReturnType := Typ;
  226            SymTab.Add(Func.Id,Func);
  227            ZFunctions.Add(Func);
  228            Self.CurrentFunction := Func;
  229            SymTab.PushScope;
  230            try
  231         .)
  232      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"
  233          (.
  234            finally
  235              SymTab.PopScope;
  236            end;
  237          .)
  238    }
  239    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  240    {
  241  
  242    (.
  243         Func := TZcOpFunctionUserDefined.Create(nil);
  244         Func.ReturnType := Self.ReturnType;
  245         Self.CurrentFunction := Func;
  246         try
  247           SymTab.PushScope;
  248           try
  249             ZFunctions.Add(Func);
  250    .)
  251    /* A zc-expression is treated like the body of a nameless function
  252       to allow local var declarations  */
  253  
  254    ZcFuncBody
  255    (.
  256           finally
  257             SymTab.PopScope;
  258           end;
  259         except on E: Exception do
  260           ZError(E.Message);
  261         end;
  262    .)
  263    }
  264  
  265  .
  266  
  267  /*------------------------------------------------------------------------*/
  268  
  269  ZcFuncBody (. var Op : TZcOp; .)
  270  =  {  (. Op:=nil; .)
  271        Statement<Op>
  272        (. if Op<>nil then
  273             CurrentFunction.Statements.Add(Op);
  274           Op := nil;
  275        .)
  276     }
  277  .
  278  
  279  /*------------------------------------------------------------------------*/
  280  FormalParams                    
  281  = ( Par ["," FormalParams] )
  282  .
  283  /*------------------------------------------------------------------------*/
  284  Par (.
  285  var
  286    Typ : TZcDataType;
  287    Arg : TZcOpArgumentVar;
  288    IsPtr : boolean;
  289  .)
  290  =  (. IsPtr := False; .)
  291    ["ref" (. IsPtr := True; .) ]
  292    Type<Typ> ident
  293       (.
  294          Typ.IsPointer := IsPtr;
  295          if SymTab.ScopeContains(LexString) then
  296            SynError(201)
  297          else
  298          begin
  299            Arg := TZcOpArgumentVar.Create;
  300            Arg.Id := LexString;
  301            Arg.Typ := Typ;
  302            CurrentFunction.AddArgument(Arg);
  303            SymTab.Add(Arg.Id,Arg);
  304          end;
  305       .)
  306  .
  307  /*------------------------------------------------------------------------*/
  308  
  309  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  310  = (. OutOp := nil; .)
  311    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  312  .
  313  
  314  /*------------------------------------------------------------------------*/
  315  
  316  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  317  = ident
  318       (. 
  319          if SymTab.ScopeContains(LexString) then
  320            ZError('Name already defined: ' + LexString);
  321  
  322          Loc := TZcOpLocalVar.Create(nil);
  323          Loc.Id := LexString;
  324          Loc.Typ := Typ;
  325       .)
  326       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  327       (.
  328          SymTab.Add(Loc.Id,Loc);
  329          CurrentFunction.AddLocal(Loc);
  330  
  331          if Assigned(Loc.InitExpression) then
  332          begin
  333            //Generate tree for initial assignment
  334            if OutOp=nil then
  335              OutOp := MakeOp(zcBlock);
  336            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  337          end;
  338          
  339       .)
  340  .
  341  
  342  /*------------------------------------------------------------------------*/
  343  
  344  Init<var OutOp : TZcOp>
  345  = Expr<OutOp>
  346  .
  347  
  348  /*------------------------------------------------------------------------*/
  349  Argument<var OutOp : TZcOp>
  350  = /* ["ref" | "out"] */
  351    (. OutOp := nil; .)
  352    Expr<OutOp>
  353    (. if OutOp=nil then ZError('Missing argument'); .)
  354  .
  355  
  356  /*------------------------------------------------------------------------*
  357   *-------------------------------- Types ---------------------------------*
  358   *------------------------------------------------------------------------*/
  359  
  360  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  361   * and for array creation expressions                                     */
  362  
  363  
  364  Type<var Typ : TZcDataType>
  365  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  366    ( SimpleType<Typ> )
  367  .
  368  
  369  /*------------------------------------------------------------------------*/
  370  
  371  SimpleType<var Typ : TZcDataType>
  372  /* = IntType | "float" | "double" | "decimal" | "bool" */
  373  = "float" (. Typ.Kind := zctFloat; .)
  374    | "int" (. Typ.Kind := zctInt; .)
  375    | "string" (. Typ.Kind := zctString; .)
  376    | "model" (. Typ.Kind := zctModel; .)
  377    | "xptr" (. Typ.Kind := zctXptr; .)
  378  
  379    /* Changes below also must be made in homographs-section */
  380    | mtrl (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  381    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  382    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  383    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  384    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  385    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  386    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  387    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  388  .
  389  
  390  /*------------------------------------------------------------------------*/
  391  
  392  /* IntType
  393  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  394  . */
  395  
  396  
  397  ConstantDeclarationList
  398  (.
  399  var
  400    Typ : TZcDataType;
  401  .)
  402  = "const" Type<Typ> ConstantDeclaration<Typ> {"," ConstantDeclaration<Typ> }
  403    ";"
  404  .
  405  
  406  ConstantDeclaration<var Typ : TZcDataType>
  407  (.
  408  var
  409    Cns : TDefineConstant;
  410    Op : TZcOp;
  411    Lit : TZcOpLiteral;
  412    CnsName : string;
  413  .)
  414  =
  415  ident (. CnsName := LexString; .) "=" Expr<Op>
  416    (.
  417     Op := Op.Optimize;
  418     if not (Op is TZcOpLiteral) then
  419       ZError('Constant expression expected: ' + Op.ToString);
  420  
  421     Lit := Op as TZcOpLiteral;
  422  
  423     if Lit.Typ.Kind<>Typ.Kind then
  424       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  425  
  426     Cns := TDefineConstant.Create(nil);
  427     Cns.SetString('Name',AnsiString(CnsName));
  428     GlobalNames.Add(Cns);
  429  
  430     case Typ.Kind of
  431       zctInt:
  432         begin
  433           Cns._Type := dvbInt;
  434           Cns.IntValue := Round(Lit.Value);
  435         end;
  436       zctFloat:
  437         begin
  438           Cns._Type := dvbFloat;
  439           Cns.Value := Lit.Value;
  440         end;
  441       zctString:
  442         begin
  443           Cns._Type := dvbString;
  444           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  445         end;
  446       else
  447         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  448     end;
  449     SymTab.Add(CnsName,Cns);
  450    .)
  451  /* {"," ident "=" Expr<Op>} */
  452  .
  453  
  454  /*------------------------------------------------------------------------*
  455   *------------------------------ Statements ------------------------------*
  456   *------------------------------------------------------------------------*/
  457  
  458  Statement<var OutOp : TZcOp>
  459  = (. OutOp := nil; .)
  460  
  461  ConstantDeclarationList
  462  
  463  /*IF IsLocalVarDecl THEN
  464  BEGIN
  465    LocalVarDecl ";"
  466  END
  467  |  EmbeddedStatement<OutOp> */
  468  
  469  | LocalVarDecl<OutOp> ";"
  470  | EmbeddedStatement<OutOp>
  471    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  472     * ident {"." ident} { "[" ...                           */
  473  .
  474  
  475  /*------------------------------------------------------------------------*/
  476  EmbeddedStatement<var OutOp : TZcOp>
  477    (. var
  478         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  479         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  480         WhileCondOp,WhileBodyOp : TZcOp;
  481         SwitchOp : TZcOpSwitch;
  482         Loc : TZcOpLocalVar;
  483    .)
  484  = Block<OutOp>
  485  | ";"   (. OutOp := MakeOp(zcNop); .)
  486  | StatementExpr<OutOp> ";"
  487  | "if" (. ElseOp := nil; .)
  488    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  489          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  490   | "switch" "(" Expr<SwitchValueOp> ")"
  491        (.
  492           Loc := TZcOpLocalVar.Create(nil);
  493           Loc.Id := MakeTempName;
  494           Loc.Typ := SwitchValueOp.GetDataType;
  495           SymTab.Add(Loc.Id,Loc);
  496           CurrentFunction.AddLocal(Loc);
  497  
  498           OutOp := MakeOp(zcBlock);
  499           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  500  
  501           SwitchOp := TZcOpSwitch.Create(nil);
  502           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  503           OutOp.Children.Add(SwitchOp);
  504        .)
  505     "{" {
  506       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  507       SwitchSection<SwitchOp>
  508     } "}"
  509   | "while"
  510       (. try
  511           SymTab.PushScope;
  512           WhileCondOp := nil; WhileBodyOp := nil; .)
  513     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  514     (.
  515           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  516         finally
  517           SymTab.PopScope;
  518         end;
  519     .)
  520   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  521   | "for"
  522      (. try
  523           SymTab.PushScope;
  524           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  525     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  526     (.
  527           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  528         finally
  529           SymTab.PopScope;
  530         end;
  531     .)
  532  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  533   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  534   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  535   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  536      (.
  537          if (Op=nil) then
  538          begin
  539            if CurrentFunction.ReturnType.Kind<>zctVoid then
  540              SynError(202)
  541            else
  542              OutOp := MakeOp(zcReturn);
  543          end else
  544          begin
  545            if CurrentFunction.ReturnType.Kind=zctVoid then
  546              SynError(203)
  547            else
  548              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  549          end;
  550      .)
  551  .
  552  /*------------------------------------------------------------------------*/
  553  
  554  Block<var OutOp : TZcOp>
  555    (. var
  556         Op : TZcOp;
  557    .)
  558  = (. Op := nil;
  559       OutOp := MakeOp(zcBlock);
  560    .)
  561    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  562  
  563  /*------------------------------------------------------------------------*/
  564  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  565  = (. Op1 :=nil; Op2 := nil; .)
  566    Unary<Op1>
  567    ( AssignOp<Kind> Expr<Op2>
  568      (.
  569        if Op2<>nil then
  570          OutOp := MakeAssign(Kind,Op1,Op2);
  571      .)
  572    |                             (. OutOp := Op1; .)
  573    )
  574  .
  575  
  576  /*------------------------------------------------------------------------*/
  577  AssignOp<var Kind : TZcAssignType>
  578  = "="     (. Kind := atAssign; .)
  579    | "+="  (. Kind := atPlusAssign; .)
  580    | "-="  (. Kind := atMinusAssign; .)
  581    | "*="  (. Kind := atMulAssign; .)
  582    | "/="  (. Kind := atDivAssign; .)
  583  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  584  .
  585  
  586  /*------------------------------------------------------------------------*/
  587  
  588  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  589  = (. Op := nil; .)
  590    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  591    {
  592      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  593    }
  594    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  595    {
  596       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  597    }
  598  .
  599  
  600  /*------------------------------------------------------------------------*/
  601  
  602  SwitchLabel<var OutOp : TZcOp>
  603  = "case" Expr<OutOp> ":"
  604  | "default" ":"
  605  .
  606  
  607  /*------------------------------------------------------------------------*/
  608  
  609  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  610  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  611  (
  612  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  613  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  614    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  615  )
  616  .  
  617  
  618  /*------------------------------------------------------------------------*/
  619  
  620  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  621  = (. Op:=nil; 
  622       OutOp := MakeOp(zcBlock);
  623    .) 
  624  (
  625  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  626  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  627  )
  628  . 
  629  
  630  
  631  /*------------------------------------------------------------------------*
  632   *----------------------------- Expressions ------------------------------*
  633   *------------------------------------------------------------------------*/
  634  
  635  
  636  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  637  = (. Op1 :=nil; Op2 := nil; .)
  638    Unary<Op1>
  639    ( OrExpr<Op1,OutOp>
  640        ["?" Expr<Op1> ":" Expr<Op2>
  641           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  642                SynError(205)
  643              else
  644                OutOp := MakeOp(zcConditional,[OutOp,Op1,Op2]);
  645           .)
  646        ]
  647    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  648    )
  649  .
  650  /*------------------------------------------------------------------------*/
  651  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  652  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  653      {"||" Unary<Op> AndExpr<Op,R>
  654        (. OutOp := MakeOp(zcOr,[L,R]);
  655           L := OutOp; .)
  656      }
  657  .
  658  
  659  
  660  /*------------------------------------------------------------------------*/
  661  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  662  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  663      {"&&" Unary<Op> BitOrExpr<Op,R>
  664        (. OutOp := MakeOp(zcAnd,[L,R]);
  665           L := OutOp; .)
  666      }
  667  .
  668  /*------------------------------------------------------------------------*/
  669  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  670  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  671    {"|" Unary<Op> BitXorExpr<Op,R>
  672      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  673         L := OutOp; .)
  674    }
  675  .
  676  
  677  /*------------------------------------------------------------------------*/
  678  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  679  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  680    {"^" Unary<Op> BitAndExpr<Op,R>
  681      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  682         L := OutOp; .)
  683    }
  684  .
  685  
  686  /*------------------------------------------------------------------------*/
  687  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  688  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  689    {"&" Unary<Op> EqlExpr<Op,R>
  690      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  691         L := OutOp; .)
  692    }
  693  .
  694  
  695  /*------------------------------------------------------------------------*/
  696  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  697  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  698    {( "!="   (. Kind := zcCompNE; .)
  699     | "=="   (. Kind := zcCompEQ; .)
  700     )
  701     Unary<Op> RelExpr<Op,R>
  702           (. OutOp := MakeBinary(Kind, L,R);
  703              L := OutOp;
  704           .)
  705    }
  706  .
  707  /*------------------------------------------------------------------------*/
  708  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  709  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  710    { ( "<"       (. Kind := zcCompLT; .)
  711      | ">"       (. Kind := zcCompGT; .)
  712      | "<="      (. Kind := zcCompLE; .)
  713      | ">="      (. Kind := zcCompGE; .)
  714       )
  715      Unary<Op> ShiftExpr<Op,R>
  716           (. OutOp := MakeBinary(Kind, L,R );
  717              L := OutOp;
  718           .)
  719    }
  720  .
  721  /*------------------------------------------------------------------------*/
  722  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  723  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  724    { ("<<"  (. Kind := zcBinaryShiftL; .)
  725      | ">>" (. Kind := zcBinaryShiftR; .)
  726      )
  727      Unary<Op> AddExpr<Op,R>
  728      (. OutOp := MakeOp(Kind,[L,R]);
  729         L := OutOp; .)
  730    }
  731  .
  732  /*------------------------------------------------------------------------*/
  733  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  734  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  735      {( "+"    (. Kind := zcPlus; .)
  736       | "-"    (. Kind := zcMinus; .)
  737       ) Unary<Op> MulExpr<Op,R>
  738           (. 
  739              if (L=nil) or (R=nil) then
  740                ZError('Invalid syntax');
  741              OutOp := MakeBinary(Kind,L,R);
  742              L := OutOp;
  743           .)
  744      }
  745  .
  746  /*------------------------------------------------------------------------*/
  747  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  748  = (. OutOp := InOp; Kind := zcNop; .)
  749    { ("*"      (. Kind := zcMul; .)
  750      | "/"     (. Kind := zcDiv; .)
  751    /*  | "%" */
  752      ) Unary<Tmp>
  753           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  754              InOp := OutOp;
  755           .)
  756      }
  757  .
  758  /*------------------------------------------------------------------------*/
  759  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  760  =       (. LastOp := nil; Kind := zcNop; .)
  761    {
  762      (
  763        /* "+" | */
  764        "-"   (. Kind := zcNegate; .) |
  765        "++"  (. Kind := zcPreInc; .) |    
  766        "--"  (. Kind := zcPreDec; .) |
  767        "!"   (. Kind := zcNot; .)
  768        /* | "~" | "*" */
  769      )
  770      (.
  771         if Kind in [zcNegate,zcNot] then
  772         begin
  773           Tmp := MakeOp(Kind);
  774           if LastOp<>nil then
  775             LastOp.Children.Add(Tmp);
  776           LastOp := Tmp;
  777         end else if Assigned(LastOp) then
  778           ZError('-- and ++ cannot be combined with other unary ops');
  779      .)
  780    }
  781    Primary<Tmp>
  782      (.
  783         if Kind in [zcNop,zcNegate,zcNot] then
  784         begin
  785           if LastOp<>nil then
  786           begin
  787             LastOp.Children.Add(Tmp);
  788             OutOp := LastOp;
  789           end else
  790             OutOp := Tmp;
  791         end else
  792         begin
  793           OutOp := MakePrePostIncDec(Kind,Tmp);
  794         end;
  795      .)
  796  .
  797  
  798  
  799  
  800  /*------------------------------------------------------------------------*/
  801  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  802  (.
  803    var
  804      Op : TZcOp;
  805      Prop : TZProperty;
  806  .)
  807  = (. OutOp := nil; Op := nil; .)
  808    ident (.
  809      Prop := Ci.GetProperties.GetByName(LexString);
  810      if Prop=nil then
  811        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  812      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  813        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  814      OutOp := MakeOp(zcIdentifier);
  815      OutOp.Id := LexString;
  816    .)
  817    ":" Expr<Op>
  818    (. if Op=nil then
  819         ZError('Missing argument');
  820       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  821       OutOp.Children.Add(Op);
  822    .)
  823  .
  824  
  825  
  826  
  827  /*------------------------------------------------------------------------*/
  828  Primary<var OutOp : TZcOp>
  829  (. var Op : TZcOp; S : string; V : single;
  830       Typ : TZcDataType;
  831       Ci : TZComponentInfo;
  832  .)
  833  =            (. OutOp := nil; .)
  834    (
  835      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  836    | "@" ident (.
  837         Ci := ComponentManager.GetInfoFromName(LexString);
  838         if not Ci.ZClass.InheritsFrom(TCommand) then
  839           ZError('Class must inherit TCommand: ' + LexString);
  840         OutOp := TZcOpInvokeComponent.Create(nil);
  841         OutOp.Id := LexString;
  842      .)
  843      "(" (. IsInInvokeArg := True; .)
  844          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
  845            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
  846            }
  847          ]
  848      ")" (. IsInInvokeArg := False; .)
  849    | Literal<Typ>  (.
  850          if Typ.Kind in [zctString,zctNull] then
  851            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  852          else
  853          begin
  854            try
  855              S := LexString;
  856              V := ZcStrToFloat(S);
  857              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  858            except on EConvertError do
  859              SynError(200);
  860            end;
  861          end;
  862       .)
  863    | "(" Expr<OutOp> ")"
  864  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
  865      | "float"  | "int"    | "long" | "object"  | "sbyte"
  866      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  867      ) "." ident */
  868    )
  869  
  870    {
  871    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
  872    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
  873  
  874  /*  | "->" ident */
  875  
  876    | "." (. IsInIdent := True; .) ident (.
  877  
  878        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
  879          ZError('Invalid use of "."');
  880  
  881        Op := MakeOp(zcSelect,LexString);
  882        Op.Children.Add(OutOp);
  883  
  884        OutOp := CheckPrimary(Op);
  885  
  886        IsInIdent := False;
  887  
  888      .)
  889  
  890    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  891             OutOp.Kind:=zcFuncCall;
  892           .)
  893          [Argument<Op> (. OutOp.Children.Add(Op); .)
  894            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  895            }
  896          ]
  897          (.
  898             if not VerifyFunctionCall(OutOp,S) then
  899               ZError(S);
  900          .)
  901      ")"
  902  
  903    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  904             OutOp.Kind:=zcArrayAccess;
  905           .)
  906      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
  907        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
  908      "]"
  909  
  910    }
  911  .
  912  /*------------------------------------------------------------------------*/
  913  Literal<var Typ : TZcDataType>
  914  = intCon (. Typ.Kind :=zctInt; .) |
  915    realCon (. Typ.Kind := zctFloat; .) |
  916    stringCon (. Typ.Kind := zctString; .)
  917    | "null" (. Typ.Kind := zctNull; .)
  918    /* | "true" | "false"  */
  919  .
  920  
  921  END Zc.



