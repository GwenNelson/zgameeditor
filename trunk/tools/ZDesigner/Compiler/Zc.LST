
Listing
-------
0 errors and 45 warnings
*****  Warning: LL1 warning in ZcFuncBody:"vec2" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"mat4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec3" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"byte" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"reinterpret_cast" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"File" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      destructor Destroy; override;
   15      procedure CheckHomograph(var sym: Integer); override;
   16  .)
   17  private = (.
   18      IsInIdent,IsInInvokeArg : boolean;
   19      CurrentFunction : TZcOpFunctionUserDefined;
   20      Mat4Array,Vec2Array,Vec3Array,Vec4Array : TDefineArray;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      function MakeTempName : string;
   25      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   26      function GetArray(Kind : TZcDataTypeKind) : TDefineArray;
   27      .)
   28  precreate = (.
   29      ZFunctions := TObjectList.Create(False);
   30      Self.OnError := OnParserError;
   31  
   32      Mat4Array := TDefineArray.Create(nil);
   33      Mat4Array.Dimensions := dadTwo;
   34      Mat4Array.SizeDim1 := 4;
   35      Mat4Array.SizeDim2 := 4;
   36      Mat4Array._Type := zctFloat;
   37  
   38      Vec2Array := TDefineArray.Create(nil);
   39      Vec2Array.Dimensions := dadOne;
   40      Vec2Array.SizeDim1 := 2;
   41      Vec2Array._Type := zctFloat;
   42  
   43      Vec3Array := TDefineArray.Create(nil);
   44      Vec3Array.Dimensions := dadOne;
   45      Vec3Array.SizeDim1 := 3;
   46      Vec3Array._Type := zctFloat;
   47  
   48      Vec4Array := TDefineArray.Create(nil);
   49      Vec4Array.Dimensions := dadOne;
   50      Vec4Array.SizeDim1 := 4;
   51      Vec4Array._Type := zctFloat;
   52  .)
   53  
   54  semErrors = (.
   55      200 : Result := 'Not a floating point value';
   56      201 : Result := 'Name already defined in this scope';
   57      202 : Result := 'Return value expected';
   58      203 : Result := 'Function should not return a value';
   59      204 : Result := 'Only function definitions are allowed here';
   60      205 : Result := 'Syntax not supported';
   61  .)
   62  
   63  implementation = (.
   64  
   65  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   66  begin
   67    ZError(Msg + ' ' + Data);
   68  end;
   69  
   70  procedure TZc.CheckHomograph(var sym: Integer);
   71  begin
   72    //Only Homographs are name of component datatypes
   73    //If inside identifier "x.y.z" then let it refer to identifier instead
   74    if IsInIdent or IsInInvokeArg then
   75      sym := identSym;
   76  end;
   77  
   78  destructor TZc.Destroy;
   79  begin
   80    inherited;
   81    CleanUp;
   82  end;
   83  
   84  function TZc.GetArray(Kind : TZcDataTypeKind) : TDefineArray;
   85  begin
   86    case Kind of
   87      zctMat4 : Result := Mat4Array;
   88      zctVec3 : Result := Vec3Array;
   89      zctVec2 : Result := Vec2Array;
   90      zctVec4 : Result := Vec4Array;
   91    else
   92      Assert(False);
   93    end;
   94  end;
   95  
   96  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   97  begin
   98    if Op=nil then
   99    begin
  100      if SwitchOp.HasDefault then
  101        ZError('Only one default statement is allowed.');
  102      SwitchOp.HasDefault := True;
  103    end else
  104      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
  105    SwitchOp.CaseOps.Last.Children.Add( Op );
  106    Op := nil;
  107  end;
  108  
  109  procedure TZc.CleanUp;
  110  begin
  111    Zc_Ops.FunctionCleanUps.Clear;
  112    ZFunctions.Free;
  113    Mat4Array.Free;
  114    Vec2Array.Free;
  115    Vec3Array.Free;
  116    Vec4Array.Free;
  117  end;
  118  
  119  function TZc.MakeTempName : string;
  120  begin
  121    Inc(TempCounter);
  122    Result := '#temp' + IntToStr(TempCounter);
  123  end;
  124  
  125  procedure TZc.ZError(const S : string);
  126  var
  127    E : EParseError;
  128    P : TSymbolRec;
  129  begin
  130    E := EParseError.Create(S);
  131    E.Message := S;
  132    Scanner.GetPosition(P);
  133    E.Line := P.Line;
  134    E.Col := P.Col;
  135    if (E.Line<>0) or (E.Col<>0) then
  136      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
  137    raise E;
  138  end;
  139  
  140  .)
  141  
  142  END
  143  
  144  
  145  CHARACTERS
  146  
  147          tab                = CHR(9). /*  9 = tabulator */
  148          eol                = CHR(10). /* 10 = line feed */
  149          cr                 = CHR(13). /* 13 = carriage return */
  150          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  151  
  152          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  153          digit              = "0123456789".
  154          hexDigit           = digit + "ABCDEFabcdef".
  155          notDigit           = ANY - digit.
  156  
  157          char               = ANY - "'" - '\' - newLine.
  158          verbatimStringChar = ANY - '"'.
  159          regularStringChar  = ANY - '"' - '\' - newLine.
  160          notNewLine         = ANY - newLine .
  161  
  162  
  163  TOKENS
  164  
  165    /*--------------------------------------------------------------------------------*/
  166          intCon =
  167                  ( digit {digit}
  168                  | ("0x" | "0X") hexDigit {hexDigit}
  169                  )
  170                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  171                  .
  172    /*--------------------------------------------------------------------------------*/
  173          realCon =
  174                  "." digit {digit}
  175                  [("e" | "E") ["+" | "-"] digit {digit}]
  176                  ["F" | "f" | "D" | "d" | "M" | "m"]
  177          | digit {digit}
  178                  ( "." digit {digit}
  179                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  180                          ["F" | "f" | "D" | "d" | "M" | "m"]
  181                  | ("e" | "E") ["+" | "-"] digit {digit}
  182                          ["F" | "f" | "D" | "d" | "M" | "m"]
  183                  | "F" | "f" | "D" | "d" | "M" | "m"
  184                  ).
  185    /*--------------------------------------------------------------------------------*/
  186          stringCon =
  187                  '"'    { regularStringChar
  188            | "\'" | '\"' | "\\" | "\n"
  189            }
  190                  '"'.
  191  
  192          ident = letter { letter | digit }.
  193  
  194  
  195          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  196          and    = "&".
  197          assgn  = "=".
  198          colon  = ":".
  199          comma  = ",".
  200          dec    = "--".
  201          div    = "/".
  202          dot    = ".".
  203          eq     = "==".
  204          gt     = ">".
  205          gte    = ">=".
  206          inc    = "++".
  207          lbrace = "{".
  208          lbrack = "[".
  209          lpar   = "(".
  210          lshift = "<<".
  211          lt     = "<".
  212          lte    = "<=".
  213          minus  = "-".
  214          mod    = "%".
  215          neq    = "!=".
  216          not    = "!".
  217          or     = "|".
  218          plus   = "+".
  219          rbrace = "}".
  220          rbrack = "]".
  221          rpar   = ")".
  222          rshift = ">>".
  223          scolon = ";".
  224          tilde  = "~".
  225          times  = "*".
  226          xor    = "^".
  227  
  228  
  229  
  230  COMMENTS FROM "/*" TO "*/"
  231  COMMENTS FROM "//" TO eol
  232  
  233  IGNORE eol + cr + tab
  234  
  235  HOMOGRAPHS
  236    "Material"
  237    "Sound"
  238    "Shader" 
  239    "Bitmap" 
  240    "Mesh"
  241    "Camera" 
  242    "Font"
  243    "Sample"
  244    "File"
  245  
  246  PRODUCTIONS
  247  
  248  /*------------------------------------------------------------------------*
  249   *--------------------------- Declarations -------------------------------*
  250   *------------------------------------------------------------------------*/
  251  
  252  Zc (. var
  253          Func : TZcOpFunctionUserDefined;
  254          Typ : TZcDataType;
  255      .)
  256  =
  257    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  258    {
  259      ConstantDeclarationList
  260      |
  261      ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (.
  262            if SymTab.Contains(LexString) then
  263              ZError('Name already defined: ' + LexString);
  264  
  265            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  266            Func.Id := LexString;
  267            Func.ReturnType := Typ;
  268            SymTab.Add(Func.Id,Func);
  269            ZFunctions.Add(Func);
  270            Self.CurrentFunction := Func;
  271            SymTab.PushScope;
  272            try
  273         .)
  274      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"
  275          (.
  276            finally
  277              SymTab.PopScope;
  278            end;
  279          .)
  280    }
  281    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  282    {
  283  
  284    (.
  285         Func := TZcOpFunctionUserDefined.Create(nil);
  286         Func.ReturnType := Self.ReturnType;
  287         Self.CurrentFunction := Func;
  288         try
  289           SymTab.PushScope;
  290           try
  291             ZFunctions.Add(Func);
  292    .)
  293    /* A zc-expression is treated like the body of a nameless function
  294       to allow local var declarations  */
  295  
  296    ZcFuncBody
  297    (.
  298           finally
  299             SymTab.PopScope;
  300           end;
  301         except on E: Exception do
  302           ZError(E.Message);
  303         end;
  304    .)
  305    }
  306  
  307  .
  308  
  309  /*------------------------------------------------------------------------*/
  310  
  311  ZcFuncBody (. var Op : TZcOp; .)
  312  =  {  (. Op:=nil; .)
  313        Statement<Op>
  314        (. if Op<>nil then
  315             CurrentFunction.Statements.Add(Op);
  316           Op := nil;
  317        .)
  318     }
  319  .
  320  
  321  /*------------------------------------------------------------------------*/
  322  FormalParams                    
  323  = ( Par ["," FormalParams] )
  324  .
  325  /*------------------------------------------------------------------------*/
  326  Par (.
  327  var
  328    Typ : TZcDataType;
  329    Arg : TZcOpArgumentVar;
  330    IsPtr : boolean;
  331  .)
  332  =  (. IsPtr := False; .)
  333    ["ref" (. IsPtr := True; .) ]
  334    Type<Typ> ident
  335       (.
  336          Typ.IsPointer := IsPtr;
  337          if SymTab.ScopeContains(LexString) then
  338            SynError(201)
  339          else
  340          begin
  341            Arg := TZcOpArgumentVar.Create;
  342            Arg.Id := LexString;
  343            Arg.Typ := Typ;
  344            CurrentFunction.AddArgument(Arg);
  345            SymTab.Add(Arg.Id,Arg);
  346          end;
  347       .)
  348  .
  349  /*------------------------------------------------------------------------*/
  350  
  351  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  352  = (. OutOp := nil; .)
  353    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  354  .
  355  
  356  /*------------------------------------------------------------------------*/
  357  
  358  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  359  = ident
  360       (. 
  361          if SymTab.ScopeContains(LexString) then
  362            ZError('Name already defined: ' + LexString);
  363  
  364          Loc := TZcOpLocalVar.Create(nil);
  365          Loc.Id := LexString;
  366          Loc.Typ := Typ;
  367       .)
  368       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  369       (.
  370          SymTab.Add(Loc.Id,Loc);
  371          CurrentFunction.AddLocal(Loc);
  372  
  373          if Assigned(Loc.InitExpression) then
  374          begin
  375            //Generate tree for initial assignment
  376            if OutOp=nil then
  377              OutOp := MakeOp(zcBlock);
  378            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  379          end;
  380          
  381       .)
  382  .
  383  
  384  /*------------------------------------------------------------------------*/
  385  
  386  Init<var OutOp : TZcOp>
  387  = Expr<OutOp>
  388  .
  389  
  390  /*------------------------------------------------------------------------*/
  391  Argument<var OutOp : TZcOp>
  392  = /* ["ref" | "out"] */
  393    (. OutOp := nil; .)
  394    Expr<OutOp>
  395    (. if OutOp=nil then ZError('Missing argument'); .)
  396  .
  397  
  398  /*------------------------------------------------------------------------*
  399   *-------------------------------- Types ---------------------------------*
  400   *------------------------------------------------------------------------*/
  401  
  402  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  403   * and for array creation expressions                                     */
  404  
  405  
  406  Type<var Typ : TZcDataType>
  407  (.
  408    var
  409      A : TDefineArray;
  410  .)
  411  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  412    ( SimpleType<Typ> )
  413    {
  414      (
  415        "["       (.
  416                     A := TDefineArray.Create(nil);
  417                     GlobalNames.Add(A);
  418                     A._Type := Typ.Kind;
  419                     Typ.Kind := zctArray;
  420                     Typ.TheArray := A;
  421                  .)
  422           [ intCon (. A.SizeDim1 := StrToInt(LexString); .) ]
  423           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  424             [ intCon (. if (A.Dimensions=dadTwo) then A.SizeDim2 := StrToInt(LexString) else A.SizeDim3 := StrToInt(LexString);
  425             .) ]
  426           }
  427         "]"
  428      )
  429    }
  430  .
  431  
  432  /*------------------------------------------------------------------------*/
  433  
  434  SimpleType<var Typ : TZcDataType>
  435  (.
  436    var
  437      A : TDefineArray;
  438  .)
  439  /* = IntType | "float" | "double" | "decimal" | "bool" */
  440  = "float" (. Typ.Kind := zctFloat; .)
  441    | "int" (. Typ.Kind := zctInt; .)
  442    | "byte" (. Typ.Kind := zctByte; .)
  443    | "string" (. Typ.Kind := zctString; .)
  444    | "model" (. Typ.Kind := zctModel; .)
  445    | "xptr" (. Typ.Kind := zctXptr; .)
  446  
  447    | "mat4" (.
  448       A := Mat4Array;
  449       Typ.Kind := zctMat4;
  450       Typ.TheArray := A;
  451      .)
  452    | "vec2" (.
  453       A := Vec2Array;
  454       Typ.Kind := zctVec2;
  455       Typ.TheArray := A;
  456    .)
  457    | "vec3" (.
  458       A := Vec3Array;
  459       Typ.Kind := zctVec3;
  460       Typ.TheArray := A;
  461    .)
  462    | "vec4" (.
  463       A := Vec4Array;
  464       Typ.Kind := zctVec4;
  465       Typ.TheArray := A;
  466    .)
  467  
  468    /* Changes below also must be made in homographs-section */
  469    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  470    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  471    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  472    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  473    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  474    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  475    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  476    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  477    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FileClassId; .)
  478  .
  479  
  480  /*------------------------------------------------------------------------*/
  481  
  482  /* IntType
  483  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  484  . */
  485  
  486  
  487  ConstantDeclarationList
  488  (.
  489  var
  490    Typ : TZcDataType;
  491  .)
  492  = "const" Type<Typ> ConstantDeclaration<Typ> {"," ConstantDeclaration<Typ> }
  493    ";"
  494  .
  495  
  496  ConstantDeclaration<var Typ : TZcDataType>
  497  (.
  498  var
  499    Cns : TDefineConstant;
  500    Op : TZcOp;
  501    Lit : TZcOpLiteral;
  502    CnsName : string;
  503  .)
  504  =
  505  ident (. CnsName := LexString; .) "=" Expr<Op>
  506    (.
  507     Op := Op.Optimize;
  508     if not (Op is TZcOpLiteral) then
  509       ZError('Constant expression expected: ' + Op.ToString);
  510  
  511     Lit := Op as TZcOpLiteral;
  512  
  513     if Lit.Typ.Kind<>Typ.Kind then
  514       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  515  
  516     Cns := TDefineConstant.Create(nil);
  517     Cns.SetString('Name',AnsiString(CnsName));
  518     GlobalNames.Add(Cns);
  519  
  520     case Typ.Kind of
  521       zctInt:
  522         begin
  523           Cns._Type := zctInt;
  524           Cns.IntValue := Round(Lit.Value);
  525         end;
  526       zctFloat:
  527         begin
  528           Cns._Type := zctFloat;
  529           Cns.Value := Lit.Value;
  530         end;
  531       zctString:
  532         begin
  533           Cns._Type := zctString;
  534           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  535         end;
  536       else
  537         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  538     end;
  539     SymTab.Add(CnsName,Cns);
  540    .)
  541  /* {"," ident "=" Expr<Op>} */
  542  .
  543  
  544  /*------------------------------------------------------------------------*
  545   *------------------------------ Statements ------------------------------*
  546   *------------------------------------------------------------------------*/
  547  
  548  Statement<var OutOp : TZcOp>
  549  = (. OutOp := nil; .)
  550  
  551  ConstantDeclarationList
  552  
  553  /*IF IsLocalVarDecl THEN
  554  BEGIN
  555    LocalVarDecl ";"
  556  END
  557  |  EmbeddedStatement<OutOp> */
  558  
  559  | LocalVarDecl<OutOp> ";"
  560  | EmbeddedStatement<OutOp>
  561    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  562     * ident {"." ident} { "[" ...                           */
  563  .
  564  
  565  /*------------------------------------------------------------------------*/
  566  EmbeddedStatement<var OutOp : TZcOp>
  567    (. var
  568         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  569         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  570         WhileCondOp,WhileBodyOp : TZcOp;
  571         SwitchOp : TZcOpSwitch;
  572         Loc : TZcOpLocalVar;
  573    .)
  574  = Block<OutOp>
  575  | ";"   (. OutOp := MakeOp(zcNop); .)
  576  | StatementExpr<OutOp> ";"
  577  | "if" (. ElseOp := nil; .)
  578    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  579          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  580   | "switch" "(" Expr<SwitchValueOp> ")"
  581        (.
  582           Loc := TZcOpLocalVar.Create(nil);
  583           Loc.Id := MakeTempName;
  584           Loc.Typ := SwitchValueOp.GetDataType;
  585           SymTab.Add(Loc.Id,Loc);
  586           CurrentFunction.AddLocal(Loc);
  587  
  588           OutOp := MakeOp(zcBlock);
  589           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  590  
  591           SwitchOp := TZcOpSwitch.Create(nil);
  592           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  593           OutOp.Children.Add(SwitchOp);
  594        .)
  595     "{" {
  596       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  597       SwitchSection<SwitchOp>
  598     } "}"
  599   | "while"
  600       (. try
  601           SymTab.PushScope;
  602           WhileCondOp := nil; WhileBodyOp := nil; .)
  603     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  604     (.
  605           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  606         finally
  607           SymTab.PopScope;
  608         end;
  609     .)
  610   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  611   | "for"
  612      (. try
  613           SymTab.PushScope;
  614           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  615     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  616     (.
  617           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  618         finally
  619           SymTab.PopScope;
  620         end;
  621     .)
  622  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  623   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  624   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  625   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  626      (.
  627          if (Op=nil) then
  628          begin
  629            if CurrentFunction.ReturnType.Kind<>zctVoid then
  630              SynError(202)
  631            else
  632              OutOp := MakeOp(zcReturn);
  633          end else
  634          begin
  635            if CurrentFunction.ReturnType.Kind=zctVoid then
  636              SynError(203)
  637            else
  638              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  639          end;
  640      .)
  641  .
  642  /*------------------------------------------------------------------------*/
  643  
  644  Block<var OutOp : TZcOp>
  645    (. var
  646         Op : TZcOp;
  647    .)
  648  = (. Op := nil;
  649       OutOp := MakeOp(zcBlock);
  650    .)
  651    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  652  
  653  /*------------------------------------------------------------------------*/
  654  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  655  = (. Op1 :=nil; Op2 := nil; .)
  656    Unary<Op1>
  657    ( AssignOp<Kind> Expr<Op2>
  658      (.
  659        if Op2<>nil then
  660          OutOp := MakeAssign(Kind,Op1,Op2);
  661      .)
  662    |                             (. OutOp := Op1; .)
  663    )
  664  .
  665  
  666  /*------------------------------------------------------------------------*/
  667  AssignOp<var Kind : TZcAssignType>
  668  = "="     (. Kind := atAssign; .)
  669    | "+="  (. Kind := atPlusAssign; .)
  670    | "-="  (. Kind := atMinusAssign; .)
  671    | "*="  (. Kind := atMulAssign; .)
  672    | "/="  (. Kind := atDivAssign; .)
  673  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  674  .
  675  
  676  /*------------------------------------------------------------------------*/
  677  
  678  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  679  = (. Op := nil; .)
  680    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  681    {
  682      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  683    }
  684    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  685    {
  686       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  687    }
  688  .
  689  
  690  /*------------------------------------------------------------------------*/
  691  
  692  SwitchLabel<var OutOp : TZcOp>
  693  = "case" Expr<OutOp> ":"
  694  | "default" ":"
  695  .
  696  
  697  /*------------------------------------------------------------------------*/
  698  
  699  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  700  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  701  (
  702  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  703  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  704    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  705  )
  706  .  
  707  
  708  /*------------------------------------------------------------------------*/
  709  
  710  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  711  = (. Op:=nil; 
  712       OutOp := MakeOp(zcBlock);
  713    .) 
  714  (
  715  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  716  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  717  )
  718  . 
  719  
  720  
  721  /*------------------------------------------------------------------------*
  722   *----------------------------- Expressions ------------------------------*
  723   *------------------------------------------------------------------------*/
  724  
  725  
  726  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  727  = (. Op1 :=nil; Op2 := nil; .)
  728    Unary<Op1>
  729    ( OrExpr<Op1,OutOp>
  730        ["?" Expr<Op1> ":" Expr<Op2>
  731           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  732                SynError(205)
  733              else
  734                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  735           .)
  736        ]
  737    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  738    )
  739  .
  740  /*------------------------------------------------------------------------*/
  741  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  742  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  743      {"||" Unary<Op> AndExpr<Op,R>
  744        (. OutOp := MakeOp(zcOr,[L,R]);
  745           L := OutOp; .)
  746      }
  747  .
  748  
  749  
  750  /*------------------------------------------------------------------------*/
  751  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  752  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  753      {"&&" Unary<Op> BitOrExpr<Op,R>
  754        (. OutOp := MakeOp(zcAnd,[L,R]);
  755           L := OutOp; .)
  756      }
  757  .
  758  /*------------------------------------------------------------------------*/
  759  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  760  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  761    {"|" Unary<Op> BitXorExpr<Op,R>
  762      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  763         L := OutOp; .)
  764    }
  765  .
  766  
  767  /*------------------------------------------------------------------------*/
  768  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  769  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  770    {"^" Unary<Op> BitAndExpr<Op,R>
  771      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  772         L := OutOp; .)
  773    }
  774  .
  775  
  776  /*------------------------------------------------------------------------*/
  777  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  778  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  779    {"&" Unary<Op> EqlExpr<Op,R>
  780      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  781         L := OutOp; .)
  782    }
  783  .
  784  
  785  /*------------------------------------------------------------------------*/
  786  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  787  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  788    {( "!="   (. Kind := zcCompNE; .)
  789     | "=="   (. Kind := zcCompEQ; .)
  790     )
  791     Unary<Op> RelExpr<Op,R>
  792           (. OutOp := MakeBinary(Kind, L,R);
  793              L := OutOp;
  794           .)
  795    }
  796  .
  797  /*------------------------------------------------------------------------*/
  798  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  799  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  800    { ( "<"       (. Kind := zcCompLT; .)
  801      | ">"       (. Kind := zcCompGT; .)
  802      | "<="      (. Kind := zcCompLE; .)
  803      | ">="      (. Kind := zcCompGE; .)
  804       )
  805      Unary<Op> ShiftExpr<Op,R>
  806           (. OutOp := MakeBinary(Kind, L,R );
  807              L := OutOp;
  808           .)
  809    }
  810  .
  811  /*------------------------------------------------------------------------*/
  812  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  813  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  814    { ("<<"  (. Kind := zcBinaryShiftL; .)
  815      | ">>" (. Kind := zcBinaryShiftR; .)
  816      )
  817      Unary<Op> AddExpr<Op,R>
  818      (. OutOp := MakeOp(Kind,[L,R]);
  819         L := OutOp; .)
  820    }
  821  .
  822  /*------------------------------------------------------------------------*/
  823  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  824  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  825      {( "+"    (. Kind := zcPlus; .)
  826       | "-"    (. Kind := zcMinus; .)
  827       ) Unary<Op> MulExpr<Op,R>
  828           (. 
  829              if (L=nil) or (R=nil) then
  830                ZError('Invalid syntax');
  831              OutOp := MakeBinary(Kind,L,R);
  832              L := OutOp;
  833           .)
  834      }
  835  .
  836  /*------------------------------------------------------------------------*/
  837  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  838  = (. OutOp := InOp; Kind := zcNop; .)
  839    { ("*"      (. Kind := zcMul; .)
  840      | "/"     (. Kind := zcDiv; .)
  841      | "%"     (. Kind := zcMod; .)
  842      ) Unary<Tmp>
  843           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  844              InOp := OutOp;
  845           .)
  846      }
  847  .
  848  /*------------------------------------------------------------------------*/
  849  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  850  =       (. LastOp := nil; Kind := zcNop; .)
  851    {
  852      (
  853        /* "+" | */
  854        "-"   (. Kind := zcNegate; .) |
  855        "++"  (. Kind := zcPreInc; .) |    
  856        "--"  (. Kind := zcPreDec; .) |
  857        "!"   (. Kind := zcNot; .)
  858        /* | "~" | "*" */
  859      )
  860      (.
  861         if Kind in [zcNegate,zcNot] then
  862         begin
  863           Tmp := MakeOp(Kind);
  864           if LastOp<>nil then
  865             LastOp.Children.Add(Tmp);
  866           LastOp := Tmp;
  867         end else if Assigned(LastOp) then
  868           ZError('-- and ++ cannot be combined with other unary ops');
  869      .)
  870    }
  871    Primary<Tmp>
  872      (.
  873         if Kind in [zcNop,zcNegate,zcNot] then
  874         begin
  875           if LastOp<>nil then
  876           begin
  877             LastOp.Children.Add(Tmp);
  878             OutOp := LastOp;
  879           end else
  880             OutOp := Tmp;
  881         end else
  882         begin
  883           OutOp := MakePrePostIncDec(Kind,Tmp);
  884         end;
  885      .)
  886  .
  887  
  888  
  889  
  890  /*------------------------------------------------------------------------*/
  891  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  892  (.
  893    var
  894      Op : TZcOp;
  895      Prop : TZProperty;
  896  .)
  897  = (. OutOp := nil; Op := nil; .)
  898    ident (.
  899      Prop := Ci.GetProperties.GetByName(LexString);
  900      if Prop=nil then
  901        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  902      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  903        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  904      OutOp := MakeOp(zcIdentifier);
  905      OutOp.Id := LexString;
  906    .)
  907    ":" Expr<Op>
  908    (. if Op=nil then
  909         ZError('Missing argument');
  910       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  911       OutOp.Children.Add(Op);
  912    .)
  913  .
  914  
  915  
  916  /*------------------------------------------------------------------------*/
  917  ReinterpretCast<var OutOp : TZcOp>
  918  (.
  919  var
  920    Op : TZcOp;
  921    Typ : TZcDataType;
  922  .)
  923  = "reinterpret_cast" "<" SimpleType<Typ> ">"
  924    "(" Expr<Op> ")"
  925    (.
  926       OutOp := TZcOpReinterpretCast.Create(nil);
  927       OutOp.Children.Add(Op);
  928       (OutOp as TZcOpReinterpretCast).Typ := Typ;
  929    .)
  930  .
  931  
  932  /*------------------------------------------------------------------------*/
  933  InlineComponent<var OutOp : TZcOp>
  934  (. var Op : TZcOp;
  935       Ci : TZComponentInfo;
  936  .)
  937  =  (. OutOp := nil;
  938        IsInInvokeArg := True;
  939     .)
  940     "@" ident (.
  941         Ci := ComponentManager.GetInfoFromName(LexString);
  942         OutOp := TZcOpInvokeComponent.Create(nil);
  943         OutOp.Id := LexString;
  944      .)
  945      "("
  946          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
  947            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
  948            }
  949          ]
  950      ")" (. IsInInvokeArg := False; .)
  951  .
  952  
  953  /*------------------------------------------------------------------------*/
  954  Primary<var OutOp : TZcOp>
  955  (. var Op : TZcOp; S : string; V : double;
  956       Typ : TZcDataType;
  957  .)
  958  =            (. OutOp := nil; .)
  959    (
  960      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
  961    | InlineComponent<OutOp>
  962    | Literal<Typ>  (.
  963          if Typ.Kind in [zctString,zctNull] then
  964            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
  965          else
  966          begin
  967            try
  968              S := LexString;
  969              V := ZcStrToFloat(S);
  970              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
  971            except on EConvertError do
  972              SynError(200);
  973            end;
  974          end;
  975       .)
  976    | "(" Expr<OutOp> ")"
  977  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
  978      | "float"  | "int"    | "long" | "object"  | "sbyte"
  979      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  980      ) "." ident */
  981    | ReinterpretCast<OutOp>
  982    )
  983  
  984    {
  985    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
  986    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
  987  
  988  /*  | "->" ident */
  989  
  990    | "." (. IsInIdent := True; .) ident (.
  991  
  992        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
  993          ZError('Invalid use of "."');
  994  
  995        Op := MakeOp(zcSelect,LexString);
  996        Op.Children.Add(OutOp);
  997  
  998        OutOp := CheckPrimary(Op);
  999  
 1000        IsInIdent := False;
 1001  
 1002      .)
 1003  
 1004    | "(" (. Assert(OutOp.Kind=zcIdentifier);
 1005             OutOp.Kind:=zcFuncCall;
 1006           .)
 1007          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1008            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1009            }
 1010          ]
 1011          (.
 1012             if not VerifyFunctionCall(OutOp,S) then
 1013               ZError(S);
 1014          .)
 1015      ")"
 1016  
 1017    | "[" (. Assert(OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall]);
 1018             Op := TZcOpArrayAccess.Create(OutOp.Id, OutOp);
 1019  
 1020             if OutOp.Kind=zcArrayAccess then
 1021             begin
 1022               //Array of arrays
 1023               Op.Ref := GetArray(TDefineArray(TZcOpArrayAccess(OutOp).Arrayop.GetDataType.TheArray)._Type);
 1024               TZcOpArrayAccess(Op).IsRawMem := True;
 1025             end;
 1026  
 1027             if OutOp.Kind=zcFuncCall then
 1028             begin
 1029               //Function returning array
 1030               Op.Ref := GetArray((OutOp.Ref as TZcOpFunctionBase).ReturnType.Kind);
 1031             end;
 1032  
 1033             OutOp := Op;
 1034           .)
 1035  
 1036          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1037            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1038          "]"
 1039    }
 1040  .
 1041  /*------------------------------------------------------------------------*/
 1042  Literal<var Typ : TZcDataType>
 1043  = intCon (. Typ.Kind :=zctInt; .) |
 1044    realCon (. Typ.Kind := zctFloat; .) |
 1045    stringCon (. Typ.Kind := zctString; .)
 1046    | "null" (. Typ.Kind := zctNull; .)
 1047    /* | "true" | "false"  */
 1048  .
 1049  
 1050  END Zc.



