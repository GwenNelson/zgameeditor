COMPILER Zc

DELPHI
(*  USES INTERFACE SysUtils *)
  USES (INTERFACE) contnrs

  TYPE

  TZcAssignType = (atAssign,atMulAssign,atDivAssign,atPlusAssign,atMinusAssign);
  TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus,zcConst,zcIdentifier,zcAssign,zcIf,
          zcCompLT,zcCompGT,zcCompLE,zcCompGE,zcCompNE,zcCompEQ,
          zcBlock,zcNegate,zcOr,zcAnd,zcFuncCall,zcReturn);

  TZcOp = class
  public
    Kind : TZcOpKind;
    Value : single;
    Id : string;
    Children : TObjectList;
    constructor Create;
    destructor Destroy; override;
    function ToString : string;
    function Child(I : integer) : TZcOp;
    procedure Optimize;
  end;

  PUBLIC
    ZStatements : TObjectList;
  PRIVATE
    procedure WriteStr(S : string);
    procedure WriteOp(Op : TZcOp);
    procedure AddGlobalStatement(Op : TZcOp);
    procedure CleanUp;
  CREATE
    ZStatements := TObjectList.Create(False);
    //Alla nodes ägs av globalcleanups
    GlobalCleanUps := TObjectList.Create;
  DESTROY
    CleanUp;
  ERRORS
    200 : Result := 'Not a floating point value';
END_DELPHI

(* Arbitrary Code *)

var
  GlobalCleanUps : TObjectList;

function MakeOp(Kind : TZcOpKind) : TZcOp; overload;
begin
  Result := TZcOp.Create;
  Result.Kind := Kind;
end;
function MakeOp(Kind : TZcOpKind; Value : single) : TZcOp; overload;
begin
  Result := MakeOp(Kind);
  Result.Value := Value;
end;
function MakeOp(Kind : TZcOpKind; Id :string) : TZcOp; overload;
begin
  Result := MakeOp(Kind);
  Result.Id := Id;
end;
function MakeOp(Kind : TZcOpKind; const Children : array of TZcOp) : TZcOp; overload;
var
  I : integer;
begin
  Result := MakeOp(Kind);
  for I := 0 to High(Children) do
    Result.Children.Add(Children[I]);
end;

function MakeAssign(Kind : TZcAssignType; Op1,Op2 : TZcOp) : TZcOp;
const
  AssignMap : array[TZcAssignType] of TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus);
var
  Tmp : TZcOp;
begin
  case Kind of
    atMulAssign,atDivAssign,atPlusAssign,atMinusAssign :  //Convert x*=2 to x=x*2
      begin
        Tmp := MakeOp(zcIdentifier,Op1.Id);
        Op2 := MakeOp(AssignMap[Kind],[Tmp,Op2]);
      end;
  end;
  Result := MakeOp(zcAssign,[Op1,Op2]);
end;

constructor TZcOp.Create;
begin
  Children := TObjectList.Create(False);
  GlobalCleanUps.Add(Self);
end;

destructor TZcOp.Destroy;
//var
//  I : integer;
begin
//  for I := 0 to Children.Count-1 do
//    if Assigned(Children[I]) then Child(I).Free;
  FreeAndNil(Children);
end;

function TZcOp.Child(I : integer) : TZcOp;
begin
  Result := TZcOp(Children[I]);
end;

function TZcOp.ToString : string;
var
  I : integer;
begin
  case Kind of
    zcMul : Result := Child(0).ToString + '*' + Child(1).ToString;
    zcDiv : Result := Child(0).ToString + '/' + Child(1).ToString;
    zcPlus : Result := Child(0).ToString + '+' + Child(1).ToString;
    zcMinus : Result := Child(0).ToString + '-' + Child(1).ToString;
    zcConst : Result := FloatToStr(Value);
    zcIdentifier : Result := Id;
    zcAssign : Result := Child(0).ToString + '=' + Child(1).ToString;
    zcIf :
      begin
        Result := 'if(' + Child(0).ToString + ') ' + Child(1).ToString;
        if Assigned(Child(2)) then
          Result := Result + ' else ' + Child(2).ToString;
      end;
    zcCompLT : Result := Child(0).ToString + '<' + Child(1).ToString;
    zcCompGT : Result := Child(0).ToString + '>' + Child(1).ToString;
    zcCompLE : Result := Child(0).ToString + '<=' + Child(1).ToString;
    zcCompGE : Result := Child(0).ToString + '>=' + Child(1).ToString;
    zcCompNE : Result := Child(0).ToString + '!=' + Child(1).ToString;
    zcCompEQ : Result := Child(0).ToString + '==' + Child(1).ToString;
    zcBlock :
      begin
        Result := '{'#13#10;
        for I := 0 to Children.Count-1 do
          Result := Result + Child(I).ToString + '; ';
        Result := Result + '}'#13#10;
      end;
    zcNegate : Result := '-' + Child(0).ToString;
    zcOr : Result := Child(0).ToString + ' || ' + Child(1).ToString;
    zcAnd : Result := Child(0).ToString + ' && ' + Child(1).ToString;
    zcFuncCall :
      begin
        Result := Id + '(';
        for I := 0 to Children.Count-1 do
        begin
          if I>0 then
            Result := Result + ',';
          Result := Result + Child(I).ToString;
        end;
        Result := Result + ')';
      end;
    zcNop : Result := ';';       //Empty statement
    zcReturn : Result := 'return ' + Child(0).ToString + ';';
  end;
end;

procedure TZcOp.Optimize;
var
  I : integer;

  procedure DoConstant(NewValue : single);
  begin
    if (Child(0).Kind=zcConst) and (Child(1).Kind=zcConst) then
    begin
      Kind := zcConst;
      Value := NewValue;
    end;
  end;

begin
  for I := 0 to Children.Count-1 do
    if Assigned(Child(I)) then Child(I).Optimize;
  case Kind of
    //todo: more optimizations
    zcMul : DoConstant(Child(0).Value * Child(1).Value);
    zcDiv : DoConstant(Child(0).Value / Child(1).Value);
    zcPlus : DoConstant(Child(0).Value + Child(1).Value);
    zcMinus : DoConstant(Child(0).Value - Child(1).Value);
    zcNegate :
      if Child(0).Kind=zcConst then
      begin
        Kind := zcConst;
        Value := Child(0).Value * -1;
      end;
  end;
end;

procedure T-->Grammar<--.WriteStr(S : string);
begin
  StreamToListFile(S, TRUE);
end;

procedure T-->Grammar<--.WriteOp(Op : TZcOp);
begin
  WriteStr(Op.ToString);
end;

procedure T-->Grammar<--.AddGlobalStatement(Op : TZcOp);
begin
  ZStatements.Add(Op);
end;

procedure T-->Grammar<--.CleanUp;
//var
//  I : integer;
begin
//  for I := 0 to ZSTatements.Count-1 do TObject(ZStatements[I]).Free;
  ZStatements.Free;
  GlobalCleanUps.Free;
end;

CHARACTERS

        tab                = CHR(9). /*  9 = tabulator */
        eol                = CHR(10). /* 10 = line feed */
        cr                 = CHR(13). /* 13 = carriage return */
        newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

        letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
        digit              = "0123456789".
        hexDigit           = digit + "ABCDEFabcdef".
        notDigit           = ANY - digit.

        char               = ANY - "'" - '\\' - newLine.
        verbatimStringChar = ANY - '"'.
        regularStringChar  = ANY - '"' - '\\' - newLine.
        notNewLine         = ANY - newLine .


TOKENS

  /*--------------------------------------------------------------------------------*/
        intCon =
                ( digit {digit}
                | ("0x" | "0X") hexDigit {hexDigit}
                )
                ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  /*--------------------------------------------------------------------------------*/
        realCon =
                "." digit {digit}
                [("e" | "E") ["+" | "-"] digit {digit}]
                ["F" | "f" | "D" | "d" | "M" | "m"]
        | digit {digit}
                ( "." digit {digit}
                        [("e" | "E" ) ["+" | "-"] digit {digit} ]
                        ["F" | "f" | "D" | "d" | "M" | "m"]
                | ("e" | "E") ["+" | "-"] digit {digit}
                        ["F" | "f" | "D" | "d" | "M" | "m"]
                | "F" | "f" | "D" | "d" | "M" | "m"
                ).
  /*--------------------------------------------------------------------------------*/
        stringCon =
                '"'    { regularStringChar }
                '"'.

        ident = ['@'] letter { letter | digit }.


        /*----- operators and special characters needed in LL(1) resolvers --------------*/
        and    = "&".
        assgn  = "=".
        colon  = ":".
        comma  = ",".
        dec    = "--".
        div    = "/".
        dot    = ".".
        eq     = "==".
        gt     = ">".
        gte    = ">=".
        inc    = "++".
        lbrace = "{".
        lbrack = "[".
        lpar   = "(".
        lshift = "<<".
        lt     = "<".
        lte    = "<=".
        minus  = "-".
        mod    = "%".
        neq    = "!=".
        not    = "!".
        or     = "|".
        plus   = "+".
        rbrace = "}".
        rbrack = "]".
        rpar   = ")".
        rshift = ">>".
        scolon = ";".
        tilde  = "~".
        times  = "*".
        xor    = "^".



COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO eol

IGNORE eol + cr + tab

PRODUCTIONS

/*------------------------------------------------------------------------*
 *--------------------------- Declarations -------------------------------*
 *------------------------------------------------------------------------*/

Zc      (. var Op : TZcOp; I : integer; .)
= (. Op := nil; .)
  {EmbeddedStatement<Op>
      (. if Op<>nil then
           AddGlobalStatement(Op);
         Op := nil;
      .)
   }

  (. if Successful then
     begin
       for I:=0 to ZStatements.Count-1 do
       begin
         TZcOp(ZStatements[I]).Optimize;
         WriteOp(TZcOp(ZStatements[I]));
       end;
     end;
  .)
.


/*------------------------------------------------------------------------*/

/* LocalVarDecl
= Type LocalVar {"," LocalVar}
. */

/*------------------------------------------------------------------------*/

/* LocalVar       (. var Op : TZcOp; .)
= ident [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ]
. */

/*------------------------------------------------------------------------*/

/* Init           (. var Op : TZcOp; .)
= Expr<Op>
.  */

/*------------------------------------------------------------------------*/
Argument<var OutOp : TZcOp>
= /* ["ref" | "out"] */
  Expr<OutOp>
.

/*------------------------------------------------------------------------*
 *-------------------------------- Types ---------------------------------*
 *------------------------------------------------------------------------*/

/* Attribute "type" is needed for error messages in EmbeddedStatement     *
 * and for array creation expressions                                     */

/*
Type
= ( SimpleType )
. */

/*------------------------------------------------------------------------*/

/* SimpleType
= IntType | "float" | "double" | "decimal" | "bool"
.  */

/*------------------------------------------------------------------------*/

/* IntType
= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
. */


/*------------------------------------------------------------------------*
 *------------------------------ Statements ------------------------------*
 *------------------------------------------------------------------------*/

Statement<var OutOp : TZcOp>
=
/* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
/* | LocalVarDecl ";"
 | */
 EmbeddedStatement<OutOp>
  /* LL(1) confict between LocalVarDecl and StatementExpr: *
   * ident {"." ident} { "[" ...                           */
.
/*------------------------------------------------------------------------*/
EmbeddedStatement<var OutOp : TZcOp>
  (. var
       Op,IfOp,IfBody,ElseOp : TZcOp;
  .)
=
  Block<OutOp>
| ";"   (. OutOp := MakeOp(zcNop); .)
| StatementExpr<OutOp> ";"
| "if" (. ElseOp := nil; .)
  "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
        (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
/* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
/* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
/* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
/* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
/* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
/* | "break" ";" */
/* | "continue" ";" */
 | "return" Expr<Op> ";"   (. OutOp := MakeOp(zcReturn,[Op]); {return måste har ett expr} .)
.
/*------------------------------------------------------------------------*/

Block<var OutOp : TZcOp>
  (. var
       Op : TZcOp;
  .)
= (. OutOp := MakeOp(zcBlock); .)
  "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".

/*------------------------------------------------------------------------*/
StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
=
  Unary<Op1>
  ( AssignOp<Kind> Expr<Op2>
    (.
      OutOp := MakeAssign(Kind,Op1,Op2);
    .)
  |                             (. OutOp := Op1; .)
  )
.

/*------------------------------------------------------------------------*/
AssignOp<var Kind : TZcAssignType>
= "="     (. Kind := atAssign; .)
  | "+="  (. Kind := atPlusAssign; .)
  | "-="  (. Kind := atMinusAssign; .)
  | "*="  (. Kind := atMulAssign; .)
  | "/="  (. Kind := atDivAssign; .)
/*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
.

/*------------------------------------------------------------------------*/

/* SwitchSection   (. var Op : TZcOp; .)
= SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
.  */

/*------------------------------------------------------------------------*/

/* SwitchLabel     (. var Op : TZcOp; .)
= "case" Expr<Op> ":"
| "default" ":"
.  */

/*------------------------------------------------------------------------*/

/* ForInit     (. var Op : TZcOp; .)
= LocalVarDecl
| StatementExpr<Op> { "," StatementExpr<Op> }
.  */

/*------------------------------------------------------------------------*/

/* ForInc      (. var Op : TZcOp; .)
= StatementExpr<Op> { "," StatementExpr<Op> }
.  */


/*------------------------------------------------------------------------*
 *----------------------------- Expressions ------------------------------*
 *------------------------------------------------------------------------*/


Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
= Unary<Op1>
  ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  )
.
/*------------------------------------------------------------------------*/
OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
= AndExpr<InOp,OutOp>   (. L := OutOp; .)
    {"||" Unary<Op> AndExpr<Op,R>
      (. OutOp := MakeOp(zcOr,[L,R]);
         L := OutOp; .)
    }
.


/*------------------------------------------------------------------------*/
AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
= BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
    {"&&" Unary<Op> BitOrExpr<Op,R>
      (. OutOp := MakeOp(zcAnd,[L,R]);
         L := OutOp; .)
    }
.
/*------------------------------------------------------------------------*/
BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
= BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
.
/*------------------------------------------------------------------------*/
BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
= BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
.
/*------------------------------------------------------------------------*/
BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
= EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
.
/*------------------------------------------------------------------------*/
EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
= RelExpr<InOp,OutOp>   (. L := OutOp; .)
  {( "!="   (. Kind := zcCompNE; .)
   | "=="   (. Kind := zcCompEQ; .)
   )
   Unary<Op> RelExpr<Op,R>
         (. OutOp := MakeOp(Kind,[L,R]);
            L := OutOp;
         .)
  }
.
/*------------------------------------------------------------------------*/
RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
= ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  { ( "<"       (. Kind := zcCompLT; .)
    | ">"       (. Kind := zcCompGT; .)
    | "<="      (. Kind := zcCompLE; .)
    | ">="      (. Kind := zcCompGE; .)
     )
    Unary<Op> ShiftExpr<Op,R>
         (. OutOp := MakeOp(Kind,[L,R]);
            L := OutOp;
         .)
  }
.
/*------------------------------------------------------------------------*/
ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
= AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
.
/*------------------------------------------------------------------------*/
AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
= MulExpr<InOp,OutOp>   (. L := OutOp; .)
    {( "+"    (. Kind := zcPlus; .)
     | "-"    (. Kind := zcMinus; .)
     ) Unary<Op> MulExpr<Op,R>
         (. OutOp := MakeOp(Kind,[L,R]);
            L := OutOp;
         .)
    }
.
/*------------------------------------------------------------------------*/
MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
=       (. OutOp := InOp; .)
  { ("*"      (. Kind := zcMul; .)
    | "/"     (. Kind := zcDiv; .)
  (*  | "%" *)
    ) Unary<Tmp>
         (. OutOp := MakeOp(Kind,[InOp,Tmp]);
            InOp := OutOp;
         .)
    }
.
/*------------------------------------------------------------------------*/
Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
=       (. LastOp := nil; .)
  {
    (
      (* "+" | *)
      "-"       (. Kind := zcNegate; .)
      (* | "!" | "~" | "*" | "++" | "--" *)
    )   (. Tmp := MakeOp(Kind);
           if LastOp<>nil then
             LastOp.Children.Add(Tmp);
           LastOp := Tmp;
        .)
  }
  Primary<Tmp>
    (. if LastOp<>nil then
       begin
         LastOp.Children.Add(Tmp);
         OutOp := LastOp;
       end else
         OutOp := Tmp;
    .)
.
/*------------------------------------------------------------------------*/
Primary<var OutOp : TZcOp>         (. var Op : TZcOp; .)
=            (. OutOp := nil; .)
  ( ident    (. OutOp := MakeOp(zcIdentifier,LexString); .)
  | Literal  (. 
        try
          OutOp := MakeOp(zcConst,StrToFloat(LexString)); 
        except on EConvertError do
          SynError(200);
        end;
     .)
  | "(" Expr<OutOp> ")"
(*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
    | "float"  | "int"    | "long" | "object"  | "sbyte"
    | "short"  | "string" | "uint" | "ulong"   | "ushort"
    ) "." ident *)
  )

  {
/*  "++" | "--" | "->" ident
  | */
  "." ident (.
      Assert(OutOp.Kind=zcIdentifier);
      OutOp.Id := OutOp.Id + '.' + LexString;
    .)
  | "(" (. Assert(OutOp.Kind=zcIdentifier);
           OutOp.Kind:=zcFuncCall;
         .)
        [Argument<Op> (. OutOp.Children.Add(Op); .)
          {"," Argument<Op> (. OutOp.Children.Add(Op); .)
          }
        ]
    ")"
  }
.
/*------------------------------------------------------------------------*/
Literal
= intCon | realCon | stringCon | "true" | "false" | "null"
.

END Zc.
