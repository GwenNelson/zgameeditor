unit Zc;




{==============================================================================
Zc
1.0.0.116
Date of Generation: 2006-05-09 16:41
Comment: Zc
Author: Ville Krumlinde
Copyright: 

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Zc_Ops,contnrs,uSymTab,ZClasses,mwStringHashList;



const
maxT = 81;
type

  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EZc = class(Exception);
  TZc = class;

  TZcScanner = class(TCocoRScanner)
  private
    FOwner : TZc;
fHashList: TmwStringHashList;
function CharInIgnoreSet(const Ch : char) : boolean;
procedure CheckLiteral(var Sym : integer);
function GetNextSymbolString: string;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TZc read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TZcScanner }

  TZc = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..5] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : string;
    function GetVersionStr : string;
    procedure SetVersion(const Value : string);
    function GetVersionInfo : string;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Literal (var Typ : TZcDataType);
    procedure _Primary (var OutOp : TZcOp);
    procedure _MulExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _AddExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _ShiftExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _RelExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _EqlExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitAndExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitXorExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitOrExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _AndExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _OrExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _AssignOp (var Kind : TZcAssignType);
    procedure _Unary (var OutOp : TZcOp);
    procedure _ForInc (var OutOp : TZcOp);
    procedure _ForInit (var OutOp : TZcOp);
    procedure _StatementExpr (var OutOp : TZcOp);
    procedure _Block (var OutOp : TZcOp);
    procedure _EmbeddedStatement (var OutOp : TZcOp);
    procedure _SimpleType (var Typ : TZcDataType);
    procedure _Argument (var OutOp : TZcOp);
    procedure _Expr (var OutOp : TZcOp);
    procedure _Init (var OutOp : TZcOp);
    procedure _LocalVar (Typ : TZcDataType; var OutOp : TZcOp);
    procedure _LocalVarDecl (var OutOp : TZcOp);
    procedure _Par;
    procedure _Statement (var OutOp : TZcOp);
    procedure _ZcFuncBody;
    procedure _FormalParams;
    procedure _Type (var Typ : TZcDataType);
    procedure _Zc;

  private
    CurrentFunction : TZcOpFunctionUserDefined;
    procedure CleanUp;
    function NoFunctionsAllowed : boolean;
    procedure ZError(const S : string);

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : string) : string; override;
    procedure Execute;
    function GetScanner : TZcScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : string read GetVersionStr;
    property VersionInfo : string read GetVersionInfo;

  public
    ZFunctions : TObjectList;
    SymTab : TSymbolTable;
    ReturnType : TZcDataType;
    AllowFunctions : boolean;
    GlobalNames : TObjectList;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : string read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TZc }

implementation
uses  ExprEdit;



const

  EOFSYMB = 0;  intConSym = 1;  realConSym = 2;  stringConSym = 3;
  identSym = 4;  andSym = 5;  assgnSym = 6;  colonSym = 7;  commaSym = 8;
  decSym = 9;  divSym = 10;  dotSym = 11;  eqSym = 12;  gtSym = 13;
  gteSym = 14;  incSym = 15;  lbraceSym = 16;  lbrackSym = 17;  lparSym = 18;
  lshiftSym = 19;  ltSym = 20;  lteSym = 21;  minusSym = 22;  modSym = 23;
  neqSym = 24;  notSym = 25;  orSym = 26;  plusSym = 27;  rbraceSym = 28;
  rbrackSym = 29;  rparSym = 30;  rshiftSym = 31;  scolonSym = 32;
  tildeSym = 33;  timesSym = 34;  xorSym = 35;  voidSym = 36;  _lparenSym = 37;
  _rparenSym = 38;  _lbraceSym = 39;  _rbraceSym = 40;  _commaSym = 41;
  _equalSym = 42;  floatSym = 43;  intSym = 44;  stringSym = 45;
  _semicolonSym = 46;  ifSym = 47;  elseSym = 48;  whileSym = 49;  forSym = 50;
  breakSym = 51;  continueSym = 52;  returnSym = 53;  _plus_equalSym = 54;
  _minus_equalSym = 55;  _star_equalSym = 56;  _slash_equalSym = 57;
  _bar_barSym = 58;  _and_andSym = 59;  _barSym = 60;  _uparrowSym = 61;
  _andSym = 62;  _bang_equalSym = 63;  _equal_equalSym = 64;  _lessSym = 65;
  _greaterSym = 66;  _less_equalSym = 67;  _greater_equalSym = 68;
  _less_lessSym = 69;  _greater_greaterSym = 70;  _plusSym = 71;
  _minusSym = 72;  _starSym = 73;  _slashSym = 74;  _plus_plusSym = 75;
  _minus_minusSym = 76;  _bangSym = 77;  _pointSym = 78;  _lbrackSym = 79;
  _rbrackSym = 80;  NOSYMB = 81;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
procedure TZc.CleanUp;
begin
  Zc_Ops.FunctionCleanUps.Clear;
  ZFunctions.Free;
end;

function TZc.NoFunctionsAllowed : boolean;
begin
  Result := not AllowFunctions;
end;

procedure TZc.ZError(const S : string);
var
  E : EParseError;
begin
  E := EParseError.Create(S);
  E.Message := S;
  E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
  E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
  raise E;
end;




{ --------------------------------------------------------------------------- }
{ ---- implementation for TZcScanner ---- }

procedure TZcScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TZcScanner.Comment : boolean;
var
  level : integer;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : string;
begin
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = CHR(10)) then
begin
level := level - 1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level - 1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
end;  { Comment }

function TZcScanner.CharInIgnoreSet(const Ch : char) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= CHR(9)) AND (CurrInputCh <= CHR(10)) OR
(CurrInputCh = CHR(13)));
end; {CharInIgnoreSet}

function TZcScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    inc(q);
    inc(i);
  end;
end; {GetNextSymbolString}

procedure TZcScanner.CheckLiteral(var Sym : integer);
var
  SymId : integer;
  DefaultSymId : integer;
  aToken : string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
      sym := SymId;
  end;
end; {CheckLiteral}


procedure TZcScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '/')) AND Comment then
begin
  Get(sym);
  exit;
  end;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
 
end
else
begin
sym := intConSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 4; 
end
else
begin
sym := realConSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 6; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 5; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
   7: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 8; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 9; 
end
else
begin
sym := realConSym;
exit;
end;
   9: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 11; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 11; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
  12: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 14; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  14: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
  15: begin
sym := realConSym;
exit;
end;
  16: if ((CurrInputCh <= CHR(9)) OR
(CurrInputCh >= CHR(11)) AND (CurrInputCh <= CHR(12)) OR
(CurrInputCh >= CHR(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '"') then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: begin
sym := stringConSym;
exit;
end;
  18: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := identSym;
CheckLiteral(sym);
exit;
end;
  20: if (CurrInputCh = '&') then
begin
state := 59; 
end
else
begin
sym := andSym;
CheckLiteral(sym);
exit;
end;
  21: begin
sym := colonSym;
exit;
end;
  22: begin
sym := commaSym;
CheckLiteral(sym);
exit;
end;
  23: begin
sym := decSym;
CheckLiteral(sym);
exit;
end;
  24: if (CurrInputCh = '=') then
begin
state := 57; 
end
else
begin
sym := divSym;
CheckLiteral(sym);
exit;
end;
  25: begin
sym := eqSym;
CheckLiteral(sym);
exit;
end;
  26: begin
sym := gteSym;
CheckLiteral(sym);
exit;
end;
  27: begin
sym := incSym;
CheckLiteral(sym);
exit;
end;
  28: begin
sym := lbraceSym;
CheckLiteral(sym);
exit;
end;
  29: begin
sym := lbrackSym;
CheckLiteral(sym);
exit;
end;
  30: begin
sym := lparSym;
CheckLiteral(sym);
exit;
end;
  31: begin
sym := lshiftSym;
CheckLiteral(sym);
exit;
end;
  32: begin
sym := lteSym;
CheckLiteral(sym);
exit;
end;
  33: begin
sym := modSym;
exit;
end;
  34: begin
sym := neqSym;
CheckLiteral(sym);
exit;
end;
  35: if (CurrInputCh = '|') then
begin
state := 58; 
end
else
begin
sym := orSym;
CheckLiteral(sym);
exit;
end;
  36: begin
sym := rbraceSym;
CheckLiteral(sym);
exit;
end;
  37: begin
sym := rbrackSym;
CheckLiteral(sym);
exit;
end;
  38: begin
sym := rparSym;
CheckLiteral(sym);
exit;
end;
  39: begin
sym := rshiftSym;
CheckLiteral(sym);
exit;
end;
  40: begin
sym := scolonSym;
CheckLiteral(sym);
exit;
end;
  41: begin
sym := tildeSym;
exit;
end;
  42: if (CurrInputCh = '=') then
begin
state := 56; 
end
else
begin
sym := timesSym;
CheckLiteral(sym);
exit;
end;
  43: begin
sym := xorSym;
CheckLiteral(sym);
exit;
end;
  44: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 7; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 12; 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := intConSym;
exit;
end;
  45: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 44; 
end
else if ((CurrInputCh = 'X') OR
(CurrInputCh = 'x')) then
begin
state := 1; 
end
else if (CurrInputCh = '.') then
begin
state := 7; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 12; 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := intConSym;
exit;
end;
  46: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 3; 
end
else
begin
sym := dotSym;
CheckLiteral(sym);
exit;
end;
  47: if (CurrInputCh = '=') then
begin
state := 25; 
end
else
begin
sym := assgnSym;
CheckLiteral(sym);
exit;
end;
  48: if (CurrInputCh = '-') then
begin
state := 23; 
end
else if (CurrInputCh = '=') then
begin
state := 55; 
end
else
begin
sym := minusSym;
CheckLiteral(sym);
exit;
end;
  49: if (CurrInputCh = '=') then
begin
state := 26; 
end
else if (CurrInputCh = '>') then
begin
state := 39; 
end
else
begin
sym := gtSym;
CheckLiteral(sym);
exit;
end;
  50: if (CurrInputCh = '+') then
begin
state := 27; 
end
else if (CurrInputCh = '=') then
begin
state := 54; 
end
else
begin
sym := plusSym;
CheckLiteral(sym);
exit;
end;
  51: if (CurrInputCh = '<') then
begin
state := 31; 
end
else if (CurrInputCh = '=') then
begin
state := 32; 
end
else
begin
sym := ltSym;
CheckLiteral(sym);
exit;
end;
  52: if (CurrInputCh = '=') then
begin
state := 34; 
end
else
begin
sym := notSym;
CheckLiteral(sym);
exit;
end;
  53: if ((CurrInputCh = '"') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '\') OR
(CurrInputCh = 'n')) then
begin
state := 16; 
end
else
begin
  sym := _noSym;
exit;
end;
  54: begin
sym := _plus_equalSym;
exit;
end;
  55: begin
sym := _minus_equalSym;
exit;
end;
  56: begin
sym := _star_equalSym;
exit;
end;
  57: begin
sym := _slash_equalSym;
exit;
end;
  58: begin
sym := _bar_barSym;
exit;
end;
  59: begin
sym := _and_andSym;
exit;
end;
  60: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TZcScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(TinyHash, HashSecondaryOne, HashCompare);
fHashList.AddString('!', _bangSym, _bangSym);
fHashList.AddString('!=', _bang_equalSym, _bang_equalSym);
fHashList.AddString('&', _andSym, _andSym);
fHashList.AddString('(', _lparenSym, _lparenSym);
fHashList.AddString(')', _rparenSym, _rparenSym);
fHashList.AddString('*', _starSym, _starSym);
fHashList.AddString('+', _plusSym, _plusSym);
fHashList.AddString('++', _plus_plusSym, _plus_plusSym);
fHashList.AddString(',', _commaSym, _commaSym);
fHashList.AddString('-', _minusSym, _minusSym);
fHashList.AddString('--', _minus_minusSym, _minus_minusSym);
fHashList.AddString('.', _pointSym, _pointSym);
fHashList.AddString('/', _slashSym, _slashSym);
fHashList.AddString(';', _semicolonSym, _semicolonSym);
fHashList.AddString('<', _lessSym, _lessSym);
fHashList.AddString('<<', _less_lessSym, _less_lessSym);
fHashList.AddString('<=', _less_equalSym, _less_equalSym);
fHashList.AddString('=', _equalSym, _equalSym);
fHashList.AddString('==', _equal_equalSym, _equal_equalSym);
fHashList.AddString('>', _greaterSym, _greaterSym);
fHashList.AddString('>=', _greater_equalSym, _greater_equalSym);
fHashList.AddString('>>', _greater_greaterSym, _greater_greaterSym);
fHashList.AddString('[', _lbrackSym, _lbrackSym);
fHashList.AddString(']', _rbrackSym, _rbrackSym);
fHashList.AddString('^', _uparrowSym, _uparrowSym);
fHashList.AddString('break', breakSym, breakSym);
fHashList.AddString('continue', continueSym, continueSym);
fHashList.AddString('else', elseSym, elseSym);
fHashList.AddString('float', floatSym, floatSym);
fHashList.AddString('for', forSym, forSym);
fHashList.AddString('if', ifSym, ifSym);
fHashList.AddString('int', intSym, intSym);
fHashList.AddString('return', returnSym, returnSym);
fHashList.AddString('string', stringSym, stringSym);
fHashList.AddString('void', voidSym, voidSym);
fHashList.AddString('while', whileSym, whileSym);
fHashList.AddString('{', _lbraceSym, _lbraceSym);
fHashList.AddString('|', _barSym, _barSym);
fHashList.AddString('}', _rbraceSym, _rbraceSym);
CurrentCh := CharAt;
fStartState[  0] := 60; fStartState[  1] := 61; fStartState[  2] := 61; fStartState[  3] := 61; 
fStartState[  4] := 61; fStartState[  5] := 61; fStartState[  6] := 61; fStartState[  7] := 61; 
fStartState[  8] := 61; fStartState[  9] := 61; fStartState[ 10] := 61; fStartState[ 11] := 61; 
fStartState[ 12] := 61; fStartState[ 13] := 61; fStartState[ 14] := 61; fStartState[ 15] := 61; 
fStartState[ 16] := 61; fStartState[ 17] := 61; fStartState[ 18] := 61; fStartState[ 19] := 61; 
fStartState[ 20] := 61; fStartState[ 21] := 61; fStartState[ 22] := 61; fStartState[ 23] := 61; 
fStartState[ 24] := 61; fStartState[ 25] := 61; fStartState[ 26] := 61; fStartState[ 27] := 61; 
fStartState[ 28] := 61; fStartState[ 29] := 61; fStartState[ 30] := 61; fStartState[ 31] := 61; 
fStartState[ 32] := 61; fStartState[ 33] := 52; fStartState[ 34] := 16; fStartState[ 35] := 61; 
fStartState[ 36] := 61; fStartState[ 37] := 33; fStartState[ 38] := 20; fStartState[ 39] := 61; 
fStartState[ 40] := 30; fStartState[ 41] := 38; fStartState[ 42] := 42; fStartState[ 43] := 50; 
fStartState[ 44] := 22; fStartState[ 45] := 48; fStartState[ 46] := 46; fStartState[ 47] := 24; 
fStartState[ 48] := 45; fStartState[ 49] := 44; fStartState[ 50] := 44; fStartState[ 51] := 44; 
fStartState[ 52] := 44; fStartState[ 53] := 44; fStartState[ 54] := 44; fStartState[ 55] := 44; 
fStartState[ 56] := 44; fStartState[ 57] := 44; fStartState[ 58] := 21; fStartState[ 59] := 40; 
fStartState[ 60] := 51; fStartState[ 61] := 47; fStartState[ 62] := 49; fStartState[ 63] := 61; 
fStartState[ 64] := 18; fStartState[ 65] := 19; fStartState[ 66] := 19; fStartState[ 67] := 19; 
fStartState[ 68] := 19; fStartState[ 69] := 19; fStartState[ 70] := 19; fStartState[ 71] := 19; 
fStartState[ 72] := 19; fStartState[ 73] := 19; fStartState[ 74] := 19; fStartState[ 75] := 19; 
fStartState[ 76] := 19; fStartState[ 77] := 19; fStartState[ 78] := 19; fStartState[ 79] := 19; 
fStartState[ 80] := 19; fStartState[ 81] := 19; fStartState[ 82] := 19; fStartState[ 83] := 19; 
fStartState[ 84] := 19; fStartState[ 85] := 19; fStartState[ 86] := 19; fStartState[ 87] := 19; 
fStartState[ 88] := 19; fStartState[ 89] := 19; fStartState[ 90] := 19; fStartState[ 91] := 29; 
fStartState[ 92] := 61; fStartState[ 93] := 37; fStartState[ 94] := 43; fStartState[ 95] := 19; 
fStartState[ 96] := 61; fStartState[ 97] := 19; fStartState[ 98] := 19; fStartState[ 99] := 19; 
fStartState[100] := 19; fStartState[101] := 19; fStartState[102] := 19; fStartState[103] := 19; 
fStartState[104] := 19; fStartState[105] := 19; fStartState[106] := 19; fStartState[107] := 19; 
fStartState[108] := 19; fStartState[109] := 19; fStartState[110] := 19; fStartState[111] := 19; 
fStartState[112] := 19; fStartState[113] := 19; fStartState[114] := 19; fStartState[115] := 19; 
fStartState[116] := 19; fStartState[117] := 19; fStartState[118] := 19; fStartState[119] := 19; 
fStartState[120] := 19; fStartState[121] := 19; fStartState[122] := 19; fStartState[123] := 28; 
fStartState[124] := 35; fStartState[125] := 36; fStartState[126] := 41; fStartState[127] := 61; 
fStartState[128] := 61; fStartState[129] := 61; fStartState[130] := 61; fStartState[131] := 61; 
fStartState[132] := 61; fStartState[133] := 61; fStartState[134] := 61; fStartState[135] := 61; 
fStartState[136] := 61; fStartState[137] := 61; fStartState[138] := 61; fStartState[139] := 61; 
fStartState[140] := 61; fStartState[141] := 61; fStartState[142] := 61; fStartState[143] := 61; 
fStartState[144] := 61; fStartState[145] := 61; fStartState[146] := 61; fStartState[147] := 61; 
fStartState[148] := 61; fStartState[149] := 61; fStartState[150] := 61; fStartState[151] := 61; 
fStartState[152] := 61; fStartState[153] := 61; fStartState[154] := 61; fStartState[155] := 61; 
fStartState[156] := 61; fStartState[157] := 61; fStartState[158] := 61; fStartState[159] := 61; 
fStartState[160] := 61; fStartState[161] := 61; fStartState[162] := 61; fStartState[163] := 61; 
fStartState[164] := 61; fStartState[165] := 61; fStartState[166] := 61; fStartState[167] := 61; 
fStartState[168] := 61; fStartState[169] := 61; fStartState[170] := 61; fStartState[171] := 61; 
fStartState[172] := 61; fStartState[173] := 61; fStartState[174] := 61; fStartState[175] := 61; 
fStartState[176] := 61; fStartState[177] := 61; fStartState[178] := 61; fStartState[179] := 61; 
fStartState[180] := 61; fStartState[181] := 61; fStartState[182] := 61; fStartState[183] := 61; 
fStartState[184] := 61; fStartState[185] := 61; fStartState[186] := 61; fStartState[187] := 61; 
fStartState[188] := 61; fStartState[189] := 61; fStartState[190] := 61; fStartState[191] := 61; 
fStartState[192] := 61; fStartState[193] := 61; fStartState[194] := 61; fStartState[195] := 61; 
fStartState[196] := 61; fStartState[197] := 61; fStartState[198] := 61; fStartState[199] := 61; 
fStartState[200] := 61; fStartState[201] := 61; fStartState[202] := 61; fStartState[203] := 61; 
fStartState[204] := 61; fStartState[205] := 61; fStartState[206] := 61; fStartState[207] := 61; 
fStartState[208] := 61; fStartState[209] := 61; fStartState[210] := 61; fStartState[211] := 61; 
fStartState[212] := 61; fStartState[213] := 61; fStartState[214] := 61; fStartState[215] := 61; 
fStartState[216] := 61; fStartState[217] := 61; fStartState[218] := 61; fStartState[219] := 61; 
fStartState[220] := 61; fStartState[221] := 61; fStartState[222] := 61; fStartState[223] := 61; 
fStartState[224] := 61; fStartState[225] := 61; fStartState[226] := 61; fStartState[227] := 61; 
fStartState[228] := 61; fStartState[229] := 61; fStartState[230] := 61; fStartState[231] := 61; 
fStartState[232] := 61; fStartState[233] := 61; fStartState[234] := 61; fStartState[235] := 61; 
fStartState[236] := 61; fStartState[237] := 61; fStartState[238] := 61; fStartState[239] := 61; 
fStartState[240] := 61; fStartState[241] := 61; fStartState[242] := 61; fStartState[243] := 61; 
fStartState[244] := 61; fStartState[245] := 61; fStartState[246] := 61; fStartState[247] := 61; 
fStartState[248] := 61; fStartState[249] := 61; fStartState[250] := 61; fStartState[251] := 61; 
fStartState[252] := 61; fStartState[253] := 61; fStartState[254] := 61; fStartState[255] := 61; 
end; {Create}

destructor TZcScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TZc ---- }

constructor TZc.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TZcScanner.Create;
  GetScanner.Owner := self;
ZFunctions := TObjectList.Create(False);

  InitSymSet;
end; {Create}

destructor TZc.Destroy;
begin
  Scanner.Free;
CleanUp;

  inherited;
end; {Destroy}

function TZc.ErrorStr(const ErrorCode : integer; const Data : string) : string;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'intCon expected';
   2 : Result := 'realCon expected';
   3 : Result := 'stringCon expected';
   4 : Result := 'ident expected';
   5 : Result := 'and expected';
   6 : Result := 'assgn expected';
   7 : Result := 'colon expected';
   8 : Result := 'comma expected';
   9 : Result := 'dec expected';
  10 : Result := 'div expected';
  11 : Result := 'dot expected';
  12 : Result := 'eq expected';
  13 : Result := 'gt expected';
  14 : Result := 'gte expected';
  15 : Result := 'inc expected';
  16 : Result := 'lbrace expected';
  17 : Result := 'lbrack expected';
  18 : Result := 'lpar expected';
  19 : Result := 'lshift expected';
  20 : Result := 'lt expected';
  21 : Result := 'lte expected';
  22 : Result := 'minus expected';
  23 : Result := 'mod expected';
  24 : Result := 'neq expected';
  25 : Result := 'not expected';
  26 : Result := 'or expected';
  27 : Result := 'plus expected';
  28 : Result := 'rbrace expected';
  29 : Result := 'rbrack expected';
  30 : Result := 'rpar expected';
  31 : Result := 'rshift expected';
  32 : Result := 'scolon expected';
  33 : Result := 'tilde expected';
  34 : Result := 'times expected';
  35 : Result := 'xor expected';
  36 : Result := '"void" expected';
  37 : Result := '"(" expected';
  38 : Result := '")" expected';
  39 : Result := '"{" expected';
  40 : Result := '"}" expected';
  41 : Result := '"," expected';
  42 : Result := '"=" expected';
  43 : Result := '"float" expected';
  44 : Result := '"int" expected';
  45 : Result := '"string" expected';
  46 : Result := '";" expected';
  47 : Result := '"if" expected';
  48 : Result := '"else" expected';
  49 : Result := '"while" expected';
  50 : Result := '"for" expected';
  51 : Result := '"break" expected';
  52 : Result := '"continue" expected';
  53 : Result := '"return" expected';
  54 : Result := '"+=" expected';
  55 : Result := '"-=" expected';
  56 : Result := '"*=" expected';
  57 : Result := '"/=" expected';
  58 : Result := '"||" expected';
  59 : Result := '"&&" expected';
  60 : Result := '"|" expected';
  61 : Result := '"^" expected';
  62 : Result := '"&" expected';
  63 : Result := '"!=" expected';
  64 : Result := '"==" expected';
  65 : Result := '"<" expected';
  66 : Result := '">" expected';
  67 : Result := '"<=" expected';
  68 : Result := '">=" expected';
  69 : Result := '"<<" expected';
  70 : Result := '">>" expected';
  71 : Result := '"+" expected';
  72 : Result := '"-" expected';
  73 : Result := '"*" expected';
  74 : Result := '"/" expected';
  75 : Result := '"++" expected';
  76 : Result := '"--" expected';
  77 : Result := '"!" expected';
  78 : Result := '"." expected';
  79 : Result := '"[" expected';
  80 : Result := '"]" expected';
  81 : Result := 'not expected';
  82 : Result := 'invalid Literal';
  83 : Result := 'invalid Primary';
  84 : Result := 'invalid AssignOp';
  85 : Result := 'invalid ForInit';
  86 : Result := 'invalid StatementExpr';
  87 : Result := 'invalid EmbeddedStatement';
  88 : Result := 'invalid SimpleType';
  89 : Result := 'invalid Expr';
  90 : Result := 'invalid Statement';

200 : Result := 'Not a floating point value';
    201 : Result := 'Name already defined in this scope';
    202 : Result := 'Return value expected';
    203 : Result := 'Function should not return a value';
    204 : Result := 'Only function definitions are allowed here';
    205 : Result := 'Syntax not supported';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TZc.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TZc.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TZc.GetScanner : TZcScanner;
begin
  Result := Scanner AS TZcScanner;
end; {GetScanner}

function TZc._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TZc._Literal (var  Typ  :  TZcDataType);begin
if (fCurrentInputSymbol = intConSym) then begin
Get;
Typ  :=zctInt;
end else if (fCurrentInputSymbol = realConSym) then begin
Get;
Typ  :=  zctFloat;
end else if (fCurrentInputSymbol = stringConSym) then begin
Get;
Typ  :=  zctString;
end else begin SynError(82);
end;
end;

procedure TZc._Primary (var  OutOp  :  TZcOp);var  Op  :  TZcOp;  S  :  string;  V  :  single;
   Typ  :  TZcDataType;

begin
OutOp  :=  nil;
if (fCurrentInputSymbol = identSym) then begin
Get;
OutOp  :=  MakeOp(zcIdentifier,LexString);
end else if (fCurrentInputSymbol = intConSym) OR
 (fCurrentInputSymbol = realConSym) OR
 (fCurrentInputSymbol = stringConSym) then begin
_Literal(Typ);

if  Typ=zctString  then
OutOp  :=  TZcOpLiteral.Create(Typ,LexString)
else
begin
try
S  :=  LexString;
V  :=  ZcStrToFloat(S);
OutOp  :=  TZcOpLiteral.Create(Typ,V)
except  on  EConvertError  do
SynError(200);
end;
end;

end else if (fCurrentInputSymbol = _lparenSym) then begin
Get;
_Expr(OutOp);
Expect(_rparenSym);
end else begin SynError(83);
end;
while (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) OR
 (fCurrentInputSymbol = _pointSym) OR
 (fCurrentInputSymbol = _lbrackSym) do begin
if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
OutOp  :=  MakePrePostIncDec(zcPostInc,OutOp);
end else if (fCurrentInputSymbol = _minus_minusSym) then begin
Get;
OutOp  :=  MakePrePostIncDec(zcPostDec,OutOp);
end else if (fCurrentInputSymbol = _pointSym) then begin
Get;
Expect(identSym);

Assert(OutOp.Kind=zcIdentifier);
OutOp.Id  :=  OutOp.Id  +  '.'  +  LexString;

end else if (fCurrentInputSymbol = _lparenSym) then begin
Get;
Assert(OutOp.Kind=zcIdentifier);
OutOp.Kind:=zcFuncCall;

if _In(symSet[1], fCurrentInputSymbol) then begin
_Argument(Op);
OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Argument(Op);
OutOp.Children.Add(Op);
end;
end;

if  not  VerifyFunctionCall(OutOp,S)  then
   ZError(S);

Expect(_rparenSym);
end else begin
Get;
Assert(OutOp.Kind=zcIdentifier);
OutOp.Kind:=zcArrayAccess;

_Expr(Op);
OutOp.Children.Add(  MakeCompatible(Op,zctInt)  );
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Expr(Op);
OutOp.Children.Add(  MakeCompatible(Op,zctInt)  );
end;
Expect(_rbrackSym);
end;
end;
end;

procedure TZc._MulExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Tmp  :  TZcOp;  Kind  :  TZcOpKind;
begin
OutOp  :=  InOp;
while (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _slashSym) do begin
if (fCurrentInputSymbol = _starSym) then begin
Get;
Kind  :=  zcMul;
end else begin
Get;
Kind  :=  zcDiv;
end;
_Unary(Tmp);
OutOp  :=  MakeBinary(Kind,InOp,Tmp);
InOp  :=  OutOp;

end;
end;

procedure TZc._AddExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;   Kind  :  TZcOpKind;
begin
_MulExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
Kind  :=  zcPlus;
end else begin
Get;
Kind  :=  zcMinus;
end;
_Unary(Op);
_MulExpr(Op,R);

if  (L=nil)  or  (R=nil)  then
   ZError('Invalid  syntax');
OutOp  :=  MakeBinary(Kind,L,R);
L  :=  OutOp;

end;
end;

procedure TZc._ShiftExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;  Kind  :  TZcOpKind;
begin
_AddExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _less_lessSym) OR
 (fCurrentInputSymbol = _greater_greaterSym) do begin
if (fCurrentInputSymbol = _less_lessSym) then begin
Get;
Kind  :=  zcBinaryShiftL;
end else begin
Get;
Kind  :=  zcBinaryShiftR;
end;
_Unary(Op);
_AddExpr(Op,R);
OutOp  :=  MakeOp(Kind,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._RelExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;   Kind  :  TZcOpKind;
begin
_ShiftExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _less_equalSym) OR
 (fCurrentInputSymbol = _greater_equalSym) do begin
if (fCurrentInputSymbol = _lessSym) then begin
Get;
Kind  :=  zcCompLT;
end else if (fCurrentInputSymbol = _greaterSym) then begin
Get;
Kind  :=  zcCompGT;
end else if (fCurrentInputSymbol = _less_equalSym) then begin
Get;
Kind  :=  zcCompLE;
end else begin
Get;
Kind  :=  zcCompGE;
end;
_Unary(Op);
_ShiftExpr(Op,R);
OutOp  :=  MakeBinary(Kind,  L,R  );
L  :=  OutOp;

end;
end;

procedure TZc._EqlExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;  Kind  :  TZcOpKind;
begin
_RelExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _bang_equalSym) OR
 (fCurrentInputSymbol = _equal_equalSym) do begin
if (fCurrentInputSymbol = _bang_equalSym) then begin
Get;
Kind  :=  zcCompNE;
end else begin
Get;
Kind  :=  zcCompEQ;
end;
_Unary(Op);
_RelExpr(Op,R);
OutOp  :=  MakeBinary(Kind,  L,R);
L  :=  OutOp;

end;
end;

procedure TZc._BitAndExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_EqlExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _andSym) do begin
Get;
_Unary(Op);
_EqlExpr(Op,R);
OutOp  :=  MakeOp(zcBinaryAnd,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._BitXorExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
_BitAndExpr(InOp,OutOp);
while (fCurrentInputSymbol = _uparrowSym) do begin
Get;
SynError(205);
_Unary(Op);
_BitAndExpr(InOp,OutOp);
end;
end;

procedure TZc._BitOrExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_BitXorExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _barSym) do begin
Get;
_Unary(Op);
_BitXorExpr(Op,R);
OutOp  :=  MakeOp(zcBinaryOr,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._AndExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_BitOrExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _and_andSym) do begin
Get;
_Unary(Op);
_BitOrExpr(Op,R);
OutOp  :=  MakeOp(zcAnd,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._OrExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_AndExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _bar_barSym) do begin
Get;
_Unary(Op);
_AndExpr(Op,R);
OutOp  :=  MakeOp(zcOr,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._AssignOp (var  Kind  :  TZcAssignType);begin
if (fCurrentInputSymbol = _equalSym) then begin
Get;
Kind  :=  atAssign;
end else if (fCurrentInputSymbol = _plus_equalSym) then begin
Get;
Kind  :=  atPlusAssign;
end else if (fCurrentInputSymbol = _minus_equalSym) then begin
Get;
Kind  :=  atMinusAssign;
end else if (fCurrentInputSymbol = _star_equalSym) then begin
Get;
Kind  :=  atMulAssign;
end else if (fCurrentInputSymbol = _slash_equalSym) then begin
Get;
Kind  :=  atDivAssign;
end else begin SynError(84);
end;
end;

procedure TZc._Unary (var  OutOp  :  TZcOp);var  LastOp,Tmp  :  TZcOp;  Kind  :  TZcOpKind;
begin
LastOp  :=  nil;  Kind  :=  zcNop;
while (fCurrentInputSymbol = _minusSym) OR
 (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) OR
 (fCurrentInputSymbol = _bangSym) do begin
if (fCurrentInputSymbol = _minusSym) then begin
Get;
Kind  :=  zcNegate;
end else if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
Kind  :=  zcPreInc;
end else if (fCurrentInputSymbol = _minus_minusSym) then begin
Get;
Kind  :=  zcPreDec;
end else begin
Get;
Kind  :=  zcNot;
end;

if  Kind  in  [zcNegate,zcNot]  then
begin
   Tmp  :=  MakeOp(Kind);
   if  LastOp<>nil  then
     LastOp.Children.Add(Tmp);
   LastOp  :=  Tmp;
end  else  if  Assigned(LastOp)  then
   ZError('--  and  ++  cannot  be  combined  with  other  unary  ops');

end;
_Primary(Tmp);

if  Kind  in  [zcNop,zcNegate,zcNot]  then
begin
   if  LastOp<>nil  then
   begin
     LastOp.Children.Add(Tmp);
     OutOp  :=  LastOp;
   end  else
     OutOp  :=  Tmp;
end  else
begin
   OutOp  :=  MakePrePostIncDec(Kind,Tmp);
end;

end;

procedure TZc._ForInc (var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
Op:=nil;
OutOp  :=  MakeOp(zcBlock);

_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Op:=nil;
Get;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
end;

procedure TZc._ForInit (var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
Op:=nil;  OutOp  :=  MakeOp(zcBlock);
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) then begin
_LocalVarDecl(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end else if _In(symSet[1], fCurrentInputSymbol) then begin
Op:=nil;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Op:=nil;
Get;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
end else begin SynError(85);
end;
end;

procedure TZc._StatementExpr (var  OutOp  :  TZcOp);var  Op1,Op2  :  TZcOp;  Kind  :  TZcAssignType;
begin
Op1  :=nil;  Op2  :=  nil;
_Unary(Op1);
if (fCurrentInputSymbol = _equalSym) OR
 (fCurrentInputSymbol = _plus_equalSym) OR
 (fCurrentInputSymbol = _minus_equalSym) OR
 (fCurrentInputSymbol = _star_equalSym) OR
 (fCurrentInputSymbol = _slash_equalSym) then begin
_AssignOp(Kind);
_Expr(Op2);

if  Op2<>nil  then
   OutOp  :=  MakeAssign(Kind,Op1,Op2);

end else if (fCurrentInputSymbol = _rparenSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _semicolonSym) then begin
OutOp  :=  Op1;
end else begin SynError(86);
end;
end;

procedure TZc._Block (var  OutOp  :  TZcOp);var
   Op  :  TZcOp;

begin
Op  :=  nil;
OutOp  :=  MakeOp(zcBlock);

Expect(_lbraceSym);
while _In(symSet[2], fCurrentInputSymbol) do begin
_Statement(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
Expect(_rbraceSym);
end;

procedure TZc._EmbeddedStatement (var  OutOp  :  TZcOp);var
   Op,IfOp,IfBody,ElseOp  :  TZcOp;
   ForInitOp,ForCondOp,ForIncOp,ForBodyOp  :  TZcOp;
   WhileCondOp,WhileBodyOp  :  TZcOp;

begin
case fCurrentInputSymbol of
  _lbraceSym : begin
_Block(OutOp);
    end;
  _semicolonSym : begin
Get;
OutOp  :=  MakeOp(zcNop);
    end;
  intConSym, realConSym, stringConSym, identSym, _lparenSym, _minusSym, _plus_plusSym, 
      _minus_minusSym, _bangSym : begin
_StatementExpr(OutOp);
Expect(_semicolonSym);
    end;
  ifSym : begin
Get;
ElseOp  :=  nil;
Expect(_lparenSym);
_Expr(IfOp);
Expect(_rparenSym);
_EmbeddedStatement(IfBody);
if (fCurrentInputSymbol = elseSym) then begin
Get;
_EmbeddedStatement(ElseOp);
end;
OutOp  :=  MakeOp(zcIf,[IfOp,IfBody,ElseOp]);
    end;
  whileSym : begin
Get;
try
  SymTab.PushScope;
  WhileCondOp  :=  nil;  WhileBodyOp  :=  nil;
Expect(_lparenSym);
_Expr(WhileCondOp);
Expect(_rparenSym);
_EmbeddedStatement(WhileBodyOp);

     OutOp  :=  MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
   finally
     SymTab.PopScope;
   end;

    end;
  forSym : begin
Get;
try
   SymTab.PushScope;
   ForInitOp  :=nil;  ForCondOp  :=  nil;  ForIncOp  :=  nil;
Expect(_lparenSym);
if _In(symSet[3], fCurrentInputSymbol) then begin
_ForInit(ForInitOp);
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expr(ForCondOp);
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_ForInc(ForIncOp);
end;
Expect(_rparenSym);
_EmbeddedStatement(ForBodyOp);

     OutOp  :=  MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
   finally
     SymTab.PopScope;
   end;

    end;
  breakSym : begin
Get;
Expect(_semicolonSym);
OutOp  :=  MakeOp(zcBreak);
    end;
  continueSym : begin
Get;
Expect(_semicolonSym);
OutOp  :=  MakeOp(zcContinue);
    end;
  returnSym : begin
Op  :=  nil;
Get;
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expr(Op);
end;
Expect(_semicolonSym);

   if  (Op=nil)  then
   begin
     if  CurrentFunction.ReturnType<>zctVoid  then
       SynError(202)
     else
       OutOp  :=  MakeOp(zcReturn);
   end  else
   begin
     if  CurrentFunction.ReturnType=zctVoid  then
       SynError(203)
     else
       OutOp  :=  MakeOp(zcReturn,[  MakeCompatible(Op,CurrentFunction.ReturnType)  ]);
   end;

    end;
else begin SynError(87);
    end;
end;
end;

procedure TZc._SimpleType (var  Typ  :  TZcDataType);begin
if (fCurrentInputSymbol = floatSym) then begin
Get;
Typ  :=  zctFloat;
end else if (fCurrentInputSymbol = intSym) then begin
Get;
Typ  :=  zctInt;
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
Typ  :=  zctString;
end else begin SynError(88);
end;
end;

procedure TZc._Argument (var  OutOp  :  TZcOp);begin
_Expr(OutOp);
end;

procedure TZc._Expr (var  OutOp  :  TZcOp);var  Op1,Op2  :  TZcOp;  Kind  :  TZcAssignType;
begin
_Unary(Op1);
if _In(symSet[4], fCurrentInputSymbol) then begin
_OrExpr(Op1,OutOp);
end else if (fCurrentInputSymbol = _equalSym) OR
 (fCurrentInputSymbol = _plus_equalSym) OR
 (fCurrentInputSymbol = _minus_equalSym) OR
 (fCurrentInputSymbol = _star_equalSym) OR
 (fCurrentInputSymbol = _slash_equalSym) then begin
_AssignOp(Kind);
_Expr(Op2);
OutOp  :=  MakeAssign(Kind,Op1,Op2);
end else begin SynError(89);
end;
end;

procedure TZc._Init (var  OutOp  :  TZcOp);begin
_Expr(OutOp);
end;

procedure TZc._LocalVar (Typ  :  TZcDataType;  var  OutOp  :  TZcOp);var  Loc  :  TZcOpLocalVar;  InitOp  :  TZcOp;
begin
Expect(identSym);

if  SymTab.ScopeContains(LexString)  then
   ZError('Name  already  defined:  '  +  LexString);

Loc  :=  TZcOpLocalVar.Create(nil);
Loc.Id  :=  LexString;
Loc.Typ  :=  Typ;

if (fCurrentInputSymbol = _equalSym) then begin
Get;
_Init(InitOp);
Loc.InitExpression:=InitOp;
end;

SymTab.Add(Loc.Id,Loc);
CurrentFunction.AddLocal(Loc);

if  Assigned(Loc.InitExpression)  then
begin
   //Generate  tree  for  initial  assignment
   if  OutOp=nil  then
     OutOp  :=  MakeOp(zcBlock);
   OutOp.Children.Add(  MakeAssign(atAssign,  MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression)  );
end;


end;

procedure TZc._LocalVarDecl (var  OutOp  :  TZcOp);var  Typ  :  TZcDataType;
begin
OutOp  :=  nil;
_Type(Typ);
_LocalVar(Typ,OutOp);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_LocalVar(Typ,OutOp);
end;
end;

procedure TZc._Par;var  Typ  :  TZcDataType;  Arg  :  TZcOpArgumentVar;
begin
_Type(Typ);
Expect(identSym);

  if  SymTab.ScopeContains(LexString)  then
    SynError(201)
  else
  begin
    Arg  :=  TZcOpArgumentVar.Create(GlobalNames);
    Arg.Id  :=  LexString;
    Arg.Typ  :=  Typ;
    CurrentFunction.AddArgument(Arg);
    SymTab.Add(Arg.Id,Arg);
  end;

end;

procedure TZc._Statement (var  OutOp  :  TZcOp);begin
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) then begin
OutOp  :=  nil;
_LocalVarDecl(OutOp);
Expect(_semicolonSym);
end else if _In(symSet[5], fCurrentInputSymbol) then begin
_EmbeddedStatement(OutOp);
end else begin SynError(90);
end;
end;

procedure TZc._ZcFuncBody;var  Op  :  TZcOp;
begin
while _In(symSet[2], fCurrentInputSymbol) do begin
Op:=nil;
_Statement(Op);
if  Op<>nil  then
   CurrentFunction.Statements.Add(Op);
Op  :=  nil;

end;
end;

procedure TZc._FormalParams;begin
_Par;
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_FormalParams;
end;
end;

procedure TZc._Type (var  Typ  :  TZcDataType);begin
_SimpleType(Typ);
end;

procedure TZc._Zc;var
   I  :  integer;
   Func  :  TZcOpFunctionUserDefined;
   Typ  :  TZcDataType;

begin
if AllowFunctions then begin
while (fCurrentInputSymbol = voidSym) OR
 (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) do begin
if (fCurrentInputSymbol = voidSym) then begin
Get;
Typ  :=  zctVoid;
end else begin
_Type(Typ);
end;
Expect(identSym);

if  SymTab.Contains(LexString)  then
ZError('Name  already  defined:  '  +  LexString);

Func  :=  TZcOpFunctionUserDefined.Create(GlobalNames);
Func.Id  :=  LexString;
Func.ReturnType  :=  Typ;
SymTab.Add(Func.Id,Func);
ZFunctions.Add(Func);
Self.CurrentFunction  :=  Func;
SymTab.PushScope;
try

Expect(_lparenSym);
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) then begin
_FormalParams;
end;
Expect(_rparenSym);
Expect(_lbraceSym);
_ZcFuncBody;
Expect(_rbraceSym);

finally
SymTab.PopScope;
end;

end;
end
else begin

   Func  :=  TZcOpFunctionUserDefined.Create(nil);
   Func.ReturnType  :=  Self.ReturnType;
   Self.CurrentFunction  :=  Func;
   SymTab.PushScope;
   try
   ZFunctions.Add(Func);

_ZcFuncBody;

   finally
   SymTab.PopScope;
   end;

end;

    if  Successful  then
    begin
      for  I:=0  to  ZFunctions.Count-1  do
        ZFunctions[I]  :=  TZcOp(ZFunctions[I]).Optimize;
    end;

end;

function TZc.GetBuildDate : TDateTime;
const
  BDate = 38846;
  Hour = 16;
  Min = 41;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TZc.GetVersion : string;
begin
  Result := '1.0.0.116';
end;

function TZc.GetVersionStr : string;
begin
  Result := '1.0.0.116';
end;

function TZc.GetVersionInfo : string;
begin
  Result := 'Comment: Zc' + #13#10 +
'Author: Ville Krumlinde' + #13#10 +
'Copyright: ';
end;

procedure TZc.SetVersion(const Value : string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TZc.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_Zc;
end;  {Parse}

procedure TZc.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 0, 4] := [];
symSet[ 0, 5] := [];
symSet[ 1, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 1, 1] := [];
symSet[ 1, 2] := [_lparenSym-32];
symSet[ 1, 3] := [];
symSet[ 1, 4] := [_minusSym-64, _plus_plusSym-64, _minus_minusSym-64, 
                    _bangSym-64];
symSet[ 1, 5] := [];
symSet[ 2, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 2, 1] := [];
symSet[ 2, 2] := [_lparenSym-32, _lbraceSym-32, floatSym-32, intSym-32, 
                    stringSym-32, _semicolonSym-32, ifSym-32];
symSet[ 2, 3] := [whileSym-48, forSym-48, breakSym-48, continueSym-48, 
                    returnSym-48];
symSet[ 2, 4] := [_minusSym-64, _plus_plusSym-64, _minus_minusSym-64, 
                    _bangSym-64];
symSet[ 2, 5] := [];
symSet[ 3, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 3, 1] := [];
symSet[ 3, 2] := [_lparenSym-32, floatSym-32, intSym-32, stringSym-32];
symSet[ 3, 3] := [];
symSet[ 3, 4] := [_minusSym-64, _plus_plusSym-64, _minus_minusSym-64, 
                    _bangSym-64];
symSet[ 3, 5] := [];
symSet[ 4, 0] := [];
symSet[ 4, 1] := [];
symSet[ 4, 2] := [_rparenSym-32, _commaSym-32, _semicolonSym-32];
symSet[ 4, 3] := [_bar_barSym-48, _and_andSym-48, _barSym-48, _uparrowSym-48, 
                    _andSym-48, _bang_equalSym-48];
symSet[ 4, 4] := [_equal_equalSym-64, _lessSym-64, _greaterSym-64, 
                    _less_equalSym-64, _greater_equalSym-64, _less_lessSym-64, 
                    _greater_greaterSym-64, _plusSym-64, _minusSym-64, 
                    _starSym-64, _slashSym-64];
symSet[ 4, 5] := [_rbrackSym-80];
symSet[ 5, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 5, 1] := [];
symSet[ 5, 2] := [_lparenSym-32, _lbraceSym-32, _semicolonSym-32, ifSym-32];
symSet[ 5, 3] := [whileSym-48, forSym-48, breakSym-48, continueSym-48, 
                    returnSym-48];
symSet[ 5, 4] := [_minusSym-64, _plus_plusSym-64, _minus_minusSym-64, 
                    _bangSym-64];
symSet[ 5, 5] := [];
end; {InitSymSet}

end { Zc }.    
