

Compiled: den 26 januari 2010 - 18:51:20
Output sent to: C:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 26 januari 2010 @ 18:51:20

Statistics:
  number of terminals:        78 (limit  2561)
  number of non-terminals:    31 (limit  1281)
  number of pragmas:           0 (limit  2483)
  number of symbolnodes:     109 (limit  2561)
  number of graphnodes:      322 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    23 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;    
   16    PRIVATE
   17      CurrentFunction : TZcOpFunctionUserDefined;
   18      procedure CleanUp;
   19      function NoFunctionsAllowed : boolean;
   20      procedure ZError(const S : string);
   21    CREATE
   22      ZFunctions := TObjectList.Create(False);
   23    DESTROY
   24      CleanUp;
   25    ERRORS
   26      200 : Result := 'Not a floating point value';
   27      201 : Result := 'Name already defined in this scope';
   28      202 : Result := 'Return value expected';
   29      203 : Result := 'Function should not return a value';
   30      204 : Result := 'Only function definitions are allowed here';
   31  END_DELPHI
   32  
   33  (* Arbitrary Code *)
   34  
   35  
   36  
   37  
   38  procedure T-->Grammar<--.CleanUp;
   39  begin
   40    Zc_Ops.FunctionCleanUps.Clear;
   41    ZFunctions.Free;
   42  end;
   43  
   44  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   45  begin
   46    Result := not AllowFunctions;
   47  end;
   48  
   49  procedure T-->Grammar<--.ZError(const S : string);
   50  var
   51    E : EParseError;
   52  begin
   53    E := EParseError.Create(S);
   54    E.Message := S;
   55    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   56    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   57    raise E;
   58  end;
   59  
   60  
   61  CHARACTERS
   62  
   63          tab                = CHR(9). /*  9 = tabulator */
   64          eol                = CHR(10). /* 10 = line feed */
   65          cr                 = CHR(13). /* 13 = carriage return */
   66          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   67  
   68          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   69          digit              = "0123456789".
   70          hexDigit           = digit + "ABCDEFabcdef".
   71          notDigit           = ANY - digit.
   72  
   73          char               = ANY - "'" - '\' - newLine.
   74          verbatimStringChar = ANY - '"'.
   75          regularStringChar  = ANY - '"' - '\' - newLine.
   76          notNewLine         = ANY - newLine .
   77  
   78  
   79  TOKENS
   80  
   81    /*--------------------------------------------------------------------------------*/
   82          intCon =
   83                  ( digit {digit}
   84                  (* | ("0x" | "0X") hexDigit {hexDigit} *)
   85                  )
   86                  (* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] *)
   87                  .
   88    /*--------------------------------------------------------------------------------*/
   89          realCon =
   90                  "." digit {digit}
   91                  [("e" | "E") ["+" | "-"] digit {digit}]
   92                  ["F" | "f" | "D" | "d" | "M" | "m"]
   93          | digit {digit}
   94                  ( "." digit {digit}
   95                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
   96                          ["F" | "f" | "D" | "d" | "M" | "m"]
   97                  | ("e" | "E") ["+" | "-"] digit {digit}
   98                          ["F" | "f" | "D" | "d" | "M" | "m"]
   99                  | "F" | "f" | "D" | "d" | "M" | "m"
  100                  ).
  101    /*--------------------------------------------------------------------------------*/
  102          stringCon =
  103                  '"'    { regularStringChar
  104  					| "\'" | '\"' | "\\" | "\n"
  105  					}
  106                  '"'.
  107  
  108          ident = ['@'] letter { letter | digit }.
  109  
  110  
  111          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  112          and    = "&".
  113          assgn  = "=".
  114          colon  = ":".
  115          comma  = ",".
  116          dec    = "--".
  117          div    = "/".
  118          dot    = ".".
  119          eq     = "==".
  120          gt     = ">".
  121          gte    = ">=".
  122          inc    = "++".
  123          lbrace = "{".
  124          lbrack = "[".
  125          lpar   = "(".
  126          lshift = "<<".
  127          lt     = "<".
  128          lte    = "<=".
  129          minus  = "-".
  130          mod    = "%".
  131          neq    = "!=".
  132          not    = "!".
  133          or     = "|".
  134          plus   = "+".
  135          rbrace = "}".
  136          rbrack = "]".
  137          rpar   = ")".
  138          rshift = ">>".
  139          scolon = ";".
  140          tilde  = "~".
  141          times  = "*".
  142          xor    = "^".
  143  
  144  
  145  
  146  COMMENTS FROM "/*" TO "*/"
  147  COMMENTS FROM "//" TO eol
  148  
  149  IGNORE eol + cr + tab
  150  
  151  PRODUCTIONS
  152  
  153  /*------------------------------------------------------------------------*
  154   *--------------------------- Declarations -------------------------------*
  155   *------------------------------------------------------------------------*/
  156  
  157  Zc (. var 
  158          I : integer; 
  159          Func : TZcOpFunctionUserDefined; 
  160          Typ : TZcDataType;
  161      .)
  162  = 
  163  
  164    IF AllowFunctions THEN 
  165    BEGIN { 
  166      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  167            if SymTab.Contains(LexString) then
  168              ZError('Name already defined: ' + LexString);
  169              
  170            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  171            Func.Id := LexString;
  172            Func.ReturnType := Typ;
  173            SymTab.Add(Func.Id,Func);
  174            ZFunctions.Add(Func); 
  175            Self.CurrentFunction := Func;
  176            SymTab.PushScope;
  177            try
  178         .)
  179      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  180          (. 
  181            finally
  182            SymTab.PopScope;
  183            end;
  184          .)
  185      } 
  186    END ELSE
  187    BEGIN
  188  
  189  
  190    (. 
  191         Func := TZcOpFunctionUserDefined.Create(nil);
  192         Func.ReturnType := Self.ReturnType;
  193         Self.CurrentFunction := Func;
  194         SymTab.PushScope;
  195         try
  196         ZFunctions.Add(Func);
  197    .)
  198  
  199    /* A zc-expression is treated like the body of a nameless function
  200       to allow local var declarations  */
  201  
  202    ZcFuncBody
  203  
  204    (. 
  205         finally
  206         SymTab.PopScope;
  207         end;
  208    .)
  209    END
  210  
  211  (.  
  212         if Successful then
  213         begin
  214           for I:=0 to ZFunctions.Count-1 do
  215             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  216         end;
  217  .)
  218  .
  219  
  220  /*------------------------------------------------------------------------*/
  221  
  222  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  223  =  {  (. Op:=nil; .)
  224        Statement<Op>
  225        (. if Op<>nil then
  226             CurrentFunction.Statements.Add(Op);
  227           Op := nil;
  228        .)
  229     }
  230  .
  231  
  232  /*------------------------------------------------------------------------*/
  233  FormalParams                    
  234  = ( Par ["," FormalParams] )
  235  .
  236  /*------------------------------------------------------------------------*/
  237  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  238  = Type<Typ> ident
  239       (.
  240          if SymTab.ScopeContains(LexString) then
  241            SynError(201)
  242          else
  243          begin
  244            Arg := TZcOpArgumentVar.Create(GlobalNames);
  245            Arg.Id := LexString;
  246            Arg.Typ := Typ;
  247            CurrentFunction.AddArgument(Arg);
  248            SymTab.Add(Arg.Id,Arg);
  249          end;
  250       .)
  251  .
  252  /*------------------------------------------------------------------------*/
  253  
  254  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  255  = (. OutOp := nil; .)
  256    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  257  .
  258  
  259  /*------------------------------------------------------------------------*/
  260  
  261  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  262  = ident  
  263       (. 
  264          if SymTab.ScopeContains(LexString) then
  265            ZError('Name already defined: ' + LexString);
  266  
  267          Loc := TZcOpLocalVar.Create(nil);
  268          Loc.Id := LexString;
  269          Loc.Typ := Typ;        
  270       .)
  271       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  272       (. 
  273          SymTab.Add(Loc.Id,Loc);
  274          CurrentFunction.AddLocal(Loc);
  275  
  276          if Assigned(Loc.InitExpression) then
  277          begin
  278            //Generate tree for initial assignment
  279            if OutOp=nil then
  280              OutOp := MakeOp(zcBlock);
  281            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  282          end;
  283          
  284       .)
  285  .
  286  
  287  /*------------------------------------------------------------------------*/
  288  
  289  Init<var OutOp : TZcOp>
  290  = Expr<OutOp>
  291  .
  292  
  293  /*------------------------------------------------------------------------*/
  294  Argument<var OutOp : TZcOp>
  295  = /* ["ref" | "out"] */
  296    Expr<OutOp>
  297  .
  298  
  299  /*------------------------------------------------------------------------*
  300   *-------------------------------- Types ---------------------------------*
  301   *------------------------------------------------------------------------*/
  302  
  303  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  304   * and for array creation expressions                                     */
  305  
  306  
  307  Type<var Typ : TZcDataType>
  308  = ( SimpleType<Typ> )
  309  .
  310  
  311  /*------------------------------------------------------------------------*/
  312  
  313  SimpleType<var Typ : TZcDataType>
  314  /* = IntType | "float" | "double" | "decimal" | "bool" */
  315  = "float" (. Typ := zctFloat; .) |
  316    "int" (. Typ := zctInt; .) |
  317    "string" (. Typ := zctString; .)
  318  .
  319  
  320  /*------------------------------------------------------------------------*/
  321  
  322  /* IntType
  323  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  324  . */
  325  
  326  
  327  /*------------------------------------------------------------------------*
  328   *------------------------------ Statements ------------------------------*
  329   *------------------------------------------------------------------------*/
  330  
  331  Statement<var OutOp : TZcOp>
  332  = (. OutOp := nil; .)
  333  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  334  (*IF IsLocalVarDecl THEN 
  335  BEGIN
  336    LocalVarDecl ";"
  337  END
  338  |  EmbeddedStatement<OutOp> *)
  339  
  340  LocalVarDecl<OutOp> ";"
  341  | EmbeddedStatement<OutOp>
  342    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  343     * ident {"." ident} { "[" ...                           */
  344  .
  345  
  346  /*------------------------------------------------------------------------*/
  347  EmbeddedStatement<var OutOp : TZcOp>
  348    (. var
  349         Op,IfOp,IfBody,ElseOp : TZcOp;
  350         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  351    .)
  352  = Block<OutOp>
  353  | ";"   (. OutOp := MakeOp(zcNop); .)
  354  | StatementExpr<OutOp> ";"
  355  | "if" (. ElseOp := nil; .)
  356    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  357          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  358  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  359  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  360  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  361   | "for" 
  362      (. try
  363         SymTab.PushScope; 
  364         ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  365     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp> 
  366     (.
  367         OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  368         finally
  369         SymTab.PopScope;
  370         end;
  371     .)
  372  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  373  /* | "break" ";" */
  374  /* | "continue" ";" */
  375   | (. Op := nil; .) "return" [ Expr<Op> ] ";"   
  376      (. 
  377          if (Op=nil) then
  378          begin
  379            if CurrentFunction.ReturnType<>zctVoid then
  380              SynError(202)
  381            else
  382              OutOp := MakeOp(zcReturn);
  383          end else
  384          begin
  385            if CurrentFunction.ReturnType=zctVoid then
  386              SynError(203)
  387            else
  388              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  389          end;
  390      .)
  391  .
  392  /*------------------------------------------------------------------------*/
  393  
  394  Block<var OutOp : TZcOp>
  395    (. var
  396         Op : TZcOp;
  397    .)
  398  = (. Op := nil;
  399       OutOp := MakeOp(zcBlock); 
  400    .)
  401    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  402  
  403  /*------------------------------------------------------------------------*/
  404  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  405  = (. Op1 :=nil; Op2 := nil; .)
  406    Unary<Op1>
  407    ( AssignOp<Kind> Expr<Op2>
  408      (.
  409        if Op2<>nil then
  410          OutOp := MakeAssign(Kind,Op1,Op2);
  411      .)
  412    |                             (. OutOp := Op1; .)
  413    )
  414  .
  415  
  416  /*------------------------------------------------------------------------*/
  417  AssignOp<var Kind : TZcAssignType>
  418  = "="     (. Kind := atAssign; .)
  419    | "+="  (. Kind := atPlusAssign; .)
  420    | "-="  (. Kind := atMinusAssign; .)
  421    | "*="  (. Kind := atMulAssign; .)
  422    | "/="  (. Kind := atDivAssign; .)
  423  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  424  .
  425  
  426  /*------------------------------------------------------------------------*/
  427  
  428  /* SwitchSection   (. var Op : TZcOp; .)
  429  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  430  .  */
  431  
  432  /*------------------------------------------------------------------------*/
  433  
  434  /* SwitchLabel     (. var Op : TZcOp; .)
  435  = "case" Expr<Op> ":"
  436  | "default" ":"
  437  .  */
  438  
  439  /*------------------------------------------------------------------------*/
  440  
  441  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  442  = (. Op:=nil; OutOp := MakeOp(zcBlock); .) 
  443  (
  444  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  445  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  446    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  447  )
  448  .  
  449  
  450  /*------------------------------------------------------------------------*/
  451  
  452  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  453  = (. Op:=nil; 
  454       OutOp := MakeOp(zcBlock);
  455    .) 
  456  (
  457  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  458  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  459  )
  460  . 
  461  
  462  
  463  /*------------------------------------------------------------------------*
  464   *----------------------------- Expressions ------------------------------*
  465   *------------------------------------------------------------------------*/
  466  
  467  
  468  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  469  = Unary<Op1>
  470    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  471    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  472    )
  473  .
  474  /*------------------------------------------------------------------------*/
  475  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  476  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  477      {"||" Unary<Op> AndExpr<Op,R>
  478        (. OutOp := MakeOp(zcOr,[L,R]);
  479           L := OutOp; .)
  480      }
  481  .
  482  
  483  
  484  /*------------------------------------------------------------------------*/
  485  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  486  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  487      {"&&" Unary<Op> BitOrExpr<Op,R>
  488        (. OutOp := MakeOp(zcAnd,[L,R]);
  489           L := OutOp; .)
  490      }
  491  .
  492  /*------------------------------------------------------------------------*/
  493  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  494  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  495  .
  496  /*------------------------------------------------------------------------*/
  497  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  498  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  499  .
  500  /*------------------------------------------------------------------------*/
  501  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  502  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  503  .
  504  /*------------------------------------------------------------------------*/
  505  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  506  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  507    {( "!="   (. Kind := zcCompNE; .)
  508     | "=="   (. Kind := zcCompEQ; .)
  509     )
  510     Unary<Op> RelExpr<Op,R>
  511           (. OutOp := MakeBinary(Kind, L,R);
  512              L := OutOp;
  513           .)
  514    }
  515  .
  516  /*------------------------------------------------------------------------*/
  517  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  518  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  519    { ( "<"       (. Kind := zcCompLT; .)
  520      | ">"       (. Kind := zcCompGT; .)
  521      | "<="      (. Kind := zcCompLE; .)
  522      | ">="      (. Kind := zcCompGE; .)
  523       )
  524      Unary<Op> ShiftExpr<Op,R>
  525           (. OutOp := MakeBinary(Kind, L,R );
  526              L := OutOp;
  527           .)
  528    }
  529  .
  530  /*------------------------------------------------------------------------*/
  531  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  532  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  533  .
  534  /*------------------------------------------------------------------------*/
  535  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  536  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  537      {( "+"    (. Kind := zcPlus; .)
  538       | "-"    (. Kind := zcMinus; .)
  539       ) Unary<Op> MulExpr<Op,R>
  540           (. 
  541              if (L=nil) or (R=nil) then
  542                ZError('Invalid syntax');
  543              OutOp := MakeBinary(Kind,L,R);
  544              L := OutOp;
  545           .)
  546      }
  547  .
  548  /*------------------------------------------------------------------------*/
  549  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  550  =       (. OutOp := InOp; .)
  551    { ("*"      (. Kind := zcMul; .)
  552      | "/"     (. Kind := zcDiv; .)
  553    (*  | "%" *)
  554      ) Unary<Tmp>
  555           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  556              InOp := OutOp;
  557           .)
  558      }
  559  .
  560  /*------------------------------------------------------------------------*/
  561  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  562  =       (. LastOp := nil; Kind := zcNop; .)
  563    {
  564      (
  565        (* "+" | *)
  566        "-"   (. Kind := zcNegate; .) |
  567        "++"  (. Kind := zcPreInc; .) |    
  568        "--"  (. Kind := zcPreDec; .)
  569        (* | "!" | "~" | "*" |  *)
  570      )   
  571      (. 
  572         if Kind=zcNegate then
  573         begin
  574           Tmp := MakeOp(Kind);
  575           if LastOp<>nil then
  576             LastOp.Children.Add(Tmp);
  577           LastOp := Tmp;
  578         end else if Assigned(LastOp) then 
  579           ZError('-- and ++ cannot be combined with other unary ops');
  580      .)
  581    }
  582    Primary<Tmp>
  583      (. 
  584         if Kind in [zcNop,zcNegate] then
  585         begin
  586           if LastOp<>nil then
  587           begin
  588             LastOp.Children.Add(Tmp);
  589             OutOp := LastOp;
  590           end else
  591             OutOp := Tmp;
  592         end else 
  593         begin
  594           OutOp := MakePrePostIncDec(Kind,Tmp);
  595         end;
  596      .)
  597  .
  598  /*------------------------------------------------------------------------*/
  599  Primary<var OutOp : TZcOp>         
  600  (. var Op : TZcOp; S : string; V : single; 
  601       Typ : TZcDataType;
  602  .)
  603  =            (. OutOp := nil; .)
  604    ( 
  605      ident    (. OutOp := MakeOp(zcIdentifier,LexString);  .)
  606    | Literal<Typ>  (. 
  607          if Typ=zctString then
  608            OutOp := TZcOpLiteral.Create(Typ,LexString)
  609          else
  610          begin
  611            try
  612              S := LexString;
  613              if S[ Length(S) ] in ['F','f'] then
  614                S := Copy(S,1,Length(S)-1);
  615              V := StrToFloat(S);
  616              OutOp := TZcOpLiteral.Create(Typ,V)
  617            except on EConvertError do
  618              SynError(200);
  619            end;
  620          end;
  621       .)
  622    | "(" Expr<OutOp> ")"
  623  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  624      | "float"  | "int"    | "long" | "object"  | "sbyte"
  625      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  626      ) "." ident *)
  627    )
  628  
  629    {
  630    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .) |
  631    "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .) |
  632  /*  | "->" ident
  633    | */
  634    "." ident (.
  635        Assert(OutOp.Kind=zcIdentifier);
  636        OutOp.Id := OutOp.Id + '.' + LexString;
  637      .)
  638    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  639             OutOp.Kind:=zcFuncCall;
  640           .)
  641          [Argument<Op> (. OutOp.Children.Add(Op); .)
  642            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  643            }
  644          ]
  645          (. 
  646             if not VerifyFunctionCall(OutOp,S) then
  647               ZError(S);
  648          .)
  649      ")"
  650  
  651    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  652             OutOp.Kind:=zcArrayAccess;
  653           .)
  654      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) 
  655        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) } 
  656      "]" 
  657  
  658    }
  659  .
  660  /*------------------------------------------------------------------------*/
  661  Literal<var Typ : TZcDataType>
  662  = intCon (. Typ :=zctInt; .) | 
  663    realCon (. Typ := zctFloat; .) |
  664    stringCon (. Typ := zctString; .)
  665    (* | "true" | "false" | "null" *)
  666  .
  667  
  668  END Zc.

    1 LL(1) error
   11 warnings

