

Compiled: den 24 januari 2007 - 18:46:50
Output sent to: D:\DATA\Delphi32\ZzDC\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     Zc
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 24 januari 2007 @ 18:46:50

Statistics:
  number of terminals:        72 (limit  2561)
  number of non-terminals:    21 (limit  1281)
  number of pragmas:           0 (limit  2489)
  number of symbolnodes:      93 (limit  2561)
  number of graphnodes:      203 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    24 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4  (*  USES INTERFACE SysUtils *)
    5    USES (INTERFACE) contnrs
    6  
    7    TYPE
    8  
    9    TZcAssignType = (atAssign,atMulAssign,atDivAssign,atPlusAssign,atMinusAssign);
   10    TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus,zcConst,zcIdentifier,zcAssign,zcIf,
   11            zcCompLT,zcCompGT,zcCompLE,zcCompGE,zcCompNE,zcCompEQ,
   12            zcBlock,zcNegate,zcOr,zcAnd,zcFuncCall,zcReturn);
   13  
   14    TZcOp = class
   15    public
   16      Kind : TZcOpKind;
   17      Value : single;
   18      Id : string;
   19      Children : TObjectList;
   20      constructor Create;
   21      destructor Destroy; override;
   22      function ToString : string;
   23      function Child(I : integer) : TZcOp;
   24      procedure Optimize;
   25    end;
   26  
   27    PUBLIC
   28      ZStatements : TObjectList;
   29    PRIVATE
   30      procedure WriteStr(S : string);
   31      procedure WriteOp(Op : TZcOp);
   32      procedure AddGlobalStatement(Op : TZcOp);
   33      procedure CleanUp;
   34    CREATE
   35      ZStatements := TObjectList.Create(False);
   36      //Alla nodes ägs av globalcleanups
   37      GlobalCleanUps := TObjectList.Create;
   38    DESTROY
   39      CleanUp;
   40    ERRORS
   41      200 : Result := 'Not a floating point value';
   42  END_DELPHI
   43  
   44  (* Arbitrary Code *)
   45  
   46  var
   47    GlobalCleanUps : TObjectList;
   48  
   49  function MakeOp(Kind : TZcOpKind) : TZcOp; overload;
   50  begin
   51    Result := TZcOp.Create;
   52    Result.Kind := Kind;
   53  end;
   54  function MakeOp(Kind : TZcOpKind; Value : single) : TZcOp; overload;
   55  begin
   56    Result := MakeOp(Kind);
   57    Result.Value := Value;
   58  end;
   59  function MakeOp(Kind : TZcOpKind; Id :string) : TZcOp; overload;
   60  begin
   61    Result := MakeOp(Kind);
   62    Result.Id := Id;
   63  end;
   64  function MakeOp(Kind : TZcOpKind; const Children : array of TZcOp) : TZcOp; overload;
   65  var
   66    I : integer;
   67  begin
   68    Result := MakeOp(Kind);
   69    for I := 0 to High(Children) do
   70      Result.Children.Add(Children[I]);
   71  end;
   72  
   73  function MakeAssign(Kind : TZcAssignType; Op1,Op2 : TZcOp) : TZcOp;
   74  const
   75    AssignMap : array[TZcAssignType] of TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus);
   76  var
   77    Tmp : TZcOp;
   78  begin
   79    case Kind of
   80      atMulAssign,atDivAssign,atPlusAssign,atMinusAssign :  //Convert x*=2 to x=x*2
   81        begin
   82          Tmp := MakeOp(zcIdentifier,Op1.Id);
   83          Op2 := MakeOp(AssignMap[Kind],[Tmp,Op2]);
   84        end;
   85    end;
   86    Result := MakeOp(zcAssign,[Op1,Op2]);
   87  end;
   88  
   89  constructor TZcOp.Create;
   90  begin
   91    Children := TObjectList.Create(False);
   92    GlobalCleanUps.Add(Self);
   93  end;
   94  
   95  destructor TZcOp.Destroy;
   96  //var
   97  //  I : integer;
   98  begin
   99  //  for I := 0 to Children.Count-1 do
  100  //    if Assigned(Children[I]) then Child(I).Free;
  101    FreeAndNil(Children);
  102  end;
  103  
  104  function TZcOp.Child(I : integer) : TZcOp;
  105  begin
  106    Result := TZcOp(Children[I]);
  107  end;
  108  
  109  function TZcOp.ToString : string;
  110  var
  111    I : integer;
  112  begin
  113    case Kind of
  114      zcMul : Result := Child(0).ToString + '*' + Child(1).ToString;
  115      zcDiv : Result := Child(0).ToString + '/' + Child(1).ToString;
  116      zcPlus : Result := Child(0).ToString + '+' + Child(1).ToString;
  117      zcMinus : Result := Child(0).ToString + '-' + Child(1).ToString;
  118      zcConst : Result := FloatToStr(Value);
  119      zcIdentifier : Result := Id;
  120      zcAssign : Result := Child(0).ToString + '=' + Child(1).ToString;
  121      zcIf :
  122        begin
  123          Result := 'if(' + Child(0).ToString + ') ' + Child(1).ToString;
  124          if Assigned(Child(2)) then
  125            Result := Result + ' else ' + Child(2).ToString;
  126        end;
  127      zcCompLT : Result := Child(0).ToString + '<' + Child(1).ToString;
  128      zcCompGT : Result := Child(0).ToString + '>' + Child(1).ToString;
  129      zcCompLE : Result := Child(0).ToString + '<=' + Child(1).ToString;
  130      zcCompGE : Result := Child(0).ToString + '>=' + Child(1).ToString;
  131      zcCompNE : Result := Child(0).ToString + '!=' + Child(1).ToString;
  132      zcCompEQ : Result := Child(0).ToString + '==' + Child(1).ToString;
  133      zcBlock :
  134        begin
  135          Result := '{'#13#10;
  136          for I := 0 to Children.Count-1 do
  137            Result := Result + Child(I).ToString + '; ';
  138          Result := Result + '}'#13#10;
  139        end;
  140      zcNegate : Result := '-' + Child(0).ToString;
  141      zcOr : Result := Child(0).ToString + ' || ' + Child(1).ToString;
  142      zcAnd : Result := Child(0).ToString + ' && ' + Child(1).ToString;
  143      zcFuncCall :
  144        begin
  145          Result := Id + '(';
  146          for I := 0 to Children.Count-1 do
  147          begin
  148            if I>0 then
  149              Result := Result + ',';
  150            Result := Result + Child(I).ToString;
  151          end;
  152          Result := Result + ')';
  153        end;
  154      zcNop : Result := ';';       //Empty statement
  155      zcReturn : Result := 'return ' + Child(0).ToString + ';';
  156    end;
  157  end;
  158  
  159  procedure TZcOp.Optimize;
  160  var
  161    I : integer;
  162  
  163    procedure DoConstant(NewValue : single);
  164    begin
  165      if (Child(0).Kind=zcConst) and (Child(1).Kind=zcConst) then
  166      begin
  167        Kind := zcConst;
  168        Value := NewValue;
  169      end;
  170    end;
  171  
  172  begin
  173    for I := 0 to Children.Count-1 do
  174      if Assigned(Child(I)) then Child(I).Optimize;
  175    case Kind of
  176      //todo: more optimizations
  177      zcMul : DoConstant(Child(0).Value * Child(1).Value);
  178      zcDiv : DoConstant(Child(0).Value / Child(1).Value);
  179      zcPlus : DoConstant(Child(0).Value + Child(1).Value);
  180      zcMinus : DoConstant(Child(0).Value - Child(1).Value);
  181      zcNegate :
  182        if Child(0).Kind=zcConst then
  183        begin
  184          Kind := zcConst;
  185          Value := Child(0).Value * -1;
  186        end;
  187    end;
  188  end;
  189  
  190  procedure T-->Grammar<--.WriteStr(S : string);
  191  begin
  192    StreamToListFile(S, TRUE);
  193  end;
  194  
  195  procedure T-->Grammar<--.WriteOp(Op : TZcOp);
  196  begin
  197    WriteStr(Op.ToString);
  198  end;
  199  
  200  procedure T-->Grammar<--.AddGlobalStatement(Op : TZcOp);
  201  begin
  202    ZStatements.Add(Op);
  203  end;
  204  
  205  procedure T-->Grammar<--.CleanUp;
  206  //var
  207  //  I : integer;
  208  begin
  209  //  for I := 0 to ZSTatements.Count-1 do TObject(ZStatements[I]).Free;
  210    ZStatements.Free;
  211    GlobalCleanUps.Free;
  212  end;
  213  
  214  CHARACTERS
  215  
  216          tab                = CHR(9). /*  9 = tabulator */
  217          eol                = CHR(10). /* 10 = line feed */
  218          cr                 = CHR(13). /* 13 = carriage return */
  219          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  220  
  221          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  222          digit              = "0123456789".
  223          hexDigit           = digit + "ABCDEFabcdef".
  224          notDigit           = ANY - digit.
  225  
  226          char               = ANY - "'" - '\\' - newLine.
  227          verbatimStringChar = ANY - '"'.
  228          regularStringChar  = ANY - '"' - '\\' - newLine.
  229          notNewLine         = ANY - newLine .
  230  
  231  
  232  TOKENS
  233  
  234    /*--------------------------------------------------------------------------------*/
  235          intCon =
  236                  ( digit {digit}
  237                  | ("0x" | "0X") hexDigit {hexDigit}
  238                  )
  239                  ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  240    /*--------------------------------------------------------------------------------*/
  241          realCon =
  242                  "." digit {digit}
  243                  [("e" | "E") ["+" | "-"] digit {digit}]
  244                  ["F" | "f" | "D" | "d" | "M" | "m"]
  245          | digit {digit}
  246                  ( "." digit {digit}
  247                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  248                          ["F" | "f" | "D" | "d" | "M" | "m"]
  249                  | ("e" | "E") ["+" | "-"] digit {digit}
  250                          ["F" | "f" | "D" | "d" | "M" | "m"]
  251                  | "F" | "f" | "D" | "d" | "M" | "m"
  252                  ).
  253    /*--------------------------------------------------------------------------------*/
  254          stringCon =
  255                  '"'    { regularStringChar }
  256                  '"'.
  257  
  258          ident = ['@'] letter { letter | digit }.
  259  
  260  
  261          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  262          and    = "&".
  263          assgn  = "=".
  264          colon  = ":".
  265          comma  = ",".
  266          dec    = "--".
  267          div    = "/".
  268          dot    = ".".
  269          eq     = "==".
  270          gt     = ">".
  271          gte    = ">=".
  272          inc    = "++".
  273          lbrace = "{".
  274          lbrack = "[".
  275          lpar   = "(".
  276          lshift = "<<".
  277          lt     = "<".
  278          lte    = "<=".
  279          minus  = "-".
  280          mod    = "%".
  281          neq    = "!=".
  282          not    = "!".
  283          or     = "|".
  284          plus   = "+".
  285          rbrace = "}".
  286          rbrack = "]".
  287          rpar   = ")".
  288          rshift = ">>".
  289          scolon = ";".
  290          tilde  = "~".
  291          times  = "*".
  292          xor    = "^".
  293  
  294  
  295  
  296  COMMENTS FROM "/*" TO "*/"
  297  COMMENTS FROM "//" TO eol
  298  
  299  IGNORE eol + cr + tab
  300  
  301  PRODUCTIONS
  302  
  303  /*------------------------------------------------------------------------*
  304   *--------------------------- Declarations -------------------------------*
  305   *------------------------------------------------------------------------*/
  306  
  307  Zc      (. var Op : TZcOp; I : integer; .)
*****  ^ Zc is a deletable symbol
  308  = (. Op := nil; .)
  309    {EmbeddedStatement<Op>
  310        (. if Op<>nil then
  311             AddGlobalStatement(Op);
  312           Op := nil;
  313        .)
  314     }
  315  
  316    (. if Successful then
  317       begin
  318         for I:=0 to ZStatements.Count-1 do
  319         begin
  320           TZcOp(ZStatements[I]).Optimize;
  321           WriteOp(TZcOp(ZStatements[I]));
  322         end;
  323       end;
  324    .)
  325  .
  326  
  327  
  328  /*------------------------------------------------------------------------*/
  329  
  330  /* LocalVarDecl
  331  = Type LocalVar {"," LocalVar}
  332  . */
  333  
  334  /*------------------------------------------------------------------------*/
  335  
  336  /* LocalVar       (. var Op : TZcOp; .)
  337  = ident [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ]
  338  . */
  339  
  340  /*------------------------------------------------------------------------*/
  341  
  342  /* Init           (. var Op : TZcOp; .)
  343  = Expr<Op>
  344  .  */
  345  
  346  /*------------------------------------------------------------------------*/
  347  Argument<var OutOp : TZcOp>
  348  = /* ["ref" | "out"] */
  349    Expr<OutOp>
  350  .
  351  
  352  /*------------------------------------------------------------------------*
  353   *-------------------------------- Types ---------------------------------*
  354   *------------------------------------------------------------------------*/
  355  
  356  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  357   * and for array creation expressions                                     */
  358  
  359  /*
  360  Type
  361  = ( SimpleType )
  362  . */
  363  
  364  /*------------------------------------------------------------------------*/
  365  
  366  /* SimpleType
  367  = IntType | "float" | "double" | "decimal" | "bool"
  368  .  */
  369  
  370  /*------------------------------------------------------------------------*/
  371  
  372  /* IntType
  373  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  374  . */
  375  
  376  
  377  /*------------------------------------------------------------------------*
  378   *------------------------------ Statements ------------------------------*
  379   *------------------------------------------------------------------------*/
  380  
  381  Statement<var OutOp : TZcOp>
  382  =
  383  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  384  /* | LocalVarDecl ";"
  385   | */
  386   EmbeddedStatement<OutOp>
  387    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  388     * ident {"." ident} { "[" ...                           */
  389  .
  390  /*------------------------------------------------------------------------*/
  391  EmbeddedStatement<var OutOp : TZcOp>
  392    (. var
  393         Op,IfOp,IfBody,ElseOp : TZcOp;
  394    .)
  395  =
  396    Block<OutOp>
  397  | ";"   (. OutOp := MakeOp(zcNop); .)
  398  | StatementExpr<OutOp> ";"
  399  | "if" (. ElseOp := nil; .)
  400    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  401          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  402  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  403  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  404  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  405  /* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
  406  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  407  /* | "break" ";" */
  408  /* | "continue" ";" */
  409   | "return" Expr<Op> ";"   (. OutOp := MakeOp(zcReturn,[Op]); {return måste har ett expr} .)
  410  .
  411  /*------------------------------------------------------------------------*/
  412  
  413  Block<var OutOp : TZcOp>
  414    (. var
  415         Op : TZcOp;
  416    .)
  417  = (. OutOp := MakeOp(zcBlock); .)
  418    "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".
  419  
  420  /*------------------------------------------------------------------------*/
  421  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  422  =
  423    Unary<Op1>
  424    ( AssignOp<Kind> Expr<Op2>
  425      (.
  426        OutOp := MakeAssign(Kind,Op1,Op2);
  427      .)
  428    |                             (. OutOp := Op1; .)
  429    )
  430  .
  431  
  432  /*------------------------------------------------------------------------*/
  433  AssignOp<var Kind : TZcAssignType>
  434  = "="     (. Kind := atAssign; .)
  435    | "+="  (. Kind := atPlusAssign; .)
  436    | "-="  (. Kind := atMinusAssign; .)
  437    | "*="  (. Kind := atMulAssign; .)
  438    | "/="  (. Kind := atDivAssign; .)
  439  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  440  .
  441  
  442  /*------------------------------------------------------------------------*/
  443  
  444  /* SwitchSection   (. var Op : TZcOp; .)
  445  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  446  .  */
  447  
  448  /*------------------------------------------------------------------------*/
  449  
  450  /* SwitchLabel     (. var Op : TZcOp; .)
  451  = "case" Expr<Op> ":"
  452  | "default" ":"
  453  .  */
  454  
  455  /*------------------------------------------------------------------------*/
  456  
  457  /* ForInit     (. var Op : TZcOp; .)
  458  = LocalVarDecl
  459  | StatementExpr<Op> { "," StatementExpr<Op> }
  460  .  */
  461  
  462  /*------------------------------------------------------------------------*/
  463  
  464  /* ForInc      (. var Op : TZcOp; .)
  465  = StatementExpr<Op> { "," StatementExpr<Op> }
  466  .  */
  467  
  468  
  469  /*------------------------------------------------------------------------*
  470   *----------------------------- Expressions ------------------------------*
  471   *------------------------------------------------------------------------*/
  472  
  473  
  474  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  475  = Unary<Op1>
  476    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  477    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  478    )
  479  .
  480  /*------------------------------------------------------------------------*/
  481  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  482  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  483      {"||" Unary<Op> AndExpr<Op,R>
  484        (. OutOp := MakeOp(zcOr,[L,R]);
  485           L := OutOp; .)
  486      }
  487  .
  488  
  489  
  490  /*------------------------------------------------------------------------*/
  491  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  492  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  493      {"&&" Unary<Op> BitOrExpr<Op,R>
  494        (. OutOp := MakeOp(zcAnd,[L,R]);
  495           L := OutOp; .)
  496      }
  497  .
  498  /*------------------------------------------------------------------------*/
  499  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  500  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  501  .
  502  /*------------------------------------------------------------------------*/
  503  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  504  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  505  .
  506  /*------------------------------------------------------------------------*/
  507  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  508  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  509  .
  510  /*------------------------------------------------------------------------*/
  511  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  512  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  513    {( "!="   (. Kind := zcCompNE; .)
  514     | "=="   (. Kind := zcCompEQ; .)
  515     )
  516     Unary<Op> RelExpr<Op,R>
  517           (. OutOp := MakeOp(Kind,[L,R]);
  518              L := OutOp;
  519           .)
  520    }
  521  .
  522  /*------------------------------------------------------------------------*/
  523  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  524  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  525    { ( "<"       (. Kind := zcCompLT; .)
  526      | ">"       (. Kind := zcCompGT; .)
  527      | "<="      (. Kind := zcCompLE; .)
  528      | ">="      (. Kind := zcCompGE; .)
  529       )
  530      Unary<Op> ShiftExpr<Op,R>
  531           (. OutOp := MakeOp(Kind,[L,R]);
  532              L := OutOp;
  533           .)
  534    }
  535  .
  536  /*------------------------------------------------------------------------*/
  537  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  538  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  539  .
  540  /*------------------------------------------------------------------------*/
  541  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  542  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  543      {( "+"    (. Kind := zcPlus; .)
  544       | "-"    (. Kind := zcMinus; .)
  545       ) Unary<Op> MulExpr<Op,R>
  546           (. OutOp := MakeOp(Kind,[L,R]);
  547              L := OutOp;
  548           .)
  549      }
  550  .
  551  /*------------------------------------------------------------------------*/
  552  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  553  =       (. OutOp := InOp; .)
  554    { ("*"      (. Kind := zcMul; .)
  555      | "/"     (. Kind := zcDiv; .)
  556    (*  | "%" *)
  557      ) Unary<Tmp>
  558           (. OutOp := MakeOp(Kind,[InOp,Tmp]);
  559              InOp := OutOp;
  560           .)
  561      }
  562  .
  563  /*------------------------------------------------------------------------*/
  564  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  565  =       (. LastOp := nil; .)
  566    {
  567      (
  568        (* "+" | *)
  569        "-"       (. Kind := zcNegate; .)
  570        (* | "!" | "~" | "*" | "++" | "--" *)
  571      )   (. Tmp := MakeOp(Kind);
  572             if LastOp<>nil then
  573               LastOp.Children.Add(Tmp);
  574             LastOp := Tmp;
  575          .)
  576    }
  577    Primary<Tmp>
  578      (. if LastOp<>nil then
  579         begin
  580           LastOp.Children.Add(Tmp);
  581           OutOp := LastOp;
  582         end else
  583           OutOp := Tmp;
  584      .)
  585  .
  586  /*------------------------------------------------------------------------*/
  587  Primary<var OutOp : TZcOp>         (. var Op : TZcOp; .)
  588  =            (. OutOp := nil; .)
  589    ( ident    (. OutOp := MakeOp(zcIdentifier,LexString); .)
  590    | Literal  (. 
  591          try
  592            OutOp := MakeOp(zcConst,StrToFloat(LexString)); 
  593          except on EConvertError do
  594            SynError(200);
  595          end;
  596       .)
  597    | "(" Expr<OutOp> ")"
  598  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  599      | "float"  | "int"    | "long" | "object"  | "sbyte"
  600      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  601      ) "." ident *)
  602    )
  603  
  604    {
  605  /*  "++" | "--" | "->" ident
  606    | */
  607    "." ident (.
  608        Assert(OutOp.Kind=zcIdentifier);
  609        OutOp.Id := OutOp.Id + '.' + LexString;
  610      .)
  611    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  612             OutOp.Kind:=zcFuncCall;
  613           .)
  614          [Argument<Op> (. OutOp.Children.Add(Op); .)
  615            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  616            }
  617          ]
  618      ")"
  619    }
  620  .
  621  /*------------------------------------------------------------------------*/
  622  Literal
  623  = intCon | realCon | stringCon | "true" | "false" | "null"
  624  .
  625  
  626  END Zc.

    1 LL(1) error
   11 warnings

