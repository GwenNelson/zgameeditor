

Compiled: den 15 januari 2010 - 16:47:10
Output sent to: C:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 15 januari 2010 @ 16:47:10

Statistics:
  number of terminals:        78 (limit  2561)
  number of non-terminals:    31 (limit  1281)
  number of pragmas:           0 (limit  2483)
  number of symbolnodes:     109 (limit  2561)
  number of graphnodes:      322 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    20 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;    
   16    PRIVATE
   17      CurrentFunction : TZcOpFunctionUserDefined;
   18      procedure CleanUp;
   19      function NoFunctionsAllowed : boolean;
   20      procedure ZError(const S : string);
   21    CREATE
   22      ZFunctions := TObjectList.Create(False);
   23    DESTROY
   24      CleanUp;
   25    ERRORS
   26      200 : Result := 'Not a floating point value';
   27      201 : Result := 'Name already defined in this scope';
   28      202 : Result := 'Return value expected';
   29      203 : Result := 'Function should not return a value';
   30      204 : Result := 'Only function definitions are allowed here';
   31  END_DELPHI
   32  
   33  (* Arbitrary Code *)
   34  
   35  
   36  
   37  
   38  procedure T-->Grammar<--.CleanUp;
   39  begin
   40    Zc_Ops.FunctionCleanUps.Clear;
   41    ZFunctions.Free;
   42  end;
   43  
   44  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   45  begin
   46    Result := not AllowFunctions;
   47  end;
   48  
   49  procedure T-->Grammar<--.ZError(const S : string);
   50  var
   51    E : EParseError;
   52  begin
   53    E := EParseError.Create(S);
   54    E.Message := S;
   55    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   56    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   57    raise E;
   58  end;
   59  
   60  
   61  CHARACTERS
   62  
   63          tab                = CHR(9). /*  9 = tabulator */
   64          eol                = CHR(10). /* 10 = line feed */
   65          cr                 = CHR(13). /* 13 = carriage return */
   66          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   67  
   68          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   69          digit              = "0123456789".
   70          hexDigit           = digit + "ABCDEFabcdef".
   71          notDigit           = ANY - digit.
   72  
   73          char               = ANY - "'" - '\\' - newLine.
   74          verbatimStringChar = ANY - '"'.
   75          regularStringChar  = ANY - '"' - '\\' - newLine.
   76          notNewLine         = ANY - newLine .
   77  
   78  
   79  TOKENS
   80  
   81    /*--------------------------------------------------------------------------------*/
   82          intCon =
   83                  ( digit {digit}
   84                  (* | ("0x" | "0X") hexDigit {hexDigit} *)
   85                  )
   86                  (* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] *)
   87                  . 
   88    /*--------------------------------------------------------------------------------*/
   89          realCon =
   90                  "." digit {digit}
   91                  [("e" | "E") ["+" | "-"] digit {digit}]
   92                  ["F" | "f" | "D" | "d" | "M" | "m"]
   93          | digit {digit}
   94                  ( "." digit {digit}
   95                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
   96                          ["F" | "f" | "D" | "d" | "M" | "m"]
   97                  | ("e" | "E") ["+" | "-"] digit {digit}
   98                          ["F" | "f" | "D" | "d" | "M" | "m"]
   99                  | "F" | "f" | "D" | "d" | "M" | "m"
  100                  ).
  101    /*--------------------------------------------------------------------------------*/
  102          stringCon =
  103                  '"'    { regularStringChar }
  104                  '"'.
  105  
  106          ident = ['@'] letter { letter | digit }.
  107  
  108  
  109          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  110          and    = "&".
  111          assgn  = "=".
  112          colon  = ":".
  113          comma  = ",".
  114          dec    = "--".
  115          div    = "/".
  116          dot    = ".".
  117          eq     = "==".
  118          gt     = ">".
  119          gte    = ">=".
  120          inc    = "++".
  121          lbrace = "{".
  122          lbrack = "[".
  123          lpar   = "(".
  124          lshift = "<<".
  125          lt     = "<".
  126          lte    = "<=".
  127          minus  = "-".
  128          mod    = "%".
  129          neq    = "!=".
  130          not    = "!".
  131          or     = "|".
  132          plus   = "+".
  133          rbrace = "}".
  134          rbrack = "]".
  135          rpar   = ")".
  136          rshift = ">>".
  137          scolon = ";".
  138          tilde  = "~".
  139          times  = "*".
  140          xor    = "^".
  141  
  142  
  143  
  144  COMMENTS FROM "/*" TO "*/"
  145  COMMENTS FROM "//" TO eol
  146  
  147  IGNORE eol + cr + tab
  148  
  149  PRODUCTIONS
  150  
  151  /*------------------------------------------------------------------------*
  152   *--------------------------- Declarations -------------------------------*
  153   *------------------------------------------------------------------------*/
  154  
  155  Zc (. var 
  156          I : integer; 
  157          Func : TZcOpFunctionUserDefined; 
  158          Typ : TZcDataType;
  159      .)
  160  = 
  161  
  162    IF AllowFunctions THEN 
  163    BEGIN { 
  164      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  165            if SymTab.Contains(LexString) then
  166              ZError('Name already defined: ' + LexString);
  167              
  168            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  169            Func.Id := LexString;
  170            Func.ReturnType := Typ;
  171            SymTab.Add(Func.Id,Func);
  172            ZFunctions.Add(Func); 
  173            Self.CurrentFunction := Func;
  174            SymTab.PushScope;
  175            try
  176         .)
  177      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  178          (. 
  179            finally
  180            SymTab.PopScope;
  181            end;
  182          .)
  183      } 
  184    END ELSE
  185    BEGIN
  186  
  187  
  188    (. 
  189         Func := TZcOpFunctionUserDefined.Create(nil);
  190         Func.ReturnType := Self.ReturnType;
  191         Self.CurrentFunction := Func;
  192         SymTab.PushScope;
  193         try
  194         ZFunctions.Add(Func);
  195    .)
  196  
  197    /* A zc-expression is treated like the body of a nameless function
  198       to allow local var declarations  */
  199  
  200    ZcFuncBody
  201  
  202    (. 
  203         finally
  204         SymTab.PopScope;
  205         end;
  206    .)
  207    END
  208  
  209  (.  
  210         if Successful then
  211         begin
  212           for I:=0 to ZFunctions.Count-1 do
  213             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  214         end;
  215  .)
  216  .
  217  
  218  /*------------------------------------------------------------------------*/
  219  
  220  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  221  =  {  (. Op:=nil; .)
  222        Statement<Op>
  223        (. if Op<>nil then
  224             CurrentFunction.Statements.Add(Op);
  225           Op := nil;
  226        .)
  227     }
  228  .
  229  
  230  /*------------------------------------------------------------------------*/
  231  FormalParams                    
  232  = ( Par ["," FormalParams] )
  233  .
  234  /*------------------------------------------------------------------------*/
  235  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  236  = Type<Typ> ident
  237       (.
  238          if SymTab.ScopeContains(LexString) then
  239            SynError(201)
  240          else
  241          begin
  242            Arg := TZcOpArgumentVar.Create(GlobalNames);
  243            Arg.Id := LexString;
  244            Arg.Typ := Typ;
  245            CurrentFunction.AddArgument(Arg);
  246            SymTab.Add(Arg.Id,Arg);
  247          end;
  248       .)
  249  .
  250  /*------------------------------------------------------------------------*/
  251  
  252  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  253  = (. OutOp := nil; .)
  254    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  255  .
  256  
  257  /*------------------------------------------------------------------------*/
  258  
  259  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  260  = ident  
  261       (. 
  262          if SymTab.ScopeContains(LexString) then
  263            ZError('Name already defined: ' + LexString);
  264  
  265          Loc := TZcOpLocalVar.Create(nil);
  266          Loc.Id := LexString;
  267          Loc.Typ := Typ;        
  268       .)
  269       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  270       (. 
  271          SymTab.Add(Loc.Id,Loc);
  272          CurrentFunction.AddLocal(Loc);
  273  
  274          if Assigned(Loc.InitExpression) then
  275          begin
  276            //Generate tree for initial assignment
  277            if OutOp=nil then
  278              OutOp := MakeOp(zcBlock);
  279            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  280          end;
  281          
  282       .)
  283  .
  284  
  285  /*------------------------------------------------------------------------*/
  286  
  287  Init<var OutOp : TZcOp>
  288  = Expr<OutOp>
  289  .
  290  
  291  /*------------------------------------------------------------------------*/
  292  Argument<var OutOp : TZcOp>
  293  = /* ["ref" | "out"] */
  294    Expr<OutOp>
  295  .
  296  
  297  /*------------------------------------------------------------------------*
  298   *-------------------------------- Types ---------------------------------*
  299   *------------------------------------------------------------------------*/
  300  
  301  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  302   * and for array creation expressions                                     */
  303  
  304  
  305  Type<var Typ : TZcDataType>
  306  = ( SimpleType<Typ> )
  307  .
  308  
  309  /*------------------------------------------------------------------------*/
  310  
  311  SimpleType<var Typ : TZcDataType>
  312  /* = IntType | "float" | "double" | "decimal" | "bool" */
  313  = "float" (. Typ := zctFloat; .) |
  314    "int" (. Typ := zctInt; .) |
  315    "string" (. Typ := zctString; .)
  316  .
  317  
  318  /*------------------------------------------------------------------------*/
  319  
  320  /* IntType
  321  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  322  . */
  323  
  324  
  325  /*------------------------------------------------------------------------*
  326   *------------------------------ Statements ------------------------------*
  327   *------------------------------------------------------------------------*/
  328  
  329  Statement<var OutOp : TZcOp>
  330  = (. OutOp := nil; .)
  331  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  332  (*IF IsLocalVarDecl THEN 
  333  BEGIN
  334    LocalVarDecl ";"
  335  END
  336  |  EmbeddedStatement<OutOp> *)
  337  
  338  LocalVarDecl<OutOp> ";"
  339  | EmbeddedStatement<OutOp>
  340    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  341     * ident {"." ident} { "[" ...                           */
  342  .
  343  
  344  /*------------------------------------------------------------------------*/
  345  EmbeddedStatement<var OutOp : TZcOp>
  346    (. var
  347         Op,IfOp,IfBody,ElseOp : TZcOp;
  348         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  349    .)
  350  = Block<OutOp>
  351  | ";"   (. OutOp := MakeOp(zcNop); .)
  352  | StatementExpr<OutOp> ";"
  353  | "if" (. ElseOp := nil; .)
  354    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  355          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  356  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  357  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  358  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  359   | "for" 
  360      (. try
  361         SymTab.PushScope; 
  362         ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  363     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp> 
  364     (.
  365         OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  366         finally
  367         SymTab.PopScope;
  368         end;
  369     .)
  370  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  371  /* | "break" ";" */
  372  /* | "continue" ";" */
  373   | (. Op := nil; .) "return" [ Expr<Op> ] ";"   
  374      (. 
  375          if (Op=nil) then
  376          begin
  377            if CurrentFunction.ReturnType<>zctVoid then
  378              SynError(202)
  379            else
  380              OutOp := MakeOp(zcReturn);
  381          end else
  382          begin
  383            if CurrentFunction.ReturnType=zctVoid then
  384              SynError(203)
  385            else
  386              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  387          end;
  388      .)
  389  .
  390  /*------------------------------------------------------------------------*/
  391  
  392  Block<var OutOp : TZcOp>
  393    (. var
  394         Op : TZcOp;
  395    .)
  396  = (. Op := nil;
  397       OutOp := MakeOp(zcBlock); 
  398    .)
  399    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  400  
  401  /*------------------------------------------------------------------------*/
  402  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  403  = (. Op1 :=nil; Op2 := nil; .)
  404    Unary<Op1>
  405    ( AssignOp<Kind> Expr<Op2>
  406      (.
  407        if Op2<>nil then
  408          OutOp := MakeAssign(Kind,Op1,Op2);
  409      .)
  410    |                             (. OutOp := Op1; .)
  411    )
  412  .
  413  
  414  /*------------------------------------------------------------------------*/
  415  AssignOp<var Kind : TZcAssignType>
  416  = "="     (. Kind := atAssign; .)
  417    | "+="  (. Kind := atPlusAssign; .)
  418    | "-="  (. Kind := atMinusAssign; .)
  419    | "*="  (. Kind := atMulAssign; .)
  420    | "/="  (. Kind := atDivAssign; .)
  421  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  422  .
  423  
  424  /*------------------------------------------------------------------------*/
  425  
  426  /* SwitchSection   (. var Op : TZcOp; .)
  427  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  428  .  */
  429  
  430  /*------------------------------------------------------------------------*/
  431  
  432  /* SwitchLabel     (. var Op : TZcOp; .)
  433  = "case" Expr<Op> ":"
  434  | "default" ":"
  435  .  */
  436  
  437  /*------------------------------------------------------------------------*/
  438  
  439  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  440  = (. Op:=nil; OutOp := MakeOp(zcBlock); .) 
  441  (
  442  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  443  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  444    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  445  )
  446  .  
  447  
  448  /*------------------------------------------------------------------------*/
  449  
  450  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  451  = (. Op:=nil; 
  452       OutOp := MakeOp(zcBlock);
  453    .) 
  454  (
  455  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  456  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  457  )
  458  . 
  459  
  460  
  461  /*------------------------------------------------------------------------*
  462   *----------------------------- Expressions ------------------------------*
  463   *------------------------------------------------------------------------*/
  464  
  465  
  466  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  467  = Unary<Op1>
  468    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  469    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  470    )
  471  .
  472  /*------------------------------------------------------------------------*/
  473  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  474  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  475      {"||" Unary<Op> AndExpr<Op,R>
  476        (. OutOp := MakeOp(zcOr,[L,R]);
  477           L := OutOp; .)
  478      }
  479  .
  480  
  481  
  482  /*------------------------------------------------------------------------*/
  483  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  484  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  485      {"&&" Unary<Op> BitOrExpr<Op,R>
  486        (. OutOp := MakeOp(zcAnd,[L,R]);
  487           L := OutOp; .)
  488      }
  489  .
  490  /*------------------------------------------------------------------------*/
  491  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  492  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  493  .
  494  /*------------------------------------------------------------------------*/
  495  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  496  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  497  .
  498  /*------------------------------------------------------------------------*/
  499  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  500  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  501  .
  502  /*------------------------------------------------------------------------*/
  503  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  504  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  505    {( "!="   (. Kind := zcCompNE; .)
  506     | "=="   (. Kind := zcCompEQ; .)
  507     )
  508     Unary<Op> RelExpr<Op,R>
  509           (. OutOp := MakeBinary(Kind, L,R);
  510              L := OutOp;
  511           .)
  512    }
  513  .
  514  /*------------------------------------------------------------------------*/
  515  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  516  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  517    { ( "<"       (. Kind := zcCompLT; .)
  518      | ">"       (. Kind := zcCompGT; .)
  519      | "<="      (. Kind := zcCompLE; .)
  520      | ">="      (. Kind := zcCompGE; .)
  521       )
  522      Unary<Op> ShiftExpr<Op,R>
  523           (. OutOp := MakeBinary(Kind, L,R );
  524              L := OutOp;
  525           .)
  526    }
  527  .
  528  /*------------------------------------------------------------------------*/
  529  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  530  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  531  .
  532  /*------------------------------------------------------------------------*/
  533  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  534  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  535      {( "+"    (. Kind := zcPlus; .)
  536       | "-"    (. Kind := zcMinus; .)
  537       ) Unary<Op> MulExpr<Op,R>
  538           (. 
  539              if (L=nil) or (R=nil) then
  540                ZError('Invalid syntax');
  541              OutOp := MakeBinary(Kind,L,R);
  542              L := OutOp;
  543           .)
  544      }
  545  .
  546  /*------------------------------------------------------------------------*/
  547  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  548  =       (. OutOp := InOp; .)
  549    { ("*"      (. Kind := zcMul; .)
  550      | "/"     (. Kind := zcDiv; .)
  551    (*  | "%" *)
  552      ) Unary<Tmp>
  553           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  554              InOp := OutOp;
  555           .)
  556      }
  557  .
  558  /*------------------------------------------------------------------------*/
  559  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  560  =       (. LastOp := nil; Kind := zcNop; .)
  561    {
  562      (
  563        (* "+" | *)
  564        "-"   (. Kind := zcNegate; .) |
  565        "++"  (. Kind := zcPreInc; .) |    
  566        "--"  (. Kind := zcPreDec; .)
  567        (* | "!" | "~" | "*" |  *)
  568      )   
  569      (. 
  570         if Kind=zcNegate then
  571         begin
  572           Tmp := MakeOp(Kind);
  573           if LastOp<>nil then
  574             LastOp.Children.Add(Tmp);
  575           LastOp := Tmp;
  576         end else if Assigned(LastOp) then 
  577           ZError('-- and ++ cannot be combined with other unary ops');
  578      .)
  579    }
  580    Primary<Tmp>
  581      (. 
  582         if Kind in [zcNop,zcNegate] then
  583         begin
  584           if LastOp<>nil then
  585           begin
  586             LastOp.Children.Add(Tmp);
  587             OutOp := LastOp;
  588           end else
  589             OutOp := Tmp;
  590         end else 
  591         begin
  592           OutOp := MakePrePostIncDec(Kind,Tmp);
  593         end;
  594      .)
  595  .
  596  /*------------------------------------------------------------------------*/
  597  Primary<var OutOp : TZcOp>         
  598  (. var Op : TZcOp; S : string; V : single; 
  599       Typ : TZcDataType;
  600  .)
  601  =            (. OutOp := nil; .)
  602    ( 
  603      ident    (. OutOp := MakeOp(zcIdentifier,LexString);  .)
  604    | Literal<Typ>  (. 
  605    
  606          if Typ=zctString then
  607            OutOp := TZcOpLiteral.Create(Typ,LexString)
  608          else
  609          begin
  610            try
  611              S := LexString;
  612              if S[ Length(S) ] in ['F','f'] then
  613                S := Copy(S,1,Length(S)-1);
  614              V := StrToFloat(S);
  615              OutOp := TZcOpLiteral.Create(Typ,V)
  616            except on EConvertError do
  617              SynError(200);
  618            end;
  619          end;
  620       .)
  621    | "(" Expr<OutOp> ")"
  622  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  623      | "float"  | "int"    | "long" | "object"  | "sbyte"
  624      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  625      ) "." ident *)
  626    )
  627  
  628    {
  629    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .) |
  630    "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .) |
  631  /*  | "->" ident
  632    | */
  633    "." ident (.
  634        Assert(OutOp.Kind=zcIdentifier);
  635        OutOp.Id := OutOp.Id + '.' + LexString;
  636      .)
  637    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  638             OutOp.Kind:=zcFuncCall;
  639           .)
  640          [Argument<Op> (. OutOp.Children.Add(Op); .)
  641            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  642            }
  643          ]
  644          (. 
  645             if not VerifyFunctionCall(OutOp,S) then
  646               ZError(S);
  647          .)
  648      ")"
  649  
  650    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  651             OutOp.Kind:=zcArrayAccess;
  652           .)
  653      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) 
  654        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) } 
  655      "]" 
  656  
  657    }
  658  .
  659  /*------------------------------------------------------------------------*/
  660  Literal<var Typ : TZcDataType>
  661  = intCon (. Typ :=zctInt; .) | 
  662    realCon (. Typ := zctFloat; .) |
  663    stringCon (. Typ := zctString; .)
  664    (* | "true" | "false" | "null" *)
  665  .
  666  
  667  END Zc.

    1 LL(1) error
   11 warnings

