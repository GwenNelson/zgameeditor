

Compiled: den 27 februari 2010 - 13:49:18
Output sent to: C:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 27 februari 2010 @ 13:49:18

Statistics:
  number of terminals:        82 (limit  2561)
  number of non-terminals:    31 (limit  1281)
  number of pragmas:           0 (limit  2479)
  number of symbolnodes:     113 (limit  2561)
  number of graphnodes:      350 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    25 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;
   16    PRIVATE
   17      CurrentFunction : TZcOpFunctionUserDefined;
   18      procedure CleanUp;
   19      function NoFunctionsAllowed : boolean;
   20      procedure ZError(const S : string);
   21    CREATE
   22      ZFunctions := TObjectList.Create(False);
   23    DESTROY
   24      CleanUp;
   25    ERRORS
   26      200 : Result := 'Not a floating point value';
   27      201 : Result := 'Name already defined in this scope';
   28      202 : Result := 'Return value expected';
   29      203 : Result := 'Function should not return a value';
   30      204 : Result := 'Only function definitions are allowed here';
   31      205 : Result := 'Syntax not supported';
   32  END_DELPHI
   33  
   34  (* Arbitrary Code *)
   35  
   36  
   37  
   38  
   39  procedure T-->Grammar<--.CleanUp;
   40  begin
   41    Zc_Ops.FunctionCleanUps.Clear;
   42    ZFunctions.Free;
   43  end;
   44  
   45  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   46  begin
   47    Result := not AllowFunctions;
   48  end;
   49  
   50  procedure T-->Grammar<--.ZError(const S : string);
   51  var
   52    E : EParseError;
   53  begin
   54    E := EParseError.Create(S);
   55    E.Message := S;
   56    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   57    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   58    raise E;
   59  end;
   60  
   61  
   62  CHARACTERS
   63  
   64          tab                = CHR(9). /*  9 = tabulator */
   65          eol                = CHR(10). /* 10 = line feed */
   66          cr                 = CHR(13). /* 13 = carriage return */
   67          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   68  
   69          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   70          digit              = "0123456789".
   71          hexDigit           = digit + "ABCDEFabcdef".
   72          notDigit           = ANY - digit.
   73  
   74          char               = ANY - "'" - '\' - newLine.
   75          verbatimStringChar = ANY - '"'.
   76          regularStringChar  = ANY - '"' - '\' - newLine.
   77          notNewLine         = ANY - newLine .
   78  
   79  
   80  TOKENS
   81  
   82    /*--------------------------------------------------------------------------------*/
   83          intCon =
   84                  ( digit {digit}
   85                  | ("0x" | "0X") hexDigit {hexDigit}
   86                  )
   87                  (* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] *)
   88                  .
   89    /*--------------------------------------------------------------------------------*/
   90          realCon =
   91                  "." digit {digit}
   92                  [("e" | "E") ["+" | "-"] digit {digit}]
   93                  ["F" | "f" | "D" | "d" | "M" | "m"]
   94          | digit {digit}
   95                  ( "." digit {digit}
   96                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
   97                          ["F" | "f" | "D" | "d" | "M" | "m"]
   98                  | ("e" | "E") ["+" | "-"] digit {digit}
   99                          ["F" | "f" | "D" | "d" | "M" | "m"]
  100                  | "F" | "f" | "D" | "d" | "M" | "m"
  101                  ).
  102    /*--------------------------------------------------------------------------------*/
  103          stringCon =
  104                  '"'    { regularStringChar
  105  					| "\'" | '\"' | "\\" | "\n"
  106  					}
  107                  '"'.
  108  
  109          ident = ['@'] letter { letter | digit }.
  110  
  111  
  112          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  113          and    = "&".
  114          assgn  = "=".
  115          colon  = ":".
  116          comma  = ",".
  117          dec    = "--".
  118          div    = "/".
  119          dot    = ".".
  120          eq     = "==".
  121          gt     = ">".
  122          gte    = ">=".
  123          inc    = "++".
  124          lbrace = "{".
  125          lbrack = "[".
  126          lpar   = "(".
  127          lshift = "<<".
  128          lt     = "<".
  129          lte    = "<=".
  130          minus  = "-".
  131          mod    = "%".
  132          neq    = "!=".
  133          not    = "!".
  134          or     = "|".
  135          plus   = "+".
  136          rbrace = "}".
  137          rbrack = "]".
  138          rpar   = ")".
  139          rshift = ">>".
  140          scolon = ";".
  141          tilde  = "~".
  142          times  = "*".
  143          xor    = "^".
  144  
  145  
  146  
  147  COMMENTS FROM "/*" TO "*/"
  148  COMMENTS FROM "//" TO eol
  149  
  150  IGNORE eol + cr + tab
  151  
  152  PRODUCTIONS
  153  
  154  /*------------------------------------------------------------------------*
  155   *--------------------------- Declarations -------------------------------*
  156   *------------------------------------------------------------------------*/
  157  
  158  Zc (. var 
  159          I : integer; 
  160          Func : TZcOpFunctionUserDefined; 
  161          Typ : TZcDataType;
  162      .)
  163  = 
  164  
  165    IF AllowFunctions THEN 
  166    BEGIN { 
  167      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  168            if SymTab.Contains(LexString) then
  169              ZError('Name already defined: ' + LexString);
  170              
  171            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  172            Func.Id := LexString;
  173            Func.ReturnType := Typ;
  174            SymTab.Add(Func.Id,Func);
  175            ZFunctions.Add(Func); 
  176            Self.CurrentFunction := Func;
  177            SymTab.PushScope;
  178            try
  179         .)
  180      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  181          (. 
  182            finally
  183            SymTab.PopScope;
  184            end;
  185          .)
  186      } 
  187    END ELSE
  188    BEGIN
  189  
  190  
  191    (. 
  192         Func := TZcOpFunctionUserDefined.Create(nil);
  193         Func.ReturnType := Self.ReturnType;
  194         Self.CurrentFunction := Func;
  195         SymTab.PushScope;
  196         try
  197         ZFunctions.Add(Func);
  198    .)
  199  
  200    /* A zc-expression is treated like the body of a nameless function
  201       to allow local var declarations  */
  202  
  203    ZcFuncBody
  204  
  205    (. 
  206         finally
  207         SymTab.PopScope;
  208         end;
  209    .)
  210    END
  211  
  212  (.  
  213         if Successful then
  214         begin
  215           for I:=0 to ZFunctions.Count-1 do
  216             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  217         end;
  218  .)
  219  .
  220  
  221  /*------------------------------------------------------------------------*/
  222  
  223  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  224  =  {  (. Op:=nil; .)
  225        Statement<Op>
  226        (. if Op<>nil then
  227             CurrentFunction.Statements.Add(Op);
  228           Op := nil;
  229        .)
  230     }
  231  .
  232  
  233  /*------------------------------------------------------------------------*/
  234  FormalParams                    
  235  = ( Par ["," FormalParams] )
  236  .
  237  /*------------------------------------------------------------------------*/
  238  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  239  = Type<Typ> ident
  240       (.
  241          if SymTab.ScopeContains(LexString) then
  242            SynError(201)
  243          else
  244          begin
  245            Arg := TZcOpArgumentVar.Create(GlobalNames);
  246            Arg.Id := LexString;
  247            Arg.Typ := Typ;
  248            CurrentFunction.AddArgument(Arg);
  249            SymTab.Add(Arg.Id,Arg);
  250          end;
  251       .)
  252  .
  253  /*------------------------------------------------------------------------*/
  254  
  255  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  256  = (. OutOp := nil; .)
  257    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  258  .
  259  
  260  /*------------------------------------------------------------------------*/
  261  
  262  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  263  = ident  
  264       (. 
  265          if SymTab.ScopeContains(LexString) then
  266            ZError('Name already defined: ' + LexString);
  267  
  268          Loc := TZcOpLocalVar.Create(nil);
  269          Loc.Id := LexString;
  270          Loc.Typ := Typ;        
  271       .)
  272       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  273       (. 
  274          SymTab.Add(Loc.Id,Loc);
  275          CurrentFunction.AddLocal(Loc);
  276  
  277          if Assigned(Loc.InitExpression) then
  278          begin
  279            //Generate tree for initial assignment
  280            if OutOp=nil then
  281              OutOp := MakeOp(zcBlock);
  282            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  283          end;
  284          
  285       .)
  286  .
  287  
  288  /*------------------------------------------------------------------------*/
  289  
  290  Init<var OutOp : TZcOp>
  291  = Expr<OutOp>
  292  .
  293  
  294  /*------------------------------------------------------------------------*/
  295  Argument<var OutOp : TZcOp>
  296  = /* ["ref" | "out"] */
  297    Expr<OutOp>
  298  .
  299  
  300  /*------------------------------------------------------------------------*
  301   *-------------------------------- Types ---------------------------------*
  302   *------------------------------------------------------------------------*/
  303  
  304  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  305   * and for array creation expressions                                     */
  306  
  307  
  308  Type<var Typ : TZcDataType>
  309  = ( SimpleType<Typ> )
  310  .
  311  
  312  /*------------------------------------------------------------------------*/
  313  
  314  SimpleType<var Typ : TZcDataType>
  315  /* = IntType | "float" | "double" | "decimal" | "bool" */
  316  = "float" (. Typ := zctFloat; .) |
  317    "int" (. Typ := zctInt; .) |
  318    "string" (. Typ := zctString; .)
  319  .
  320  
  321  /*------------------------------------------------------------------------*/
  322  
  323  /* IntType
  324  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  325  . */
  326  
  327  
  328  /*------------------------------------------------------------------------*
  329   *------------------------------ Statements ------------------------------*
  330   *------------------------------------------------------------------------*/
  331  
  332  Statement<var OutOp : TZcOp>
  333  = (. OutOp := nil; .)
  334  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  335  (*IF IsLocalVarDecl THEN 
  336  BEGIN
  337    LocalVarDecl ";"
  338  END
  339  |  EmbeddedStatement<OutOp> *)
  340  
  341  LocalVarDecl<OutOp> ";"
  342  | EmbeddedStatement<OutOp>
  343    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  344     * ident {"." ident} { "[" ...                           */
  345  .
  346  
  347  /*------------------------------------------------------------------------*/
  348  EmbeddedStatement<var OutOp : TZcOp>
  349    (. var
  350         Op,IfOp,IfBody,ElseOp : TZcOp;
  351         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  352         WhileCondOp,WhileBodyOp : TZcOp;
  353    .)
  354  = Block<OutOp>
  355  | ";"   (. OutOp := MakeOp(zcNop); .)
  356  | StatementExpr<OutOp> ";"
  357  | "if" (. ElseOp := nil; .)
  358    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  359          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  360  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  361   | "while"
  362       (. try
  363           SymTab.PushScope;
  364           WhileCondOp := nil; WhileBodyOp := nil; .)
  365     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  366     (.
  367           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  368         finally
  369           SymTab.PopScope;
  370         end;
  371     .)
  372   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  373   | "for"
  374      (. try
  375           SymTab.PushScope;
  376           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  377     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  378     (.
  379           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  380         finally
  381           SymTab.PopScope;
  382         end;
  383     .)
  384  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  385   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  386   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  387   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  388      (.
  389          if (Op=nil) then
  390          begin
  391            if CurrentFunction.ReturnType<>zctVoid then
  392              SynError(202)
  393            else
  394              OutOp := MakeOp(zcReturn);
  395          end else
  396          begin
  397            if CurrentFunction.ReturnType=zctVoid then
  398              SynError(203)
  399            else
  400              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  401          end;
  402      .)
  403  .
  404  /*------------------------------------------------------------------------*/
  405  
  406  Block<var OutOp : TZcOp>
  407    (. var
  408         Op : TZcOp;
  409    .)
  410  = (. Op := nil;
  411       OutOp := MakeOp(zcBlock); 
  412    .)
  413    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  414  
  415  /*------------------------------------------------------------------------*/
  416  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  417  = (. Op1 :=nil; Op2 := nil; .)
  418    Unary<Op1>
  419    ( AssignOp<Kind> Expr<Op2>
  420      (.
  421        if Op2<>nil then
  422          OutOp := MakeAssign(Kind,Op1,Op2);
  423      .)
  424    |                             (. OutOp := Op1; .)
  425    )
  426  .
  427  
  428  /*------------------------------------------------------------------------*/
  429  AssignOp<var Kind : TZcAssignType>
  430  = "="     (. Kind := atAssign; .)
  431    | "+="  (. Kind := atPlusAssign; .)
  432    | "-="  (. Kind := atMinusAssign; .)
  433    | "*="  (. Kind := atMulAssign; .)
  434    | "/="  (. Kind := atDivAssign; .)
  435  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  436  .
  437  
  438  /*------------------------------------------------------------------------*/
  439  
  440  /* SwitchSection   (. var Op : TZcOp; .)
  441  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  442  .  */
  443  
  444  /*------------------------------------------------------------------------*/
  445  
  446  /* SwitchLabel     (. var Op : TZcOp; .)
  447  = "case" Expr<Op> ":"
  448  | "default" ":"
  449  .  */
  450  
  451  /*------------------------------------------------------------------------*/
  452  
  453  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  454  = (. Op:=nil; OutOp := MakeOp(zcBlock); .) 
  455  (
  456  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  457  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  458    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  459  )
  460  .  
  461  
  462  /*------------------------------------------------------------------------*/
  463  
  464  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  465  = (. Op:=nil; 
  466       OutOp := MakeOp(zcBlock);
  467    .) 
  468  (
  469  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  470  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  471  )
  472  . 
  473  
  474  
  475  /*------------------------------------------------------------------------*
  476   *----------------------------- Expressions ------------------------------*
  477   *------------------------------------------------------------------------*/
  478  
  479  
  480  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  481  = Unary<Op1>
  482    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  483    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  484    )
  485  .
  486  /*------------------------------------------------------------------------*/
  487  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  488  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  489      {"||" Unary<Op> AndExpr<Op,R>
  490        (. OutOp := MakeOp(zcOr,[L,R]);
  491           L := OutOp; .)
  492      }
  493  .
  494  
  495  
  496  /*------------------------------------------------------------------------*/
  497  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  498  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  499      {"&&" Unary<Op> BitOrExpr<Op,R>
  500        (. OutOp := MakeOp(zcAnd,[L,R]);
  501           L := OutOp; .)
  502      }
  503  .
  504  /*------------------------------------------------------------------------*/
  505  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  506  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  507    {"|" Unary<Op> BitXorExpr<Op,R>
  508      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  509         L := OutOp; .)
  510    }
  511  .
  512  
  513  /*------------------------------------------------------------------------*/
  514  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  515  = BitAndExpr<InOp,OutOp> {"^" (. SynError(205); .) Unary<Op> BitAndExpr<InOp,OutOp>}
  516  .
  517  
  518  /*------------------------------------------------------------------------*/
  519  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  520  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  521    {"&" Unary<Op> EqlExpr<Op,R>
  522      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  523         L := OutOp; .)
  524    }
  525  .
  526  
  527  /*------------------------------------------------------------------------*/
  528  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  529  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  530    {( "!="   (. Kind := zcCompNE; .)
  531     | "=="   (. Kind := zcCompEQ; .)
  532     )
  533     Unary<Op> RelExpr<Op,R>
  534           (. OutOp := MakeBinary(Kind, L,R);
  535              L := OutOp;
  536           .)
  537    }
  538  .
  539  /*------------------------------------------------------------------------*/
  540  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  541  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  542    { ( "<"       (. Kind := zcCompLT; .)
  543      | ">"       (. Kind := zcCompGT; .)
  544      | "<="      (. Kind := zcCompLE; .)
  545      | ">="      (. Kind := zcCompGE; .)
  546       )
  547      Unary<Op> ShiftExpr<Op,R>
  548           (. OutOp := MakeBinary(Kind, L,R );
  549              L := OutOp;
  550           .)
  551    }
  552  .
  553  /*------------------------------------------------------------------------*/
  554  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ ShiftExpr is a deletable symbol
  555  = AddExpr<InOp,OutOp> (. L := OutOp; .)
  556    { ("<<"  (. Kind := zcBinaryShiftL; .)
  557      | ">>" (. Kind := zcBinaryShiftR; .)
  558      )
  559      Unary<Op> AddExpr<Op,R>
  560      (. OutOp := MakeOp(Kind,[L,R]);
  561         L := OutOp; .)
  562    }
  563  .
  564  /*------------------------------------------------------------------------*/
  565  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  566  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  567      {( "+"    (. Kind := zcPlus; .)
  568       | "-"    (. Kind := zcMinus; .)
  569       ) Unary<Op> MulExpr<Op,R>
  570           (. 
  571              if (L=nil) or (R=nil) then
  572                ZError('Invalid syntax');
  573              OutOp := MakeBinary(Kind,L,R);
  574              L := OutOp;
  575           .)
  576      }
  577  .
  578  /*------------------------------------------------------------------------*/
  579  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  580  =       (. OutOp := InOp; .)
  581    { ("*"      (. Kind := zcMul; .)
  582      | "/"     (. Kind := zcDiv; .)
  583    (*  | "%" *)
  584      ) Unary<Tmp>
  585           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  586              InOp := OutOp;
  587           .)
  588      }
  589  .
  590  /*------------------------------------------------------------------------*/
  591  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  592  =       (. LastOp := nil; Kind := zcNop; .)
  593    {
  594      (
  595        (* "+" | *)
  596        "-"   (. Kind := zcNegate; .) |
  597        "++"  (. Kind := zcPreInc; .) |    
  598        "--"  (. Kind := zcPreDec; .) |
  599        "!"   (. Kind := zcNot; .)
  600        (* | "!" | "~" | "*" |  *)
  601      )   
  602      (. 
  603         if Kind in [zcNegate,zcNot] then
  604         begin
  605           Tmp := MakeOp(Kind);
  606           if LastOp<>nil then
  607             LastOp.Children.Add(Tmp);
  608           LastOp := Tmp;
  609         end else if Assigned(LastOp) then 
  610           ZError('-- and ++ cannot be combined with other unary ops');
  611      .)
  612    }
  613    Primary<Tmp>
  614      (. 
  615         if Kind in [zcNop,zcNegate,zcNot] then
  616         begin
  617           if LastOp<>nil then
  618           begin
  619             LastOp.Children.Add(Tmp);
  620             OutOp := LastOp;
  621           end else
  622             OutOp := Tmp;
  623         end else 
  624         begin
  625           OutOp := MakePrePostIncDec(Kind,Tmp);
  626         end;
  627      .)
  628  .
  629  /*------------------------------------------------------------------------*/
  630  Primary<var OutOp : TZcOp>         
  631  (. var Op : TZcOp; S : string; V : single; 
  632       Typ : TZcDataType;
  633  .)
  634  =            (. OutOp := nil; .)
  635    ( 
  636      ident    (. OutOp := MakeOp(zcIdentifier,LexString);  .)
  637    | Literal<Typ>  (. 
  638          if Typ=zctString then
  639            OutOp := TZcOpLiteral.Create(Typ,LexString)
  640          else
  641          begin
  642            try
  643              S := LexString;
  644              V := ZcStrToFloat(S);
  645              OutOp := TZcOpLiteral.Create(Typ,V)
  646            except on EConvertError do
  647              SynError(200);
  648            end;
  649          end;
  650       .)
  651    | "(" Expr<OutOp> ")"
  652  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  653      | "float"  | "int"    | "long" | "object"  | "sbyte"
  654      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  655      ) "." ident *)
  656    )
  657  
  658    {
  659    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .) |
  660    "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .) |
  661  /*  | "->" ident
  662    | */
  663    "." ident (.
  664        Assert(OutOp.Kind=zcIdentifier);
  665        OutOp.Id := OutOp.Id + '.' + LexString;
  666      .)
  667    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  668             OutOp.Kind:=zcFuncCall;
  669           .)
  670          [Argument<Op> (. OutOp.Children.Add(Op); .)
  671            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  672            }
  673          ]
  674          (. 
  675             if not VerifyFunctionCall(OutOp,S) then
  676               ZError(S);
  677          .)
  678      ")"
  679  
  680    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  681             OutOp.Kind:=zcArrayAccess;
  682           .)
  683      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) 
  684        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) } 
  685      "]" 
  686  
  687    }
  688  .
  689  /*------------------------------------------------------------------------*/
  690  Literal<var Typ : TZcDataType>
  691  = intCon (. Typ :=zctInt; .) | 
  692    realCon (. Typ := zctFloat; .) |
  693    stringCon (. Typ := zctString; .)
  694    (* | "true" | "false" | "null" *)
  695  .
  696  
  697  END Zc.

    1 LL(1) error
   11 warnings

