

Compiled: den 28 december 2008 - 16:32:21
Output sent to: D:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 28 december 2008 @ 16:32:21

Statistics:
  number of terminals:        74 (limit  2561)
  number of non-terminals:    28 (limit  1281)
  number of pragmas:           0 (limit  2487)
  number of symbolnodes:     102 (limit  2561)
  number of graphnodes:      256 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    24 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;    
   16    PRIVATE
   17      CurrentFunction : TZcOpFunction;
   18      procedure CleanUp;
   19      function NoFunctionsAllowed : boolean;
   20      procedure ZError(const S : string);
   21    CREATE
   22      ZFunctions := TObjectList.Create(False);
   23    DESTROY
   24      CleanUp;
   25    ERRORS
   26      200 : Result := 'Not a floating point value';
   27      201 : Result := 'Name already defined in this scope';
   28      202 : Result := 'Return value expected';
   29      203 : Result := 'Function should not return a value';
   30      204 : Result := 'Only function definitions are allowed here';
   31  END_DELPHI
   32  
   33  (* Arbitrary Code *)
   34  
   35  
   36  
   37  
   38  procedure T-->Grammar<--.CleanUp;
   39  begin
   40    Zc_Ops.FunctionCleanUps.Clear;
   41    ZFunctions.Free;
   42  end;
   43  
   44  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   45  begin
   46    Result := not AllowFunctions;
   47  end;
   48  
   49  procedure T-->Grammar<--.ZError(const S : string);
   50  var
   51    E : EParseError;
   52  begin
   53    E := EParseError.Create(S);
   54    E.Message := S;
   55    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   56    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   57    raise E;
   58  end;
   59  
   60  
   61  CHARACTERS
   62  
   63          tab                = CHR(9). /*  9 = tabulator */
   64          eol                = CHR(10). /* 10 = line feed */
   65          cr                 = CHR(13). /* 13 = carriage return */
   66          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   67  
   68          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   69          digit              = "0123456789".
   70          hexDigit           = digit + "ABCDEFabcdef".
   71          notDigit           = ANY - digit.
   72  
   73          char               = ANY - "'" - '\\' - newLine.
   74          verbatimStringChar = ANY - '"'.
   75          regularStringChar  = ANY - '"' - '\\' - newLine.
   76          notNewLine         = ANY - newLine .
   77  
   78  
   79  TOKENS
   80  
   81    /*--------------------------------------------------------------------------------*/
   82          intCon =
   83                  ( digit {digit}
   84                  | ("0x" | "0X") hexDigit {hexDigit}
   85                  )
   86                  ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
   87    /*--------------------------------------------------------------------------------*/
   88          realCon =
   89                  "." digit {digit}
   90                  [("e" | "E") ["+" | "-"] digit {digit}]
   91                  ["F" | "f" | "D" | "d" | "M" | "m"]
   92          | digit {digit}
   93                  ( "." digit {digit}
   94                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
   95                          ["F" | "f" | "D" | "d" | "M" | "m"]
   96                  | ("e" | "E") ["+" | "-"] digit {digit}
   97                          ["F" | "f" | "D" | "d" | "M" | "m"]
   98                  | "F" | "f" | "D" | "d" | "M" | "m"
   99                  ).
  100    /*--------------------------------------------------------------------------------*/
  101          stringCon =
  102                  '"'    { regularStringChar }
  103                  '"'.
  104  
  105          ident = ['@'] letter { letter | digit }.
  106  
  107  
  108          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  109          and    = "&".
  110          assgn  = "=".
  111          colon  = ":".
  112          comma  = ",".
  113          dec    = "--".
  114          div    = "/".
  115          dot    = ".".
  116          eq     = "==".
  117          gt     = ">".
  118          gte    = ">=".
  119          inc    = "++".
  120          lbrace = "{".
  121          lbrack = "[".
  122          lpar   = "(".
  123          lshift = "<<".
  124          lt     = "<".
  125          lte    = "<=".
  126          minus  = "-".
  127          mod    = "%".
  128          neq    = "!=".
  129          not    = "!".
  130          or     = "|".
  131          plus   = "+".
  132          rbrace = "}".
  133          rbrack = "]".
  134          rpar   = ")".
  135          rshift = ">>".
  136          scolon = ";".
  137          tilde  = "~".
  138          times  = "*".
  139          xor    = "^".
  140  
  141  
  142  
  143  COMMENTS FROM "/*" TO "*/"
  144  COMMENTS FROM "//" TO eol
  145  
  146  IGNORE eol + cr + tab
  147  
  148  PRODUCTIONS
  149  
  150  /*------------------------------------------------------------------------*
  151   *--------------------------- Declarations -------------------------------*
  152   *------------------------------------------------------------------------*/
  153  
  154  Zc (. var 
  155          I : integer; 
  156          Func : TZcOpFunction; 
  157          Typ : TZcDataType;
  158      .)
  159  = 
  160  
  161    IF AllowFunctions THEN 
  162    BEGIN { 
  163      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  164            if SymTab.Contains(LexString) then
  165              ZError('Name already defined: ' + LexString)
  166            else
  167            begin
  168              Func := TZcOpFunction.Create(GlobalNames);
  169              Func.Id := LexString;
  170              Func.ReturnType := Typ;
  171              SymTab.Add(Func.Id,Func);
  172              ZFunctions.Add(Func); 
  173              Self.CurrentFunction := Func;
  174              SymTab.PushScope;
  175            end;
  176         .)
  177      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  178          (. 
  179             SymTab.PopScope;
  180          .)
  181      } 
  182    END ELSE
  183    BEGIN
  184  
  185  
  186    (. 
  187         Func := TZcOpFunction.Create(nil);
  188         Func.ReturnType := Self.ReturnType;
  189         Self.CurrentFunction := Func;
  190         SymTab.PushScope;
  191         ZFunctions.Add(Func);
  192    .)
  193  
  194    /* A zc-expression is treated like the body of a nameless function
  195       to allow local var declarations  */
  196  
  197    ZcFuncBody
  198  
  199    (. 
  200         SymTab.PopScope;
  201    .)
  202    END
  203  
  204  (.  
  205         if Successful then
  206         begin
  207           for I:=0 to ZFunctions.Count-1 do
  208             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  209         end;
  210  .)
  211  .
  212  
  213  /*------------------------------------------------------------------------*/
  214  
  215  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  216  =  {  (. Op:=nil; .)
  217        Statement<Op>
  218        (. if Op<>nil then
  219             CurrentFunction.Statements.Add(Op);
  220           Op := nil;
  221        .)
  222     }
  223  .
  224  
  225  /*------------------------------------------------------------------------*/
  226  FormalParams                    
  227  = ( Par ["," FormalParams] )
  228  .
  229  /*------------------------------------------------------------------------*/
  230  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  231  = Type<Typ> ident
  232       (.
  233          if SymTab.ScopeContains(LexString) then
  234            SynError(201)
  235          else
  236          begin
  237            Arg := TZcOpArgumentVar.Create(GlobalNames);
  238            Arg.Id := LexString;
  239            Arg.Typ := Typ;
  240            CurrentFunction.AddArgument(Arg);
  241            SymTab.Add(Arg.Id,Arg);
  242          end;
  243       .)
  244  .
  245  /*------------------------------------------------------------------------*/
  246  
  247  LocalVarDecl (. var Typ : TZcDataType; .)
  248  = Type<Typ> LocalVar<Typ> {"," LocalVar<Typ>}
  249  .
  250  
  251  /*------------------------------------------------------------------------*/
  252  
  253  LocalVar<Typ : TZcDataType> (. var Loc : TZcOpLocalVar; .)
  254  = ident  
  255       (. 
  256          if SymTab.ScopeContains(LexString) then
  257            SynError(201)
  258          else
  259          begin
  260            Loc := TZcOpLocalVar.Create(nil);
  261            Loc.Id := LexString;
  262            Loc.Typ := Typ;
  263            CurrentFunction.AddLocal(Loc);
  264            SymTab.Add(Loc.Id,Loc);
  265          end;
  266       .)
  267       /* [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ] */
  268  .
  269  
  270  /*------------------------------------------------------------------------*/
  271  
  272  /* Init           (. var Op : TZcOp; .)
  273  = Expr<Op>
  274  .  */
  275  
  276  /*------------------------------------------------------------------------*/
  277  Argument<var OutOp : TZcOp>
  278  = /* ["ref" | "out"] */
  279    Expr<OutOp>
  280  .
  281  
  282  /*------------------------------------------------------------------------*
  283   *-------------------------------- Types ---------------------------------*
  284   *------------------------------------------------------------------------*/
  285  
  286  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  287   * and for array creation expressions                                     */
  288  
  289  
  290  Type<var Typ : TZcDataType>
  291  = ( SimpleType<Typ> )
  292  .
  293  
  294  /*------------------------------------------------------------------------*/
  295  
  296  SimpleType<var Typ : TZcDataType>
  297  /* = IntType | "float" | "double" | "decimal" | "bool" */
  298  = "float" (. Typ := zctFloat; .) |
  299    "int" (. Typ := zctInt; .)
  300  .
  301  
  302  /*------------------------------------------------------------------------*/
  303  
  304  /* IntType
  305  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  306  . */
  307  
  308  
  309  /*------------------------------------------------------------------------*
  310   *------------------------------ Statements ------------------------------*
  311   *------------------------------------------------------------------------*/
  312  
  313  Statement<var OutOp : TZcOp>
  314  =
  315  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  316  (*IF IsLocalVarDecl THEN 
  317  BEGIN
  318    LocalVarDecl ";"
  319  END
  320  |  EmbeddedStatement<OutOp> *)
  321  
  322  LocalVarDecl ";"
  323  | EmbeddedStatement<OutOp>
  324    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  325     * ident {"." ident} { "[" ...                           */
  326  .
  327  
  328  /*------------------------------------------------------------------------*/
  329  EmbeddedStatement<var OutOp : TZcOp>
  330    (. var
  331         Op,IfOp,IfBody,ElseOp : TZcOp;
  332    .)
  333  = Block<OutOp>
  334  | ";"   (. OutOp := MakeOp(zcNop); .)
  335  | StatementExpr<OutOp> ";"
  336  | "if" (. ElseOp := nil; .)
  337    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  338          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  339  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  340  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  341  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  342  /* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
  343  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  344  /* | "break" ";" */
  345  /* | "continue" ";" */
  346   | (. Op := nil; .) "return" [ Expr<Op> ] ";"   
  347      (. 
  348          if (Op=nil) then
  349          begin
  350            if CurrentFunction.ReturnType<>zctVoid then
  351              SynError(202)
  352            else
  353              OutOp := MakeOp(zcReturn);
  354          end else
  355          begin
  356            if CurrentFunction.ReturnType=zctVoid then
  357              SynError(203)
  358            else
  359              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  360          end;
  361      .)
  362  .
  363  /*------------------------------------------------------------------------*/
  364  
  365  Block<var OutOp : TZcOp>
  366    (. var
  367         Op : TZcOp;
  368    .)
  369  = (. OutOp := MakeOp(zcBlock); .)
  370    "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".
  371  
  372  /*------------------------------------------------------------------------*/
  373  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  374  =
  375    Unary<Op1>
  376    ( AssignOp<Kind> Expr<Op2>
  377      (.
  378        OutOp := MakeAssign(Kind,Op1,Op2);
  379      .)
  380    |                             (. OutOp := Op1; .)
  381    )
  382  .
  383  
  384  /*------------------------------------------------------------------------*/
  385  AssignOp<var Kind : TZcAssignType>
  386  = "="     (. Kind := atAssign; .)
  387    | "+="  (. Kind := atPlusAssign; .)
  388    | "-="  (. Kind := atMinusAssign; .)
  389    | "*="  (. Kind := atMulAssign; .)
  390    | "/="  (. Kind := atDivAssign; .)
  391  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  392  .
  393  
  394  /*------------------------------------------------------------------------*/
  395  
  396  /* SwitchSection   (. var Op : TZcOp; .)
  397  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  398  .  */
  399  
  400  /*------------------------------------------------------------------------*/
  401  
  402  /* SwitchLabel     (. var Op : TZcOp; .)
  403  = "case" Expr<Op> ":"
  404  | "default" ":"
  405  .  */
  406  
  407  /*------------------------------------------------------------------------*/
  408  
  409  /* ForInit     (. var Op : TZcOp; .)
  410  = LocalVarDecl
  411  | StatementExpr<Op> { "," StatementExpr<Op> }
  412  .  */
  413  
  414  /*------------------------------------------------------------------------*/
  415  
  416  /* ForInc      (. var Op : TZcOp; .)
  417  = StatementExpr<Op> { "," StatementExpr<Op> }
  418  .  */
  419  
  420  
  421  /*------------------------------------------------------------------------*
  422   *----------------------------- Expressions ------------------------------*
  423   *------------------------------------------------------------------------*/
  424  
  425  
  426  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  427  = Unary<Op1>
  428    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  429    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  430    )
  431  .
  432  /*------------------------------------------------------------------------*/
  433  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  434  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  435      {"||" Unary<Op> AndExpr<Op,R>
  436        (. OutOp := MakeOp(zcOr,[L,R]);
  437           L := OutOp; .)
  438      }
  439  .
  440  
  441  
  442  /*------------------------------------------------------------------------*/
  443  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  444  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  445      {"&&" Unary<Op> BitOrExpr<Op,R>
  446        (. OutOp := MakeOp(zcAnd,[L,R]);
  447           L := OutOp; .)
  448      }
  449  .
  450  /*------------------------------------------------------------------------*/
  451  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  452  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  453  .
  454  /*------------------------------------------------------------------------*/
  455  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  456  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  457  .
  458  /*------------------------------------------------------------------------*/
  459  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  460  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  461  .
  462  /*------------------------------------------------------------------------*/
  463  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  464  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  465    {( "!="   (. Kind := zcCompNE; .)
  466     | "=="   (. Kind := zcCompEQ; .)
  467     )
  468     Unary<Op> RelExpr<Op,R>
  469           (. OutOp := MakeBinary(Kind, L,R);
  470              L := OutOp;
  471           .)
  472    }
  473  .
  474  /*------------------------------------------------------------------------*/
  475  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  476  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  477    { ( "<"       (. Kind := zcCompLT; .)
  478      | ">"       (. Kind := zcCompGT; .)
  479      | "<="      (. Kind := zcCompLE; .)
  480      | ">="      (. Kind := zcCompGE; .)
  481       )
  482      Unary<Op> ShiftExpr<Op,R>
  483           (. OutOp := MakeBinary(Kind, L,R );
  484              L := OutOp;
  485           .)
  486    }
  487  .
  488  /*------------------------------------------------------------------------*/
  489  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  490  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  491  .
  492  /*------------------------------------------------------------------------*/
  493  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  494  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  495      {( "+"    (. Kind := zcPlus; .)
  496       | "-"    (. Kind := zcMinus; .)
  497       ) Unary<Op> MulExpr<Op,R>
  498           (. OutOp := MakeBinary(Kind,L,R);
  499              L := OutOp;
  500           .)
  501      }
  502  .
  503  /*------------------------------------------------------------------------*/
  504  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  505  =       (. OutOp := InOp; .)
  506    { ("*"      (. Kind := zcMul; .)
  507      | "/"     (. Kind := zcDiv; .)
  508    (*  | "%" *)
  509      ) Unary<Tmp>
  510           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  511              InOp := OutOp;
  512           .)
  513      }
  514  .
  515  /*------------------------------------------------------------------------*/
  516  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  517  =       (. LastOp := nil; .)
  518    {
  519      (
  520        (* "+" | *)
  521        "-"       (. Kind := zcNegate; .)
  522        (* | "!" | "~" | "*" | "++" | "--" *)
  523      )   (. Tmp := MakeOp(Kind);
  524             if LastOp<>nil then
  525               LastOp.Children.Add(Tmp);
  526             LastOp := Tmp;
  527          .)
  528    }
  529    Primary<Tmp>
  530      (. if LastOp<>nil then
  531         begin
  532           LastOp.Children.Add(Tmp);
  533           OutOp := LastOp;
  534         end else
  535           OutOp := Tmp;
  536      .)
  537  .
  538  /*------------------------------------------------------------------------*/
  539  Primary<var OutOp : TZcOp>         (. var Op : TZcOp; S : string; V : single; .)
  540  =            (. OutOp := nil; .)
  541    ( 
  542      ident    (. 
  543         OutOp := MakeOp(zcIdentifier,LexString); 
  544         if SymTab.Contains(LexString) then
  545           OutOp.Ref := SymTab.Lookup(LexString);
  546                .)
  547    | Literal  (. 
  548          try
  549            V := StrToFloat(LexString);
  550            if Frac(V)=0 then
  551              OutOp := TZcOpLiteral.Create(zctInt,V)
  552            else
  553              OutOp := TZcOpLiteral.Create(zctFloat,V);
  554          except on EConvertError do
  555            SynError(200);
  556          end;
  557       .)
  558    | "(" Expr<OutOp> ")"
  559  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  560      | "float"  | "int"    | "long" | "object"  | "sbyte"
  561      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  562      ) "." ident *)
  563    )
  564  
  565    {
  566  /*  "++" | "--" | "->" ident
  567    | */
  568    "." ident (.
  569        Assert(OutOp.Kind=zcIdentifier);
  570        OutOp.Id := OutOp.Id + '.' + LexString;
  571      .)
  572    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  573             OutOp.Kind:=zcFuncCall;
  574           .)
  575          [Argument<Op> (. OutOp.Children.Add(Op); .)
  576            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  577            }
  578          ]
  579          (. 
  580             if not VerifyFunctionCall(OutOp,S) then
  581               ZError(S);
  582          .)
  583      ")"
  584  
  585    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  586             OutOp.Kind:=zcArrayAccess;
  587           .)
  588      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInteger) ); .) 
  589        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInteger) ); .) } 
  590      "]" 
  591  
  592    }
  593  .
  594  /*------------------------------------------------------------------------*/
  595  Literal
  596  = intCon | realCon (* | stringCon | "true" | "false" | "null" *)
  597  .
  598  
  599  END Zc.

    1 LL(1) error
   11 warnings

