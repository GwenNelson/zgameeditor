

Compiled: den 30 januari 2010 - 14:53:25
Output sent to: C:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 30 januari 2010 @ 14:53:25

Statistics:
  number of terminals:        80 (limit  2561)
  number of non-terminals:    31 (limit  1281)
  number of pragmas:           0 (limit  2481)
  number of symbolnodes:     111 (limit  2561)
  number of graphnodes:      333 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    23 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab,ZClasses
    5    USES (IMPLEMENTATION) ExprEdit
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZFunctions : TObjectList;
   12      SymTab : TSymbolTable;
   13      ReturnType : TZcDataType;
   14      AllowFunctions : boolean;
   15      GlobalNames : TObjectList;    
   16    PRIVATE
   17      CurrentFunction : TZcOpFunctionUserDefined;
   18      procedure CleanUp;
   19      function NoFunctionsAllowed : boolean;
   20      procedure ZError(const S : string);
   21    CREATE
   22      ZFunctions := TObjectList.Create(False);
   23    DESTROY
   24      CleanUp;
   25    ERRORS
   26      200 : Result := 'Not a floating point value';
   27      201 : Result := 'Name already defined in this scope';
   28      202 : Result := 'Return value expected';
   29      203 : Result := 'Function should not return a value';
   30      204 : Result := 'Only function definitions are allowed here';
   31  END_DELPHI
   32  
   33  (* Arbitrary Code *)
   34  
   35  
   36  
   37  
   38  procedure T-->Grammar<--.CleanUp;
   39  begin
   40    Zc_Ops.FunctionCleanUps.Clear;
   41    ZFunctions.Free;
   42  end;
   43  
   44  function T-->Grammar<--.NoFunctionsAllowed : boolean;
   45  begin
   46    Result := not AllowFunctions;
   47  end;
   48  
   49  procedure T-->Grammar<--.ZError(const S : string);
   50  var
   51    E : EParseError;
   52  begin
   53    E := EParseError.Create(S);
   54    E.Message := S;
   55    E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
   56    E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
   57    raise E;
   58  end;
   59  
   60  
   61  CHARACTERS
   62  
   63          tab                = CHR(9). /*  9 = tabulator */
   64          eol                = CHR(10). /* 10 = line feed */
   65          cr                 = CHR(13). /* 13 = carriage return */
   66          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
   67  
   68          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
   69          digit              = "0123456789".
   70          hexDigit           = digit + "ABCDEFabcdef".
   71          notDigit           = ANY - digit.
   72  
   73          char               = ANY - "'" - '\' - newLine.
   74          verbatimStringChar = ANY - '"'.
   75          regularStringChar  = ANY - '"' - '\' - newLine.
   76          notNewLine         = ANY - newLine .
   77  
   78  
   79  TOKENS
   80  
   81    /*--------------------------------------------------------------------------------*/
   82          intCon =
   83                  ( digit {digit}
   84                  (* | ("0x" | "0X") hexDigit {hexDigit} *)
   85                  )
   86                  (* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] *)
   87                  .
   88    /*--------------------------------------------------------------------------------*/
   89          realCon =
   90                  "." digit {digit}
   91                  [("e" | "E") ["+" | "-"] digit {digit}]
   92                  ["F" | "f" | "D" | "d" | "M" | "m"]
   93          | digit {digit}
   94                  ( "." digit {digit}
   95                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
   96                          ["F" | "f" | "D" | "d" | "M" | "m"]
   97                  | ("e" | "E") ["+" | "-"] digit {digit}
   98                          ["F" | "f" | "D" | "d" | "M" | "m"]
   99                  | "F" | "f" | "D" | "d" | "M" | "m"
  100                  ).
  101    /*--------------------------------------------------------------------------------*/
  102          stringCon =
  103                  '"'    { regularStringChar
  104  					| "\'" | '\"' | "\\" | "\n"
  105  					}
  106                  '"'.
  107  
  108          ident = ['@'] letter { letter | digit }.
  109  
  110  
  111          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  112          and    = "&".
  113          assgn  = "=".
  114          colon  = ":".
  115          comma  = ",".
  116          dec    = "--".
  117          div    = "/".
  118          dot    = ".".
  119          eq     = "==".
  120          gt     = ">".
  121          gte    = ">=".
  122          inc    = "++".
  123          lbrace = "{".
  124          lbrack = "[".
  125          lpar   = "(".
  126          lshift = "<<".
  127          lt     = "<".
  128          lte    = "<=".
  129          minus  = "-".
  130          mod    = "%".
  131          neq    = "!=".
  132          not    = "!".
  133          or     = "|".
  134          plus   = "+".
  135          rbrace = "}".
  136          rbrack = "]".
  137          rpar   = ")".
  138          rshift = ">>".
  139          scolon = ";".
  140          tilde  = "~".
  141          times  = "*".
  142          xor    = "^".
  143  
  144  
  145  
  146  COMMENTS FROM "/*" TO "*/"
  147  COMMENTS FROM "//" TO eol
  148  
  149  IGNORE eol + cr + tab
  150  
  151  PRODUCTIONS
  152  
  153  /*------------------------------------------------------------------------*
  154   *--------------------------- Declarations -------------------------------*
  155   *------------------------------------------------------------------------*/
  156  
  157  Zc (. var 
  158          I : integer; 
  159          Func : TZcOpFunctionUserDefined; 
  160          Typ : TZcDataType;
  161      .)
  162  = 
  163  
  164    IF AllowFunctions THEN 
  165    BEGIN { 
  166      ("void" (. Typ := zctVoid; .) | Type<Typ> ) ident (. 
  167            if SymTab.Contains(LexString) then
  168              ZError('Name already defined: ' + LexString);
  169              
  170            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  171            Func.Id := LexString;
  172            Func.ReturnType := Typ;
  173            SymTab.Add(Func.Id,Func);
  174            ZFunctions.Add(Func); 
  175            Self.CurrentFunction := Func;
  176            SymTab.PushScope;
  177            try
  178         .)
  179      "(" [ FormalParams ] ")" "{" ZcFuncBody "}"  
  180          (. 
  181            finally
  182            SymTab.PopScope;
  183            end;
  184          .)
  185      } 
  186    END ELSE
  187    BEGIN
  188  
  189  
  190    (. 
  191         Func := TZcOpFunctionUserDefined.Create(nil);
  192         Func.ReturnType := Self.ReturnType;
  193         Self.CurrentFunction := Func;
  194         SymTab.PushScope;
  195         try
  196         ZFunctions.Add(Func);
  197    .)
  198  
  199    /* A zc-expression is treated like the body of a nameless function
  200       to allow local var declarations  */
  201  
  202    ZcFuncBody
  203  
  204    (. 
  205         finally
  206         SymTab.PopScope;
  207         end;
  208    .)
  209    END
  210  
  211  (.  
  212         if Successful then
  213         begin
  214           for I:=0 to ZFunctions.Count-1 do
  215             ZFunctions[I] := TZcOp(ZFunctions[I]).Optimize;
  216         end;
  217  .)
  218  .
  219  
  220  /*------------------------------------------------------------------------*/
  221  
  222  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  223  =  {  (. Op:=nil; .)
  224        Statement<Op>
  225        (. if Op<>nil then
  226             CurrentFunction.Statements.Add(Op);
  227           Op := nil;
  228        .)
  229     }
  230  .
  231  
  232  /*------------------------------------------------------------------------*/
  233  FormalParams                    
  234  = ( Par ["," FormalParams] )
  235  .
  236  /*------------------------------------------------------------------------*/
  237  Par (. var Typ : TZcDataType; Arg : TZcOpArgumentVar; .)
  238  = Type<Typ> ident
  239       (.
  240          if SymTab.ScopeContains(LexString) then
  241            SynError(201)
  242          else
  243          begin
  244            Arg := TZcOpArgumentVar.Create(GlobalNames);
  245            Arg.Id := LexString;
  246            Arg.Typ := Typ;
  247            CurrentFunction.AddArgument(Arg);
  248            SymTab.Add(Arg.Id,Arg);
  249          end;
  250       .)
  251  .
  252  /*------------------------------------------------------------------------*/
  253  
  254  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  255  = (. OutOp := nil; .)
  256    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  257  .
  258  
  259  /*------------------------------------------------------------------------*/
  260  
  261  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  262  = ident  
  263       (. 
  264          if SymTab.ScopeContains(LexString) then
  265            ZError('Name already defined: ' + LexString);
  266  
  267          Loc := TZcOpLocalVar.Create(nil);
  268          Loc.Id := LexString;
  269          Loc.Typ := Typ;        
  270       .)
  271       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  272       (. 
  273          SymTab.Add(Loc.Id,Loc);
  274          CurrentFunction.AddLocal(Loc);
  275  
  276          if Assigned(Loc.InitExpression) then
  277          begin
  278            //Generate tree for initial assignment
  279            if OutOp=nil then
  280              OutOp := MakeOp(zcBlock);
  281            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  282          end;
  283          
  284       .)
  285  .
  286  
  287  /*------------------------------------------------------------------------*/
  288  
  289  Init<var OutOp : TZcOp>
  290  = Expr<OutOp>
  291  .
  292  
  293  /*------------------------------------------------------------------------*/
  294  Argument<var OutOp : TZcOp>
  295  = /* ["ref" | "out"] */
  296    Expr<OutOp>
  297  .
  298  
  299  /*------------------------------------------------------------------------*
  300   *-------------------------------- Types ---------------------------------*
  301   *------------------------------------------------------------------------*/
  302  
  303  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  304   * and for array creation expressions                                     */
  305  
  306  
  307  Type<var Typ : TZcDataType>
  308  = ( SimpleType<Typ> )
  309  .
  310  
  311  /*------------------------------------------------------------------------*/
  312  
  313  SimpleType<var Typ : TZcDataType>
  314  /* = IntType | "float" | "double" | "decimal" | "bool" */
  315  = "float" (. Typ := zctFloat; .) |
  316    "int" (. Typ := zctInt; .) |
  317    "string" (. Typ := zctString; .)
  318  .
  319  
  320  /*------------------------------------------------------------------------*/
  321  
  322  /* IntType
  323  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  324  . */
  325  
  326  
  327  /*------------------------------------------------------------------------*
  328   *------------------------------ Statements ------------------------------*
  329   *------------------------------------------------------------------------*/
  330  
  331  Statement<var OutOp : TZcOp>
  332  = (. OutOp := nil; .)
  333  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  334  (*IF IsLocalVarDecl THEN 
  335  BEGIN
  336    LocalVarDecl ";"
  337  END
  338  |  EmbeddedStatement<OutOp> *)
  339  
  340  LocalVarDecl<OutOp> ";"
  341  | EmbeddedStatement<OutOp>
  342    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  343     * ident {"." ident} { "[" ...                           */
  344  .
  345  
  346  /*------------------------------------------------------------------------*/
  347  EmbeddedStatement<var OutOp : TZcOp>
  348    (. var
  349         Op,IfOp,IfBody,ElseOp : TZcOp;
  350         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  351         WhileCondOp,WhileBodyOp : TZcOp;
  352    .)
  353  = Block<OutOp>
  354  | ";"   (. OutOp := MakeOp(zcNop); .)
  355  | StatementExpr<OutOp> ";"
  356  | "if" (. ElseOp := nil; .)
  357    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  358          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  359  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  360   | "while"
  361       (. try
  362           SymTab.PushScope;
  363           WhileCondOp := nil; WhileBodyOp := nil; .)
  364     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  365     (.
  366           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  367         finally
  368           SymTab.PopScope;
  369         end;
  370     .)
  371   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  372   | "for"
  373      (. try
  374           SymTab.PushScope;
  375           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  376     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  377     (.
  378           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  379         finally
  380           SymTab.PopScope;
  381         end;
  382     .)
  383  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  384  /* | "break" ";" */
  385  /* | "continue" ";" */
  386   | (. Op := nil; .) "return" [ Expr<Op> ] ";"   
  387      (. 
  388          if (Op=nil) then
  389          begin
  390            if CurrentFunction.ReturnType<>zctVoid then
  391              SynError(202)
  392            else
  393              OutOp := MakeOp(zcReturn);
  394          end else
  395          begin
  396            if CurrentFunction.ReturnType=zctVoid then
  397              SynError(203)
  398            else
  399              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  400          end;
  401      .)
  402  .
  403  /*------------------------------------------------------------------------*/
  404  
  405  Block<var OutOp : TZcOp>
  406    (. var
  407         Op : TZcOp;
  408    .)
  409  = (. Op := nil;
  410       OutOp := MakeOp(zcBlock); 
  411    .)
  412    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  413  
  414  /*------------------------------------------------------------------------*/
  415  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  416  = (. Op1 :=nil; Op2 := nil; .)
  417    Unary<Op1>
  418    ( AssignOp<Kind> Expr<Op2>
  419      (.
  420        if Op2<>nil then
  421          OutOp := MakeAssign(Kind,Op1,Op2);
  422      .)
  423    |                             (. OutOp := Op1; .)
  424    )
  425  .
  426  
  427  /*------------------------------------------------------------------------*/
  428  AssignOp<var Kind : TZcAssignType>
  429  = "="     (. Kind := atAssign; .)
  430    | "+="  (. Kind := atPlusAssign; .)
  431    | "-="  (. Kind := atMinusAssign; .)
  432    | "*="  (. Kind := atMulAssign; .)
  433    | "/="  (. Kind := atDivAssign; .)
  434  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  435  .
  436  
  437  /*------------------------------------------------------------------------*/
  438  
  439  /* SwitchSection   (. var Op : TZcOp; .)
  440  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  441  .  */
  442  
  443  /*------------------------------------------------------------------------*/
  444  
  445  /* SwitchLabel     (. var Op : TZcOp; .)
  446  = "case" Expr<Op> ":"
  447  | "default" ":"
  448  .  */
  449  
  450  /*------------------------------------------------------------------------*/
  451  
  452  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  453  = (. Op:=nil; OutOp := MakeOp(zcBlock); .) 
  454  (
  455  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  456  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  457    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  458  )
  459  .  
  460  
  461  /*------------------------------------------------------------------------*/
  462  
  463  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  464  = (. Op:=nil; 
  465       OutOp := MakeOp(zcBlock);
  466    .) 
  467  (
  468  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  469  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  470  )
  471  . 
  472  
  473  
  474  /*------------------------------------------------------------------------*
  475   *----------------------------- Expressions ------------------------------*
  476   *------------------------------------------------------------------------*/
  477  
  478  
  479  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  480  = Unary<Op1>
  481    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  482    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  483    )
  484  .
  485  /*------------------------------------------------------------------------*/
  486  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  487  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  488      {"||" Unary<Op> AndExpr<Op,R>
  489        (. OutOp := MakeOp(zcOr,[L,R]);
  490           L := OutOp; .)
  491      }
  492  .
  493  
  494  
  495  /*------------------------------------------------------------------------*/
  496  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  497  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  498      {"&&" Unary<Op> BitOrExpr<Op,R>
  499        (. OutOp := MakeOp(zcAnd,[L,R]);
  500           L := OutOp; .)
  501      }
  502  .
  503  /*------------------------------------------------------------------------*/
  504  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  505  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  506  .
  507  /*------------------------------------------------------------------------*/
  508  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  509  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  510  .
  511  /*------------------------------------------------------------------------*/
  512  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  513  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  514  .
  515  /*------------------------------------------------------------------------*/
  516  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  517  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  518    {( "!="   (. Kind := zcCompNE; .)
  519     | "=="   (. Kind := zcCompEQ; .)
  520     )
  521     Unary<Op> RelExpr<Op,R>
  522           (. OutOp := MakeBinary(Kind, L,R);
  523              L := OutOp;
  524           .)
  525    }
  526  .
  527  /*------------------------------------------------------------------------*/
  528  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  529  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  530    { ( "<"       (. Kind := zcCompLT; .)
  531      | ">"       (. Kind := zcCompGT; .)
  532      | "<="      (. Kind := zcCompLE; .)
  533      | ">="      (. Kind := zcCompGE; .)
  534       )
  535      Unary<Op> ShiftExpr<Op,R>
  536           (. OutOp := MakeBinary(Kind, L,R );
  537              L := OutOp;
  538           .)
  539    }
  540  .
  541  /*------------------------------------------------------------------------*/
  542  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  543  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  544  .
  545  /*------------------------------------------------------------------------*/
  546  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  547  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  548      {( "+"    (. Kind := zcPlus; .)
  549       | "-"    (. Kind := zcMinus; .)
  550       ) Unary<Op> MulExpr<Op,R>
  551           (. 
  552              if (L=nil) or (R=nil) then
  553                ZError('Invalid syntax');
  554              OutOp := MakeBinary(Kind,L,R);
  555              L := OutOp;
  556           .)
  557      }
  558  .
  559  /*------------------------------------------------------------------------*/
  560  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  561  =       (. OutOp := InOp; .)
  562    { ("*"      (. Kind := zcMul; .)
  563      | "/"     (. Kind := zcDiv; .)
  564    (*  | "%" *)
  565      ) Unary<Tmp>
  566           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  567              InOp := OutOp;
  568           .)
  569      }
  570  .
  571  /*------------------------------------------------------------------------*/
  572  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  573  =       (. LastOp := nil; Kind := zcNop; .)
  574    {
  575      (
  576        (* "+" | *)
  577        "-"   (. Kind := zcNegate; .) |
  578        "++"  (. Kind := zcPreInc; .) |    
  579        "--"  (. Kind := zcPreDec; .) |
  580        "!"   (. Kind := zcNot; .)
  581        (* | "!" | "~" | "*" |  *)
  582      )   
  583      (. 
  584         if Kind in [zcNegate,zcNot] then
  585         begin
  586           Tmp := MakeOp(Kind);
  587           if LastOp<>nil then
  588             LastOp.Children.Add(Tmp);
  589           LastOp := Tmp;
  590         end else if Assigned(LastOp) then 
  591           ZError('-- and ++ cannot be combined with other unary ops');
  592      .)
  593    }
  594    Primary<Tmp>
  595      (. 
  596         if Kind in [zcNop,zcNegate,zcNot] then
  597         begin
  598           if LastOp<>nil then
  599           begin
  600             LastOp.Children.Add(Tmp);
  601             OutOp := LastOp;
  602           end else
  603             OutOp := Tmp;
  604         end else 
  605         begin
  606           OutOp := MakePrePostIncDec(Kind,Tmp);
  607         end;
  608      .)
  609  .
  610  /*------------------------------------------------------------------------*/
  611  Primary<var OutOp : TZcOp>         
  612  (. var Op : TZcOp; S : string; V : single; 
  613       Typ : TZcDataType;
  614  .)
  615  =            (. OutOp := nil; .)
  616    ( 
  617      ident    (. OutOp := MakeOp(zcIdentifier,LexString);  .)
  618    | Literal<Typ>  (. 
  619          if Typ=zctString then
  620            OutOp := TZcOpLiteral.Create(Typ,LexString)
  621          else
  622          begin
  623            try
  624              S := LexString;
  625              if S[ Length(S) ] in ['F','f'] then
  626                S := Copy(S,1,Length(S)-1);
  627              V := StrToFloat(S);
  628              OutOp := TZcOpLiteral.Create(Typ,V)
  629            except on EConvertError do
  630              SynError(200);
  631            end;
  632          end;
  633       .)
  634    | "(" Expr<OutOp> ")"
  635  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  636      | "float"  | "int"    | "long" | "object"  | "sbyte"
  637      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  638      ) "." ident *)
  639    )
  640  
  641    {
  642    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .) |
  643    "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .) |
  644  /*  | "->" ident
  645    | */
  646    "." ident (.
  647        Assert(OutOp.Kind=zcIdentifier);
  648        OutOp.Id := OutOp.Id + '.' + LexString;
  649      .)
  650    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  651             OutOp.Kind:=zcFuncCall;
  652           .)
  653          [Argument<Op> (. OutOp.Children.Add(Op); .)
  654            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  655            }
  656          ]
  657          (. 
  658             if not VerifyFunctionCall(OutOp,S) then
  659               ZError(S);
  660          .)
  661      ")"
  662  
  663    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  664             OutOp.Kind:=zcArrayAccess;
  665           .)
  666      Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) 
  667        {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) } 
  668      "]" 
  669  
  670    }
  671  .
  672  /*------------------------------------------------------------------------*/
  673  Literal<var Typ : TZcDataType>
  674  = intCon (. Typ :=zctInt; .) | 
  675    realCon (. Typ := zctFloat; .) |
  676    stringCon (. Typ := zctString; .)
  677    (* | "true" | "false" | "null" *)
  678  .
  679  
  680  END Zc.

    1 LL(1) error
   11 warnings

