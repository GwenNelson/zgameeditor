

Compiled: den 10 september 2008 - 13:15:49
Output sent to: D:\DATA\Delphi32\ZzDC_Public\tools\ZDesigner\expr\

================================================================================
Switches:
  Generate version information
  Use Hash functions to lookup literals
  Use SysUtils.SameText for case insensitive compares
  Treat space character as whitespace


================================================================================
Grammar Tests:
  Deletable symbols:
     MulExpr
     AddExpr
     ShiftExpr
     RelExpr
     EqlExpr
     BitAndExpr
     BitXorExpr
     BitOrExpr
     AndExpr
     OrExpr
     ZcFuncBody
     Zc
  Undefined nonterminals:   -- none --
  Unreachable nonterminals: -- none --
  Circular derivations:     -- none --
  Underivable nonterminals: -- none --
  LL(1) conditions:
     LL(1) error in EmbeddedStatement: "else" is the start & successor of a deletable structure

================================================================================
Time Compiled: den 10 september 2008 @ 13:15:49

Statistics:
  number of terminals:        75 (limit  2561)
  number of non-terminals:    26 (limit  1281)
  number of pragmas:           0 (limit  2486)
  number of symbolnodes:     101 (limit  2561)
  number of graphnodes:      228 (limit 15001)
  number of conditionsets:     1 (limit   101)
  number of charactersets:    24 (limit  4001)


================================================================================
Listing

    1  COMPILER Zc
    2  
    3  DELPHI
    4    USES (INTERFACE) Zc_Ops,contnrs,uSymTab
    5   (* USES (IMPLEMENTATION)  *)
    6  
    7    TYPE
    8  
    9  
   10    PUBLIC
   11      ZStatements : TObjectList;
   12      SymTab : TSymbolTable;
   13    PRIVATE
   14      CurrentFunction : TZcOpFunction;
   15      procedure WriteStr(S : string);
   16      procedure WriteOp(Op : TZcOp);
   17      procedure AddGlobalStatement(Op : TZcOp);
   18      procedure CleanUp;
   19      function IsLocalVarDecl : boolean;
   20    CREATE
   21      ZStatements := TObjectList.Create(False);
   22      //Alla nodes ägs av globalcleanups
   23      GlobalCleanUps := TObjectList.Create;
   24    DESTROY
   25      CleanUp;
   26    ERRORS
   27      200 : Result := 'Not a floating point value';
   28      201 : Result := 'Variable name already defined in this scope';
   29  END_DELPHI
   30  
   31  (* Arbitrary Code *)
   32  
   33  var
   34    GlobalCleanUps : TObjectList;
   35  
   36  function MakeOp(Kind : TZcOpKind) : TZcOp; overload;
   37  begin
   38    Result := TZcOp.Create(GlobalCleanUps);
   39    Result.Kind := Kind;
   40  end;
   41  function MakeOp(Kind : TZcOpKind; Value : single) : TZcOp; overload;
   42  begin
   43    Result := MakeOp(Kind);
   44    Result.Value := Value;
   45  end;
   46  function MakeOp(Kind : TZcOpKind; Id :string) : TZcOp; overload;
   47  begin
   48    Result := MakeOp(Kind);
   49    Result.Id := Id;
   50  end;
   51  function MakeOp(Kind : TZcOpKind; const Children : array of TZcOp) : TZcOp; overload;
   52  var
   53    I : integer;
   54  begin
   55    Result := MakeOp(Kind);
   56    for I := 0 to High(Children) do
   57      Result.Children.Add(Children[I]);
   58  end;
   59  
   60  function MakeAssign(Kind : TZcAssignType; Op1,Op2 : TZcOp) : TZcOp;
   61  const
   62    AssignMap : array[TZcAssignType] of TZcOpKind = (zcNop,zcMul,zcDiv,zcPlus,zcMinus);
   63  var
   64    Tmp : TZcOp;
   65  begin
   66    case Kind of
   67      atMulAssign,atDivAssign,atPlusAssign,atMinusAssign :  //Convert x*=2 to x=x*2
   68        begin
   69          Tmp := MakeOp(zcIdentifier,Op1.Id);
   70          Op2 := MakeOp(AssignMap[Kind],[Tmp,Op2]);
   71        end;
   72    end;
   73    Result := MakeOp(zcAssign,[Op1,Op2]);
   74  end;
   75  
   76  procedure T-->Grammar<--.WriteStr(S : string);
   77  begin
   78    StreamToListFile(S, TRUE);
   79  end;
   80  
   81  procedure T-->Grammar<--.WriteOp(Op : TZcOp);
   82  begin
   83    WriteStr(Op.ToString);
   84  end;
   85  
   86  procedure T-->Grammar<--.AddGlobalStatement(Op : TZcOp);
   87  begin
   88    ZStatements.Add(Op);
   89  end;
   90  
   91  function T-->Grammar<--.IsLocalVarDecl : boolean;
   92  begin
   93    Result := fCurrentInputSymbol=floatSym;
   94  end;
   95  
   96  procedure T-->Grammar<--.CleanUp;
   97  //var
   98  //  I : integer;
   99  begin
  100  //  for I := 0 to ZSTatements.Count-1 do TObject(ZStatements[I]).Free;
  101    ZStatements.Free;
  102    GlobalCleanUps.Free;
  103  end;
  104  
  105  CHARACTERS
  106  
  107          tab                = CHR(9). /*  9 = tabulator */
  108          eol                = CHR(10). /* 10 = line feed */
  109          cr                 = CHR(13). /* 13 = carriage return */
  110          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  111  
  112          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  113          digit              = "0123456789".
  114          hexDigit           = digit + "ABCDEFabcdef".
  115          notDigit           = ANY - digit.
  116  
  117          char               = ANY - "'" - '\\' - newLine.
  118          verbatimStringChar = ANY - '"'.
  119          regularStringChar  = ANY - '"' - '\\' - newLine.
  120          notNewLine         = ANY - newLine .
  121  
  122  
  123  TOKENS
  124  
  125    /*--------------------------------------------------------------------------------*/
  126          intCon =
  127                  ( digit {digit}
  128                  | ("0x" | "0X") hexDigit {hexDigit}
  129                  )
  130                  ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  131    /*--------------------------------------------------------------------------------*/
  132          realCon =
  133                  "." digit {digit}
  134                  [("e" | "E") ["+" | "-"] digit {digit}]
  135                  ["F" | "f" | "D" | "d" | "M" | "m"]
  136          | digit {digit}
  137                  ( "." digit {digit}
  138                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  139                          ["F" | "f" | "D" | "d" | "M" | "m"]
  140                  | ("e" | "E") ["+" | "-"] digit {digit}
  141                          ["F" | "f" | "D" | "d" | "M" | "m"]
  142                  | "F" | "f" | "D" | "d" | "M" | "m"
  143                  ).
  144    /*--------------------------------------------------------------------------------*/
  145          stringCon =
  146                  '"'    { regularStringChar }
  147                  '"'.
  148  
  149          ident = ['@'] letter { letter | digit }.
  150  
  151  
  152          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  153          and    = "&".
  154          assgn  = "=".
  155          colon  = ":".
  156          comma  = ",".
  157          dec    = "--".
  158          div    = "/".
  159          dot    = ".".
  160          eq     = "==".
  161          gt     = ">".
  162          gte    = ">=".
  163          inc    = "++".
  164          lbrace = "{".
  165          lbrack = "[".
  166          lpar   = "(".
  167          lshift = "<<".
  168          lt     = "<".
  169          lte    = "<=".
  170          minus  = "-".
  171          mod    = "%".
  172          neq    = "!=".
  173          not    = "!".
  174          or     = "|".
  175          plus   = "+".
  176          rbrace = "}".
  177          rbrack = "]".
  178          rpar   = ")".
  179          rshift = ">>".
  180          scolon = ";".
  181          tilde  = "~".
  182          times  = "*".
  183          xor    = "^".
  184  
  185  
  186  
  187  COMMENTS FROM "/*" TO "*/"
  188  COMMENTS FROM "//" TO eol
  189  
  190  IGNORE eol + cr + tab
  191  
  192  PRODUCTIONS
  193  
  194  /*------------------------------------------------------------------------*
  195   *--------------------------- Declarations -------------------------------*
  196   *------------------------------------------------------------------------*/
  197  
  198  Zc      (. var I : integer; Func : TZcOpFunction; .)
*****  ^ Zc is a deletable symbol
  199  = (. 
  200       Func := TZcOpFunction.Create(GlobalCleanUps);
  201       Self.CurrentFunction := Func;
  202       
  203       SymTab.PushScope;
  204    .)
  205  
  206    /* A zc-expression is treated like the body of a nameless function
  207       to allow local var declarations  */
  208  
  209    ZcFuncBody
  210  
  211    (. 
  212       SymTab.PopScope;
  213    
  214       AddGlobalStatement(Func);
  215       
  216       if Successful then
  217       begin
  218         for I:=0 to ZStatements.Count-1 do
  219         begin
  220           TZcOp(ZStatements[I]).Optimize;
  221           WriteOp(TZcOp(ZStatements[I]));
  222         end;
  223       end;
  224    .)
  225  .
  226  
  227  /*------------------------------------------------------------------------*/
  228  
  229  ZcFuncBody (. var Op : TZcOp; .)
*****  ^ ZcFuncBody is a deletable symbol
  230  =  {  (. Op:=nil; .)
  231        Statement<Op>
  232        (. if Op<>nil then
  233             CurrentFunction.Statements.Add(Op);
  234           Op := nil;
  235        .)
  236     }
  237  .
  238  
  239  /*------------------------------------------------------------------------*/
  240  
  241  LocalVarDecl
  242  = Type LocalVar {"," LocalVar}
  243  .
  244  
  245  /*------------------------------------------------------------------------*/
  246  
  247  LocalVar       (. var Loc : TZcOpLocalVar; .)
  248  = ident  
  249       (. 
  250          if SymTab.ScopeContains(LexString) then
  251            SynError(201)
  252          else
  253          begin
  254            Loc := TZcOpLocalVar.Create(GlobalCleanUps);
  255            Loc.Ordinal := CurrentFunction.Locals.Count;
  256            Loc.Id := LexString;
  257            SymTab.Add(Loc.Id,Loc);
  258            CurrentFunction.Locals.Add(Loc);
  259          end;
  260       .)
  261       /* [ "=" ( Init | "stackalloc" Type "[" Expr<Op> "]") ] */
  262  .
  263  
  264  /*------------------------------------------------------------------------*/
  265  
  266  /* Init           (. var Op : TZcOp; .)
  267  = Expr<Op>
  268  .  */
  269  
  270  /*------------------------------------------------------------------------*/
  271  Argument<var OutOp : TZcOp>
  272  = /* ["ref" | "out"] */
  273    Expr<OutOp>
  274  .
  275  
  276  /*------------------------------------------------------------------------*
  277   *-------------------------------- Types ---------------------------------*
  278   *------------------------------------------------------------------------*/
  279  
  280  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  281   * and for array creation expressions                                     */
  282  
  283  
  284  Type
  285  = ( SimpleType )
  286  .
  287  
  288  /*------------------------------------------------------------------------*/
  289  
  290  SimpleType
  291  /* = IntType | "float" | "double" | "decimal" | "bool" */
  292  = "float"
  293  .
  294  
  295  /*------------------------------------------------------------------------*/
  296  
  297  /* IntType
  298  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  299  . */
  300  
  301  
  302  /*------------------------------------------------------------------------*
  303   *------------------------------ Statements ------------------------------*
  304   *------------------------------------------------------------------------*/
  305  
  306  Statement<var OutOp : TZcOp>
  307  =
  308  /* "const" Type ident "=" Expr<Op> {"," ident "=" Expr<Op>} ";" */
  309  (*IF IsLocalVarDecl THEN 
  310  BEGIN
  311    LocalVarDecl ";"
  312  END
  313  |  EmbeddedStatement<OutOp> *)
  314  
  315  LocalVarDecl ";"
  316  | EmbeddedStatement<OutOp>
  317    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  318     * ident {"." ident} { "[" ...                           */
  319  .
  320  
  321  /*------------------------------------------------------------------------*/
  322  EmbeddedStatement<var OutOp : TZcOp>
  323    (. var
  324         Op,IfOp,IfBody,ElseOp : TZcOp;
  325    .)
  326  =
  327    Block<OutOp>
  328  | ";"   (. OutOp := MakeOp(zcNop); .)
  329  | StatementExpr<OutOp> ";"
  330  | "if" (. ElseOp := nil; .)
  331    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
*****  ^  in EmbeddedStatement:  "else" is the start & successor of a deletable structure
  332          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  333  /* | "switch" "(" Expr<Op> ")" "{" {SwitchSection} "}" */
  334  /* | "while" "(" Expr<Op> ")" EmbeddedStatement<Op> */
  335  /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  336  /* | "for" "(" [ForInit] ";" [Expr<Op>] ";" [ForInc] ")" EmbeddedStatement<Op> */
  337  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  338  /* | "break" ";" */
  339  /* | "continue" ";" */
  340   | "return" Expr<Op> ";"   (. OutOp := MakeOp(zcReturn,[Op]); {return måste har ett expr} .)
  341  .
  342  /*------------------------------------------------------------------------*/
  343  
  344  Block<var OutOp : TZcOp>
  345    (. var
  346         Op : TZcOp;
  347    .)
  348  = (. OutOp := MakeOp(zcBlock); .)
  349    "{" {Statement<Op> (. OutOp.Children.Add(Op); .) } "}".
  350  
  351  /*------------------------------------------------------------------------*/
  352  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  353  =
  354    Unary<Op1>
  355    ( AssignOp<Kind> Expr<Op2>
  356      (.
  357        OutOp := MakeAssign(Kind,Op1,Op2);
  358      .)
  359    |                             (. OutOp := Op1; .)
  360    )
  361  .
  362  
  363  /*------------------------------------------------------------------------*/
  364  AssignOp<var Kind : TZcAssignType>
  365  = "="     (. Kind := atAssign; .)
  366    | "+="  (. Kind := atPlusAssign; .)
  367    | "-="  (. Kind := atMinusAssign; .)
  368    | "*="  (. Kind := atMulAssign; .)
  369    | "/="  (. Kind := atDivAssign; .)
  370  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  371  .
  372  
  373  /*------------------------------------------------------------------------*/
  374  
  375  /* SwitchSection   (. var Op : TZcOp; .)
  376  = SwitchLabel { SwitchLabel } Statement<Op> { Statement<Op> }
  377  .  */
  378  
  379  /*------------------------------------------------------------------------*/
  380  
  381  /* SwitchLabel     (. var Op : TZcOp; .)
  382  = "case" Expr<Op> ":"
  383  | "default" ":"
  384  .  */
  385  
  386  /*------------------------------------------------------------------------*/
  387  
  388  /* ForInit     (. var Op : TZcOp; .)
  389  = LocalVarDecl
  390  | StatementExpr<Op> { "," StatementExpr<Op> }
  391  .  */
  392  
  393  /*------------------------------------------------------------------------*/
  394  
  395  /* ForInc      (. var Op : TZcOp; .)
  396  = StatementExpr<Op> { "," StatementExpr<Op> }
  397  .  */
  398  
  399  
  400  /*------------------------------------------------------------------------*
  401   *----------------------------- Expressions ------------------------------*
  402   *------------------------------------------------------------------------*/
  403  
  404  
  405  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  406  = Unary<Op1>
  407    ( OrExpr<Op1,OutOp> /* ["?" Expr<Op1> ":" Expr<Op1> ] */
  408    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1,Op2); .)
  409    )
  410  .
  411  /*------------------------------------------------------------------------*/
  412  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ OrExpr is a deletable symbol
  413  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  414      {"||" Unary<Op> AndExpr<Op,R>
  415        (. OutOp := MakeOp(zcOr,[L,R]);
  416           L := OutOp; .)
  417      }
  418  .
  419  
  420  
  421  /*------------------------------------------------------------------------*/
  422  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
*****  ^ AndExpr is a deletable symbol
  423  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  424      {"&&" Unary<Op> BitOrExpr<Op,R>
  425        (. OutOp := MakeOp(zcAnd,[L,R]);
  426           L := OutOp; .)
  427      }
  428  .
  429  /*------------------------------------------------------------------------*/
  430  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitOrExpr is a deletable symbol
  431  = BitXorExpr<InOp,OutOp> {"|" Unary<Op> BitXorExpr<InOp,OutOp>}
  432  .
  433  /*------------------------------------------------------------------------*/
  434  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitXorExpr is a deletable symbol
  435  = BitAndExpr<InOp,OutOp> {"^" Unary<Op> BitAndExpr<InOp,OutOp>}
  436  .
  437  /*------------------------------------------------------------------------*/
  438  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ BitAndExpr is a deletable symbol
  439  = EqlExpr<InOp,OutOp> {"&" Unary<Op> EqlExpr<InOp,OutOp>}
  440  .
  441  /*------------------------------------------------------------------------*/
  442  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
*****  ^ EqlExpr is a deletable symbol
  443  = RelExpr<InOp,OutOp>   (. L := OutOp; .)
  444    {( "!="   (. Kind := zcCompNE; .)
  445     | "=="   (. Kind := zcCompEQ; .)
  446     )
  447     Unary<Op> RelExpr<Op,R>
  448           (. OutOp := MakeOp(Kind,[L,R]);
  449              L := OutOp;
  450           .)
  451    }
  452  .
  453  /*------------------------------------------------------------------------*/
  454  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
*****  ^ RelExpr is a deletable symbol
  455  = ShiftExpr<InOp,OutOp>         (. L := OutOp; .)
  456    { ( "<"       (. Kind := zcCompLT; .)
  457      | ">"       (. Kind := zcCompGT; .)
  458      | "<="      (. Kind := zcCompLE; .)
  459      | ">="      (. Kind := zcCompGE; .)
  460       )
  461      Unary<Op> ShiftExpr<Op,R>
  462           (. OutOp := MakeOp(Kind,[L,R]);
  463              L := OutOp;
  464           .)
  465    }
  466  .
  467  /*------------------------------------------------------------------------*/
  468  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op : TZcOp; .)
*****  ^ ShiftExpr is a deletable symbol
  469  = AddExpr<InOp,OutOp> {("<<" | ">>") Unary<Op> AddExpr<InOp,OutOp>}
  470  .
  471  /*------------------------------------------------------------------------*/
  472  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
*****  ^ AddExpr is a deletable symbol
  473  = MulExpr<InOp,OutOp>   (. L := OutOp; .)
  474      {( "+"    (. Kind := zcPlus; .)
  475       | "-"    (. Kind := zcMinus; .)
  476       ) Unary<Op> MulExpr<Op,R>
  477           (. OutOp := MakeOp(Kind,[L,R]);
  478              L := OutOp;
  479           .)
  480      }
  481  .
  482  /*------------------------------------------------------------------------*/
  483  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
*****  ^ MulExpr is a deletable symbol
  484  =       (. OutOp := InOp; .)
  485    { ("*"      (. Kind := zcMul; .)
  486      | "/"     (. Kind := zcDiv; .)
  487    (*  | "%" *)
  488      ) Unary<Tmp>
  489           (. OutOp := MakeOp(Kind,[InOp,Tmp]);
  490              InOp := OutOp;
  491           .)
  492      }
  493  .
  494  /*------------------------------------------------------------------------*/
  495  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  496  =       (. LastOp := nil; .)
  497    {
  498      (
  499        (* "+" | *)
  500        "-"       (. Kind := zcNegate; .)
  501        (* | "!" | "~" | "*" | "++" | "--" *)
  502      )   (. Tmp := MakeOp(Kind);
  503             if LastOp<>nil then
  504               LastOp.Children.Add(Tmp);
  505             LastOp := Tmp;
  506          .)
  507    }
  508    Primary<Tmp>
  509      (. if LastOp<>nil then
  510         begin
  511           LastOp.Children.Add(Tmp);
  512           OutOp := LastOp;
  513         end else
  514           OutOp := Tmp;
  515      .)
  516  .
  517  /*------------------------------------------------------------------------*/
  518  Primary<var OutOp : TZcOp>         (. var Op : TZcOp; .)
  519  =            (. OutOp := nil; .)
  520    ( 
  521      ident    (. 
  522         OutOp := MakeOp(zcIdentifier,LexString); 
  523         if SymTab.Contains(LexString) then
  524           OutOp.Ref := SymTab.Lookup(LexString);
  525                .)
  526    | Literal  (. 
  527          try
  528            OutOp := MakeOp(zcConst,StrToFloat(LexString)); 
  529          except on EConvertError do
  530            SynError(200);
  531          end;
  532       .)
  533    | "(" Expr<OutOp> ")"
  534  (*  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
  535      | "float"  | "int"    | "long" | "object"  | "sbyte"
  536      | "short"  | "string" | "uint" | "ulong"   | "ushort"
  537      ) "." ident *)
  538    )
  539  
  540    {
  541  /*  "++" | "--" | "->" ident
  542    | */
  543    "." ident (.
  544        Assert(OutOp.Kind=zcIdentifier);
  545        OutOp.Id := OutOp.Id + '.' + LexString;
  546      .)
  547    | "(" (. Assert(OutOp.Kind=zcIdentifier);
  548             OutOp.Kind:=zcFuncCall;
  549           .)
  550          [Argument<Op> (. OutOp.Children.Add(Op); .)
  551            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
  552            }
  553          ]
  554      ")"
  555  
  556    | "[" (. Assert(OutOp.Kind=zcIdentifier);
  557             OutOp.Kind:=zcArrayAccess;
  558           .)
  559      Expr<Op> (. OutOp.Children.Add(Op); .) 
  560        {"," Expr<Op> (. OutOp.Children.Add(Op); .) } 
  561      "]" 
  562  
  563    }
  564  .
  565  /*------------------------------------------------------------------------*/
  566  Literal
  567  = intCon | realCon | stringCon | "true" | "false" | "null"
  568  .
  569  
  570  END Zc.

    1 LL(1) error
   12 warnings

