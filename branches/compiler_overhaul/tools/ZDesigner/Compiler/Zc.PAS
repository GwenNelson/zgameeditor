unit Zc;




{==============================================================================
Zc
1.0.0.116
Date of Generation: 2006-05-09 16:41
Comment: Zc
Author: Ville Krumlinde
Copyright: 

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface
uses  SysUtils,Classes,CocoBase,Zc_Ops,contnrs,uSymTab,ZClasses,mwStringHashList;



const
maxT = 87;
type

  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EZc = class(Exception);
  TZc = class;

  TZcScanner = class(TCocoRScanner)
  private
    FOwner : TZc;
fHashList: TmwStringHashList;
function CharInIgnoreSet(const Ch : char) : boolean;
procedure CheckLiteral(var Sym : integer);
function GetNextSymbolString: string;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TZc read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TZcScanner }

  TZc = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..5] of SymbolSet; // symSet[0] = allSyncSyms

    function GetBuildDate : TDateTime;
    function GetVersion : string;
    function GetVersionStr : string;
    procedure SetVersion(const Value : string);
    function GetVersionInfo : string;
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Literal (var Typ : TZcDataType);
    procedure _Primary (var OutOp : TZcOp);
    procedure _MulExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _AddExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _ShiftExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _RelExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _EqlExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitAndExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitXorExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitOrExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _AndExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _OrExpr (InOp : TZcOp; var OutOp : TZcOp);
    procedure _SwitchLabel (var OutOp : TZcOp);
    procedure _AssignOp (var Kind : TZcAssignType);
    procedure _Unary (var OutOp : TZcOp);
    procedure _ForInc (var OutOp : TZcOp);
    procedure _ForInit (var OutOp : TZcOp);
    procedure _SwitchSection (SwitchOp : TZcOpSwitch);
    procedure _StatementExpr (var OutOp : TZcOp);
    procedure _Block (var OutOp : TZcOp);
    procedure _EmbeddedStatement (var OutOp : TZcOp);
    procedure _SimpleType (var Typ : TZcDataType);
    procedure _Argument (var OutOp : TZcOp);
    procedure _Expr (var OutOp : TZcOp);
    procedure _Init (var OutOp : TZcOp);
    procedure _LocalVar (Typ : TZcDataType; var OutOp : TZcOp);
    procedure _LocalVarDecl (var OutOp : TZcOp);
    procedure _Par;
    procedure _Statement (var OutOp : TZcOp);
    procedure _ZcFuncBody;
    procedure _FormalParams;
    procedure _Type (var Typ : TZcDataType);
    procedure _Zc;

  private
    CurrentFunction : TZcOpFunctionUserDefined;
    procedure CleanUp;
    procedure ZError(const S : string);
    procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : string) : string; override;
    procedure Execute;
    function GetScanner : TZcScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionStr : string read GetVersionStr;
    property VersionInfo : string read GetVersionInfo;

  public
    ZFunctions : TObjectList;
    SymTab : TSymbolTable;
    ReturnType : TZcDataType;
    AllowFunctions : boolean;
    GlobalNames : TObjectList;

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : string read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TZc }

implementation
uses  Compiler;



const

  EOFSYMB = 0;  intConSym = 1;  realConSym = 2;  stringConSym = 3;
  identSym = 4;  andSym = 5;  assgnSym = 6;  colonSym = 7;  commaSym = 8;
  decSym = 9;  divSym = 10;  dotSym = 11;  eqSym = 12;  gtSym = 13;
  gteSym = 14;  incSym = 15;  lbraceSym = 16;  lbrackSym = 17;  lparSym = 18;
  lshiftSym = 19;  ltSym = 20;  lteSym = 21;  minusSym = 22;  modSym = 23;
  neqSym = 24;  notSym = 25;  orSym = 26;  plusSym = 27;  rbraceSym = 28;
  rbrackSym = 29;  rparSym = 30;  rshiftSym = 31;  scolonSym = 32;
  tildeSym = 33;  timesSym = 34;  xorSym = 35;  voidSym = 36;  _lparenSym = 37;
  _rparenSym = 38;  _lbraceSym = 39;  _rbraceSym = 40;  _commaSym = 41;
  _equalSym = 42;  floatSym = 43;  intSym = 44;  stringSym = 45;  modelSym = 46;
  _semicolonSym = 47;  ifSym = 48;  elseSym = 49;  switchSym = 50;
  whileSym = 51;  forSym = 52;  breakSym = 53;  continueSym = 54;
  returnSym = 55;  _plus_equalSym = 56;  _minus_equalSym = 57;
  _star_equalSym = 58;  _slash_equalSym = 59;  caseSym = 60;  _colonSym = 61;
  defaultSym = 62;  _querySym = 63;  _bar_barSym = 64;  _and_andSym = 65;
  _barSym = 66;  _uparrowSym = 67;  _andSym = 68;  _bang_equalSym = 69;
  _equal_equalSym = 70;  _lessSym = 71;  _greaterSym = 72;  _less_equalSym = 73;
  _greater_equalSym = 74;  _less_lessSym = 75;  _greater_greaterSym = 76;
  _plusSym = 77;  _minusSym = 78;  _starSym = 79;  _slashSym = 80;
  _plus_plusSym = 81;  _minus_minusSym = 82;  _bangSym = 83;  _pointSym = 84;
  _lbrackSym = 85;  _rbrackSym = 86;  NOSYMB = 87;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
begin
  if Op=nil then
  begin
    if SwitchOp.HasDefault then
      ZError('Only one default statement is allowed.');
    SwitchOp.HasDefault := True;
  end else
    Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
  SwitchOp.CaseOps.Last.Children.Add( Op );
  Op := nil;
end;

procedure TZc.CleanUp;
begin
  Zc_Ops.FunctionCleanUps.Clear;
  ZFunctions.Free;
end;

procedure TZc.ZError(const S : string);
var
  E : EParseError;
begin
  E := EParseError.Create(S);
  E.Message := S;
  E.Line := (Scanner as TZcScanner).CurrentSymbol.Line;
  E.Col := (Scanner as TZcScanner).CurrentSymbol.Col;
  raise E;
end;




{ --------------------------------------------------------------------------- }
{ ---- implementation for TZcScanner ---- }

procedure TZcScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TZcScanner.Comment : boolean;
var
  level : integer;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : string;
begin
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = CHR(10)) then
begin
level := level - 1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level - 1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
  Exit;
end
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
end;  { Comment }

function TZcScanner.CharInIgnoreSet(const Ch : char) : boolean;
begin
Result := (Ch = ' ')    OR
((CurrInputCh >= CHR(9)) AND (CurrInputCh <= CHR(10)) OR
(CurrInputCh = CHR(13)));
end; {CharInIgnoreSet}

function TZcScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    inc(q);
    inc(i);
  end;
end; {GetNextSymbolString}

procedure TZcScanner.CheckLiteral(var Sym : integer);
var
  SymId : integer;
  DefaultSymId : integer;
  aToken : string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
      sym := SymId;
  end;
end; {CheckLiteral}


procedure TZcScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while CharInIgnoreSet(CurrInputCh) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '/')) AND Comment then
begin
  Get(sym);
  exit;
  end;

  LastSymbol.Assign(CurrentSymbol);
  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos := BufferPosition;
  NextSymbol.Col := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len := 0;

  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
state := 2; 
end
else
begin
  sym := _noSym;
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'f')) then
begin
 
end
else
begin
sym := intConSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 4; 
end
else
begin
sym := realConSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 6; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 5; 
end
else
begin
  sym := _noSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
   7: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 8; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 9; 
end
else
begin
sym := realConSym;
exit;
end;
   9: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 11; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 10; 
end
else
begin
  sym := _noSym;
exit;
end;
  10: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 11; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
  12: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 14; 
end
else if ((CurrInputCh = '+') OR
(CurrInputCh = '-')) then
begin
state := 13; 
end
else
begin
  sym := _noSym;
exit;
end;
  13: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 14; 
end
else
begin
  sym := _noSym;
exit;
end;
  14: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := realConSym;
exit;
end;
  15: begin
sym := realConSym;
exit;
end;
  16: if ((CurrInputCh <= CHR(9)) OR
(CurrInputCh >= CHR(11)) AND (CurrInputCh <= CHR(12)) OR
(CurrInputCh >= CHR(14)) AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
 
end
else if (CurrInputCh = '"') then
begin
state := 17; 
end
else if (CurrInputCh = '\') then
begin
state := 53; 
end
else
begin
  sym := _noSym;
exit;
end;
  17: begin
sym := stringConSym;
exit;
end;
  18: if ((CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
state := 19; 
end
else
begin
  sym := _noSym;
exit;
end;
  19: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_') OR
(CurrInputCh >= 'a') AND (CurrInputCh <= 'z')) then
begin
 
end
else
begin
sym := identSym;
CheckLiteral(sym);
exit;
end;
  20: if (CurrInputCh = '&') then
begin
state := 60; 
end
else
begin
sym := andSym;
CheckLiteral(sym);
exit;
end;
  21: begin
sym := colonSym;
CheckLiteral(sym);
exit;
end;
  22: begin
sym := commaSym;
CheckLiteral(sym);
exit;
end;
  23: begin
sym := decSym;
CheckLiteral(sym);
exit;
end;
  24: if (CurrInputCh = '=') then
begin
state := 57; 
end
else
begin
sym := divSym;
CheckLiteral(sym);
exit;
end;
  25: begin
sym := eqSym;
CheckLiteral(sym);
exit;
end;
  26: begin
sym := gteSym;
CheckLiteral(sym);
exit;
end;
  27: begin
sym := incSym;
CheckLiteral(sym);
exit;
end;
  28: begin
sym := lbraceSym;
CheckLiteral(sym);
exit;
end;
  29: begin
sym := lbrackSym;
CheckLiteral(sym);
exit;
end;
  30: begin
sym := lparSym;
CheckLiteral(sym);
exit;
end;
  31: begin
sym := lshiftSym;
CheckLiteral(sym);
exit;
end;
  32: begin
sym := lteSym;
CheckLiteral(sym);
exit;
end;
  33: begin
sym := modSym;
exit;
end;
  34: begin
sym := neqSym;
CheckLiteral(sym);
exit;
end;
  35: if (CurrInputCh = '|') then
begin
state := 59; 
end
else
begin
sym := orSym;
CheckLiteral(sym);
exit;
end;
  36: begin
sym := rbraceSym;
CheckLiteral(sym);
exit;
end;
  37: begin
sym := rbrackSym;
CheckLiteral(sym);
exit;
end;
  38: begin
sym := rparSym;
CheckLiteral(sym);
exit;
end;
  39: begin
sym := rshiftSym;
CheckLiteral(sym);
exit;
end;
  40: begin
sym := scolonSym;
CheckLiteral(sym);
exit;
end;
  41: begin
sym := tildeSym;
exit;
end;
  42: if (CurrInputCh = '=') then
begin
state := 56; 
end
else
begin
sym := timesSym;
CheckLiteral(sym);
exit;
end;
  43: begin
sym := xorSym;
CheckLiteral(sym);
exit;
end;
  44: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if (CurrInputCh = '.') then
begin
state := 7; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 12; 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := intConSym;
exit;
end;
  45: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 44; 
end
else if ((CurrInputCh = 'X') OR
(CurrInputCh = 'x')) then
begin
state := 1; 
end
else if (CurrInputCh = '.') then
begin
state := 7; 
end
else if ((CurrInputCh = 'E') OR
(CurrInputCh = 'e')) then
begin
state := 12; 
end
else if ((CurrInputCh = 'D') OR
(CurrInputCh = 'F') OR
(CurrInputCh = 'M') OR
(CurrInputCh = 'd') OR
(CurrInputCh = 'f') OR
(CurrInputCh = 'm')) then
begin
state := 15; 
end
else
begin
sym := intConSym;
exit;
end;
  46: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 3; 
end
else
begin
sym := dotSym;
CheckLiteral(sym);
exit;
end;
  47: if (CurrInputCh = '=') then
begin
state := 25; 
end
else
begin
sym := assgnSym;
CheckLiteral(sym);
exit;
end;
  48: if (CurrInputCh = '-') then
begin
state := 23; 
end
else if (CurrInputCh = '=') then
begin
state := 55; 
end
else
begin
sym := minusSym;
CheckLiteral(sym);
exit;
end;
  49: if (CurrInputCh = '=') then
begin
state := 26; 
end
else if (CurrInputCh = '>') then
begin
state := 39; 
end
else
begin
sym := gtSym;
CheckLiteral(sym);
exit;
end;
  50: if (CurrInputCh = '+') then
begin
state := 27; 
end
else if (CurrInputCh = '=') then
begin
state := 54; 
end
else
begin
sym := plusSym;
CheckLiteral(sym);
exit;
end;
  51: if (CurrInputCh = '<') then
begin
state := 31; 
end
else if (CurrInputCh = '=') then
begin
state := 32; 
end
else
begin
sym := ltSym;
CheckLiteral(sym);
exit;
end;
  52: if (CurrInputCh = '=') then
begin
state := 34; 
end
else
begin
sym := notSym;
CheckLiteral(sym);
exit;
end;
  53: if ((CurrInputCh = '"') OR
(CurrInputCh = CHR(39)) OR
(CurrInputCh = '\') OR
(CurrInputCh = 'n')) then
begin
state := 16; 
end
else
begin
  sym := _noSym;
exit;
end;
  54: begin
sym := _plus_equalSym;
exit;
end;
  55: begin
sym := _minus_equalSym;
exit;
end;
  56: begin
sym := _star_equalSym;
exit;
end;
  57: begin
sym := _slash_equalSym;
exit;
end;
  58: begin
sym := _querySym;
exit;
end;
  59: begin
sym := _bar_barSym;
exit;
end;
  60: begin
sym := _and_andSym;
exit;
end;
  61: begin
sym := EOFSYMB;
CurrInputCh := chNull;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TZcScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(TinyHash, HashSecondaryOne, HashCompare);
fHashList.AddString('!', _bangSym, _bangSym);
fHashList.AddString('!=', _bang_equalSym, _bang_equalSym);
fHashList.AddString('&', _andSym, _andSym);
fHashList.AddString('(', _lparenSym, _lparenSym);
fHashList.AddString(')', _rparenSym, _rparenSym);
fHashList.AddString('*', _starSym, _starSym);
fHashList.AddString('+', _plusSym, _plusSym);
fHashList.AddString('++', _plus_plusSym, _plus_plusSym);
fHashList.AddString(',', _commaSym, _commaSym);
fHashList.AddString('-', _minusSym, _minusSym);
fHashList.AddString('--', _minus_minusSym, _minus_minusSym);
fHashList.AddString('.', _pointSym, _pointSym);
fHashList.AddString('/', _slashSym, _slashSym);
fHashList.AddString(':', _colonSym, _colonSym);
fHashList.AddString(';', _semicolonSym, _semicolonSym);
fHashList.AddString('<', _lessSym, _lessSym);
fHashList.AddString('<<', _less_lessSym, _less_lessSym);
fHashList.AddString('<=', _less_equalSym, _less_equalSym);
fHashList.AddString('=', _equalSym, _equalSym);
fHashList.AddString('==', _equal_equalSym, _equal_equalSym);
fHashList.AddString('>', _greaterSym, _greaterSym);
fHashList.AddString('>=', _greater_equalSym, _greater_equalSym);
fHashList.AddString('>>', _greater_greaterSym, _greater_greaterSym);
fHashList.AddString('[', _lbrackSym, _lbrackSym);
fHashList.AddString(']', _rbrackSym, _rbrackSym);
fHashList.AddString('^', _uparrowSym, _uparrowSym);
fHashList.AddString('break', breakSym, breakSym);
fHashList.AddString('case', caseSym, caseSym);
fHashList.AddString('continue', continueSym, continueSym);
fHashList.AddString('default', defaultSym, defaultSym);
fHashList.AddString('else', elseSym, elseSym);
fHashList.AddString('float', floatSym, floatSym);
fHashList.AddString('for', forSym, forSym);
fHashList.AddString('if', ifSym, ifSym);
fHashList.AddString('int', intSym, intSym);
fHashList.AddString('model', modelSym, modelSym);
fHashList.AddString('return', returnSym, returnSym);
fHashList.AddString('string', stringSym, stringSym);
fHashList.AddString('switch', switchSym, switchSym);
fHashList.AddString('void', voidSym, voidSym);
fHashList.AddString('while', whileSym, whileSym);
fHashList.AddString('{', _lbraceSym, _lbraceSym);
fHashList.AddString('|', _barSym, _barSym);
fHashList.AddString('}', _rbraceSym, _rbraceSym);
CurrentCh := CharAt;
fStartState[  0] := 61; fStartState[  1] := 62; fStartState[  2] := 62; fStartState[  3] := 62; 
fStartState[  4] := 62; fStartState[  5] := 62; fStartState[  6] := 62; fStartState[  7] := 62; 
fStartState[  8] := 62; fStartState[  9] := 62; fStartState[ 10] := 62; fStartState[ 11] := 62; 
fStartState[ 12] := 62; fStartState[ 13] := 62; fStartState[ 14] := 62; fStartState[ 15] := 62; 
fStartState[ 16] := 62; fStartState[ 17] := 62; fStartState[ 18] := 62; fStartState[ 19] := 62; 
fStartState[ 20] := 62; fStartState[ 21] := 62; fStartState[ 22] := 62; fStartState[ 23] := 62; 
fStartState[ 24] := 62; fStartState[ 25] := 62; fStartState[ 26] := 62; fStartState[ 27] := 62; 
fStartState[ 28] := 62; fStartState[ 29] := 62; fStartState[ 30] := 62; fStartState[ 31] := 62; 
fStartState[ 32] := 62; fStartState[ 33] := 52; fStartState[ 34] := 16; fStartState[ 35] := 62; 
fStartState[ 36] := 62; fStartState[ 37] := 33; fStartState[ 38] := 20; fStartState[ 39] := 62; 
fStartState[ 40] := 30; fStartState[ 41] := 38; fStartState[ 42] := 42; fStartState[ 43] := 50; 
fStartState[ 44] := 22; fStartState[ 45] := 48; fStartState[ 46] := 46; fStartState[ 47] := 24; 
fStartState[ 48] := 45; fStartState[ 49] := 44; fStartState[ 50] := 44; fStartState[ 51] := 44; 
fStartState[ 52] := 44; fStartState[ 53] := 44; fStartState[ 54] := 44; fStartState[ 55] := 44; 
fStartState[ 56] := 44; fStartState[ 57] := 44; fStartState[ 58] := 21; fStartState[ 59] := 40; 
fStartState[ 60] := 51; fStartState[ 61] := 47; fStartState[ 62] := 49; fStartState[ 63] := 58; 
fStartState[ 64] := 18; fStartState[ 65] := 19; fStartState[ 66] := 19; fStartState[ 67] := 19; 
fStartState[ 68] := 19; fStartState[ 69] := 19; fStartState[ 70] := 19; fStartState[ 71] := 19; 
fStartState[ 72] := 19; fStartState[ 73] := 19; fStartState[ 74] := 19; fStartState[ 75] := 19; 
fStartState[ 76] := 19; fStartState[ 77] := 19; fStartState[ 78] := 19; fStartState[ 79] := 19; 
fStartState[ 80] := 19; fStartState[ 81] := 19; fStartState[ 82] := 19; fStartState[ 83] := 19; 
fStartState[ 84] := 19; fStartState[ 85] := 19; fStartState[ 86] := 19; fStartState[ 87] := 19; 
fStartState[ 88] := 19; fStartState[ 89] := 19; fStartState[ 90] := 19; fStartState[ 91] := 29; 
fStartState[ 92] := 62; fStartState[ 93] := 37; fStartState[ 94] := 43; fStartState[ 95] := 19; 
fStartState[ 96] := 62; fStartState[ 97] := 19; fStartState[ 98] := 19; fStartState[ 99] := 19; 
fStartState[100] := 19; fStartState[101] := 19; fStartState[102] := 19; fStartState[103] := 19; 
fStartState[104] := 19; fStartState[105] := 19; fStartState[106] := 19; fStartState[107] := 19; 
fStartState[108] := 19; fStartState[109] := 19; fStartState[110] := 19; fStartState[111] := 19; 
fStartState[112] := 19; fStartState[113] := 19; fStartState[114] := 19; fStartState[115] := 19; 
fStartState[116] := 19; fStartState[117] := 19; fStartState[118] := 19; fStartState[119] := 19; 
fStartState[120] := 19; fStartState[121] := 19; fStartState[122] := 19; fStartState[123] := 28; 
fStartState[124] := 35; fStartState[125] := 36; fStartState[126] := 41; fStartState[127] := 62; 
fStartState[128] := 62; fStartState[129] := 62; fStartState[130] := 62; fStartState[131] := 62; 
fStartState[132] := 62; fStartState[133] := 62; fStartState[134] := 62; fStartState[135] := 62; 
fStartState[136] := 62; fStartState[137] := 62; fStartState[138] := 62; fStartState[139] := 62; 
fStartState[140] := 62; fStartState[141] := 62; fStartState[142] := 62; fStartState[143] := 62; 
fStartState[144] := 62; fStartState[145] := 62; fStartState[146] := 62; fStartState[147] := 62; 
fStartState[148] := 62; fStartState[149] := 62; fStartState[150] := 62; fStartState[151] := 62; 
fStartState[152] := 62; fStartState[153] := 62; fStartState[154] := 62; fStartState[155] := 62; 
fStartState[156] := 62; fStartState[157] := 62; fStartState[158] := 62; fStartState[159] := 62; 
fStartState[160] := 62; fStartState[161] := 62; fStartState[162] := 62; fStartState[163] := 62; 
fStartState[164] := 62; fStartState[165] := 62; fStartState[166] := 62; fStartState[167] := 62; 
fStartState[168] := 62; fStartState[169] := 62; fStartState[170] := 62; fStartState[171] := 62; 
fStartState[172] := 62; fStartState[173] := 62; fStartState[174] := 62; fStartState[175] := 62; 
fStartState[176] := 62; fStartState[177] := 62; fStartState[178] := 62; fStartState[179] := 62; 
fStartState[180] := 62; fStartState[181] := 62; fStartState[182] := 62; fStartState[183] := 62; 
fStartState[184] := 62; fStartState[185] := 62; fStartState[186] := 62; fStartState[187] := 62; 
fStartState[188] := 62; fStartState[189] := 62; fStartState[190] := 62; fStartState[191] := 62; 
fStartState[192] := 62; fStartState[193] := 62; fStartState[194] := 62; fStartState[195] := 62; 
fStartState[196] := 62; fStartState[197] := 62; fStartState[198] := 62; fStartState[199] := 62; 
fStartState[200] := 62; fStartState[201] := 62; fStartState[202] := 62; fStartState[203] := 62; 
fStartState[204] := 62; fStartState[205] := 62; fStartState[206] := 62; fStartState[207] := 62; 
fStartState[208] := 62; fStartState[209] := 62; fStartState[210] := 62; fStartState[211] := 62; 
fStartState[212] := 62; fStartState[213] := 62; fStartState[214] := 62; fStartState[215] := 62; 
fStartState[216] := 62; fStartState[217] := 62; fStartState[218] := 62; fStartState[219] := 62; 
fStartState[220] := 62; fStartState[221] := 62; fStartState[222] := 62; fStartState[223] := 62; 
fStartState[224] := 62; fStartState[225] := 62; fStartState[226] := 62; fStartState[227] := 62; 
fStartState[228] := 62; fStartState[229] := 62; fStartState[230] := 62; fStartState[231] := 62; 
fStartState[232] := 62; fStartState[233] := 62; fStartState[234] := 62; fStartState[235] := 62; 
fStartState[236] := 62; fStartState[237] := 62; fStartState[238] := 62; fStartState[239] := 62; 
fStartState[240] := 62; fStartState[241] := 62; fStartState[242] := 62; fStartState[243] := 62; 
fStartState[244] := 62; fStartState[245] := 62; fStartState[246] := 62; fStartState[247] := 62; 
fStartState[248] := 62; fStartState[249] := 62; fStartState[250] := 62; fStartState[251] := 62; 
fStartState[252] := 62; fStartState[253] := 62; fStartState[254] := 62; fStartState[255] := 62; 
end; {Create}

destructor TZcScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TZc ---- }

constructor TZc.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TZcScanner.Create;
  GetScanner.Owner := self;
ZFunctions := TObjectList.Create(False);

  InitSymSet;
end; {Create}

destructor TZc.Destroy;
begin
  Scanner.Free;
CleanUp;

  inherited;
end; {Destroy}

function TZc.ErrorStr(const ErrorCode : integer; const Data : string) : string;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'intCon expected';
   2 : Result := 'realCon expected';
   3 : Result := 'stringCon expected';
   4 : Result := 'ident expected';
   5 : Result := 'and expected';
   6 : Result := 'assgn expected';
   7 : Result := 'colon expected';
   8 : Result := 'comma expected';
   9 : Result := 'dec expected';
  10 : Result := 'div expected';
  11 : Result := 'dot expected';
  12 : Result := 'eq expected';
  13 : Result := 'gt expected';
  14 : Result := 'gte expected';
  15 : Result := 'inc expected';
  16 : Result := 'lbrace expected';
  17 : Result := 'lbrack expected';
  18 : Result := 'lpar expected';
  19 : Result := 'lshift expected';
  20 : Result := 'lt expected';
  21 : Result := 'lte expected';
  22 : Result := 'minus expected';
  23 : Result := 'mod expected';
  24 : Result := 'neq expected';
  25 : Result := 'not expected';
  26 : Result := 'or expected';
  27 : Result := 'plus expected';
  28 : Result := 'rbrace expected';
  29 : Result := 'rbrack expected';
  30 : Result := 'rpar expected';
  31 : Result := 'rshift expected';
  32 : Result := 'scolon expected';
  33 : Result := 'tilde expected';
  34 : Result := 'times expected';
  35 : Result := 'xor expected';
  36 : Result := '"void" expected';
  37 : Result := '"(" expected';
  38 : Result := '")" expected';
  39 : Result := '"{" expected';
  40 : Result := '"}" expected';
  41 : Result := '"," expected';
  42 : Result := '"=" expected';
  43 : Result := '"float" expected';
  44 : Result := '"int" expected';
  45 : Result := '"string" expected';
  46 : Result := '"model" expected';
  47 : Result := '";" expected';
  48 : Result := '"if" expected';
  49 : Result := '"else" expected';
  50 : Result := '"switch" expected';
  51 : Result := '"while" expected';
  52 : Result := '"for" expected';
  53 : Result := '"break" expected';
  54 : Result := '"continue" expected';
  55 : Result := '"return" expected';
  56 : Result := '"+=" expected';
  57 : Result := '"-=" expected';
  58 : Result := '"*=" expected';
  59 : Result := '"/=" expected';
  60 : Result := '"case" expected';
  61 : Result := '":" expected';
  62 : Result := '"default" expected';
  63 : Result := '"?" expected';
  64 : Result := '"||" expected';
  65 : Result := '"&&" expected';
  66 : Result := '"|" expected';
  67 : Result := '"^" expected';
  68 : Result := '"&" expected';
  69 : Result := '"!=" expected';
  70 : Result := '"==" expected';
  71 : Result := '"<" expected';
  72 : Result := '">" expected';
  73 : Result := '"<=" expected';
  74 : Result := '">=" expected';
  75 : Result := '"<<" expected';
  76 : Result := '">>" expected';
  77 : Result := '"+" expected';
  78 : Result := '"-" expected';
  79 : Result := '"*" expected';
  80 : Result := '"/" expected';
  81 : Result := '"++" expected';
  82 : Result := '"--" expected';
  83 : Result := '"!" expected';
  84 : Result := '"." expected';
  85 : Result := '"[" expected';
  86 : Result := '"]" expected';
  87 : Result := 'not expected';
  88 : Result := 'invalid Literal';
  89 : Result := 'invalid Primary';
  90 : Result := 'invalid SwitchLabel';
  91 : Result := 'invalid AssignOp';
  92 : Result := 'invalid ForInit';
  93 : Result := 'invalid StatementExpr';
  94 : Result := 'invalid EmbeddedStatement';
  95 : Result := 'invalid SimpleType';
  96 : Result := 'invalid Expr';
  97 : Result := 'invalid Statement';

200 : Result := 'Not a floating point value';
    201 : Result := 'Name already defined in this scope';
    202 : Result := 'Return value expected';
    203 : Result := 'Function should not return a value';
    204 : Result := 'Only function definitions are allowed here';
    205 : Result := 'Syntax not supported';
  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TZc.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TZc.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TZc.GetScanner : TZcScanner;
begin
  Result := Scanner AS TZcScanner;
end; {GetScanner}

function TZc._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TZc._Literal (var  Typ  :  TZcDataType);begin
if (fCurrentInputSymbol = intConSym) then begin
Get;
Typ  :=zctInt;
end else if (fCurrentInputSymbol = realConSym) then begin
Get;
Typ  :=  zctFloat;
end else if (fCurrentInputSymbol = stringConSym) then begin
Get;
Typ  :=  zctString;
end else begin SynError(88);
end;
end;

procedure TZc._Primary (var  OutOp  :  TZcOp);var  Op  :  TZcOp;  S  :  string;  V  :  single;
   Typ  :  TZcDataType;

begin
OutOp  :=  nil;
if (fCurrentInputSymbol = identSym) then begin
Get;
OutOp  :=  MakeIdentifier(LexString);
end else if (fCurrentInputSymbol = intConSym) OR
 (fCurrentInputSymbol = realConSym) OR
 (fCurrentInputSymbol = stringConSym) then begin
_Literal(Typ);

if  Typ=zctString  then
OutOp  :=  TZcOpLiteral.Create(Typ,LexString)
else
begin
try
S  :=  LexString;
V  :=  ZcStrToFloat(S);
OutOp  :=  TZcOpLiteral.Create(Typ,V)
except  on  EConvertError  do
SynError(200);
end;
end;

end else if (fCurrentInputSymbol = _lparenSym) then begin
Get;
_Expr(OutOp);
Expect(_rparenSym);
end else begin SynError(89);
end;
while (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) OR
 (fCurrentInputSymbol = _pointSym) OR
 (fCurrentInputSymbol = _lbrackSym) do begin
if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
OutOp  :=  MakePrePostIncDec(zcPostInc,CheckIdentifier(OutOp));
end else if (fCurrentInputSymbol = _minus_minusSym) then begin
Get;
OutOp  :=  MakePrePostIncDec(zcPostDec,CheckIdentifier(OutOp));
end else if (fCurrentInputSymbol = _pointSym) then begin
Get;
Expect(identSym);


if  not  (OutOp.Kind  in  [zcIdentifier,zcSelect])  then
ZError('Invalid  use  of  "."');

Op  :=  MakeOp(zcSelect,[OutOp]);
Op.Id  :=  LexString;

OutOp  :=  Op;


end else if (fCurrentInputSymbol = _lparenSym) then begin
Get;
Assert(OutOp.Kind=zcIdentifier);
OutOp.Kind:=zcFuncCall;

if _In(symSet[1], fCurrentInputSymbol) then begin
_Argument(Op);
OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Argument(Op);
OutOp.Children.Add(Op);
end;
end;

  if  not  VerifyFunctionCall(OutOp,S)  then
    ZError(S);

Expect(_rparenSym);
end else begin
Get;
Assert(OutOp.Kind=zcIdentifier);
OutOp.Kind:=zcArrayAccess;

_Expr(Op);
OutOp.Children.Add(  MakeCompatible(Op,zctInt)  );
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Expr(Op);
OutOp.Children.Add(  MakeCompatible(Op,zctInt)  );
end;
Expect(_rbrackSym);
end;
end;

if  OutOp.Kind=zcIdentifier  then
   OutOp  :=  CheckIdentifier(OutOp);

end;

procedure TZc._MulExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Tmp  :  TZcOp;  Kind  :  TZcOpKind;
begin
OutOp  :=  InOp;
while (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _slashSym) do begin
if (fCurrentInputSymbol = _starSym) then begin
Get;
Kind  :=  zcMul;
end else begin
Get;
Kind  :=  zcDiv;
end;
_Unary(Tmp);
OutOp  :=  MakeBinary(Kind,InOp,Tmp);
InOp  :=  OutOp;

end;
end;

procedure TZc._AddExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;   Kind  :  TZcOpKind;
begin
_MulExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
Kind  :=  zcPlus;
end else begin
Get;
Kind  :=  zcMinus;
end;
_Unary(Op);
_MulExpr(Op,R);

if  (L=nil)  or  (R=nil)  then
   ZError('Invalid  syntax');
OutOp  :=  MakeBinary(Kind,L,R);
L  :=  OutOp;

end;
end;

procedure TZc._ShiftExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;  Kind  :  TZcOpKind;
begin
_AddExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _less_lessSym) OR
 (fCurrentInputSymbol = _greater_greaterSym) do begin
if (fCurrentInputSymbol = _less_lessSym) then begin
Get;
Kind  :=  zcBinaryShiftL;
end else begin
Get;
Kind  :=  zcBinaryShiftR;
end;
_Unary(Op);
_AddExpr(Op,R);
OutOp  :=  MakeOp(Kind,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._RelExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;   Kind  :  TZcOpKind;
begin
_ShiftExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _greaterSym) OR
 (fCurrentInputSymbol = _less_equalSym) OR
 (fCurrentInputSymbol = _greater_equalSym) do begin
if (fCurrentInputSymbol = _lessSym) then begin
Get;
Kind  :=  zcCompLT;
end else if (fCurrentInputSymbol = _greaterSym) then begin
Get;
Kind  :=  zcCompGT;
end else if (fCurrentInputSymbol = _less_equalSym) then begin
Get;
Kind  :=  zcCompLE;
end else begin
Get;
Kind  :=  zcCompGE;
end;
_Unary(Op);
_ShiftExpr(Op,R);
OutOp  :=  MakeBinary(Kind,  L,R  );
L  :=  OutOp;

end;
end;

procedure TZc._EqlExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;  Kind  :  TZcOpKind;
begin
_RelExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _bang_equalSym) OR
 (fCurrentInputSymbol = _equal_equalSym) do begin
if (fCurrentInputSymbol = _bang_equalSym) then begin
Get;
Kind  :=  zcCompNE;
end else begin
Get;
Kind  :=  zcCompEQ;
end;
_Unary(Op);
_RelExpr(Op,R);
OutOp  :=  MakeBinary(Kind,  L,R);
L  :=  OutOp;

end;
end;

procedure TZc._BitAndExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_EqlExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _andSym) do begin
Get;
_Unary(Op);
_EqlExpr(Op,R);
OutOp  :=  MakeOp(zcBinaryAnd,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._BitXorExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
_BitAndExpr(InOp,OutOp);
while (fCurrentInputSymbol = _uparrowSym) do begin
Get;
SynError(205);
_Unary(Op);
_BitAndExpr(InOp,OutOp);
end;
end;

procedure TZc._BitOrExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_BitXorExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _barSym) do begin
Get;
_Unary(Op);
_BitXorExpr(Op,R);
OutOp  :=  MakeOp(zcBinaryOr,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._AndExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_BitOrExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _and_andSym) do begin
Get;
_Unary(Op);
_BitOrExpr(Op,R);
OutOp  :=  MakeOp(zcAnd,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._OrExpr (InOp  :  TZcOp;  var  OutOp  :  TZcOp);var  Op,L,R  :  TZcOp;
begin
_AndExpr(InOp,OutOp);
L  :=  OutOp;
while (fCurrentInputSymbol = _bar_barSym) do begin
Get;
_Unary(Op);
_AndExpr(Op,R);
OutOp  :=  MakeOp(zcOr,[L,R]);
L  :=  OutOp;
end;
end;

procedure TZc._SwitchLabel (var  OutOp  :  TZcOp);begin
if (fCurrentInputSymbol = caseSym) then begin
Get;
_Expr(OutOp);
Expect(_colonSym);
end else if (fCurrentInputSymbol = defaultSym) then begin
Get;
Expect(_colonSym);
end else begin SynError(90);
end;
end;

procedure TZc._AssignOp (var  Kind  :  TZcAssignType);begin
if (fCurrentInputSymbol = _equalSym) then begin
Get;
Kind  :=  atAssign;
end else if (fCurrentInputSymbol = _plus_equalSym) then begin
Get;
Kind  :=  atPlusAssign;
end else if (fCurrentInputSymbol = _minus_equalSym) then begin
Get;
Kind  :=  atMinusAssign;
end else if (fCurrentInputSymbol = _star_equalSym) then begin
Get;
Kind  :=  atMulAssign;
end else if (fCurrentInputSymbol = _slash_equalSym) then begin
Get;
Kind  :=  atDivAssign;
end else begin SynError(91);
end;
end;

procedure TZc._Unary (var  OutOp  :  TZcOp);var  LastOp,Tmp  :  TZcOp;  Kind  :  TZcOpKind;
begin
LastOp  :=  nil;  Kind  :=  zcNop;
while (fCurrentInputSymbol = _minusSym) OR
 (fCurrentInputSymbol = _plus_plusSym) OR
 (fCurrentInputSymbol = _minus_minusSym) OR
 (fCurrentInputSymbol = _bangSym) do begin
if (fCurrentInputSymbol = _minusSym) then begin
Get;
Kind  :=  zcNegate;
end else if (fCurrentInputSymbol = _plus_plusSym) then begin
Get;
Kind  :=  zcPreInc;
end else if (fCurrentInputSymbol = _minus_minusSym) then begin
Get;
Kind  :=  zcPreDec;
end else begin
Get;
Kind  :=  zcNot;
end;

  if  Kind  in  [zcNegate,zcNot]  then
  begin
    Tmp  :=  MakeOp(Kind);
    if  LastOp<>nil  then
      LastOp.Children.Add(Tmp);
    LastOp  :=  Tmp;
  end  else  if  Assigned(LastOp)  then
    ZError('--  and  ++  cannot  be  combined  with  other  unary  ops');

end;
_Primary(Tmp);

  if  Kind  in  [zcNop,zcNegate,zcNot]  then
  begin
    if  LastOp<>nil  then
    begin
      LastOp.Children.Add(Tmp);
      OutOp  :=  LastOp;
    end  else
      OutOp  :=  Tmp;
  end  else
  begin
    OutOp  :=  MakePrePostIncDec(Kind,Tmp);
  end;

end;

procedure TZc._ForInc (var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
Op:=nil;
OutOp  :=  MakeOp(zcBlock);

_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Op:=nil;
Get;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
end;

procedure TZc._ForInit (var  OutOp  :  TZcOp);var  Op  :  TZcOp;
begin
Op:=nil;  OutOp  :=  MakeOp(zcBlock);
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = modelSym) then begin
_LocalVarDecl(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end else if _In(symSet[1], fCurrentInputSymbol) then begin
Op:=nil;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
while (fCurrentInputSymbol = _commaSym) do begin
Op:=nil;
Get;
_StatementExpr(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
end else begin SynError(92);
end;
end;

procedure TZc._SwitchSection (SwitchOp  :  TZcOpSwitch);var  Op  :  TZcOp;
begin
Op  :=  nil;
_SwitchLabel(Op);
AddSwitchLabel(SwitchOp,Op);
while (fCurrentInputSymbol = caseSym) OR
 (fCurrentInputSymbol = defaultSym) do begin
_SwitchLabel(Op);
AddSwitchLabel(SwitchOp,Op);
end;
_Statement(Op);
SwitchOp.StatementsOps.Last.Children.Add(Op);
while _In(symSet[2], fCurrentInputSymbol) do begin
_Statement(Op);
SwitchOp.StatementsOps.Last.Children.Add(Op);
end;
end;

procedure TZc._StatementExpr (var  OutOp  :  TZcOp);var  Op1,Op2  :  TZcOp;  Kind  :  TZcAssignType;
begin
Op1  :=nil;  Op2  :=  nil;
_Unary(Op1);
if (fCurrentInputSymbol = _equalSym) OR
 (fCurrentInputSymbol = _plus_equalSym) OR
 (fCurrentInputSymbol = _minus_equalSym) OR
 (fCurrentInputSymbol = _star_equalSym) OR
 (fCurrentInputSymbol = _slash_equalSym) then begin
_AssignOp(Kind);
_Expr(Op2);

if  Op2<>nil  then
   OutOp  :=  MakeAssign(Kind,Op1,Op2);

end else if (fCurrentInputSymbol = _rparenSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _semicolonSym) then begin
OutOp  :=  Op1;
end else begin SynError(93);
end;
end;

procedure TZc._Block (var  OutOp  :  TZcOp);var
   Op  :  TZcOp;

begin
Op  :=  nil;
OutOp  :=  MakeOp(zcBlock);

Expect(_lbraceSym);
while _In(symSet[2], fCurrentInputSymbol) do begin
_Statement(Op);
if  Assigned(Op)  then  OutOp.Children.Add(Op);
end;
Expect(_rbraceSym);
end;

procedure TZc._EmbeddedStatement (var  OutOp  :  TZcOp);var
   Op,IfOp,IfBody,ElseOp  :  TZcOp;
   ForInitOp,ForCondOp,ForIncOp,ForBodyOp  :  TZcOp;
   WhileCondOp,WhileBodyOp  :  TZcOp;
   SwitchOp  :  TZcOpSwitch;

begin
case fCurrentInputSymbol of
  _lbraceSym : begin
_Block(OutOp);
    end;
  _semicolonSym : begin
Get;
OutOp  :=  MakeOp(zcNop);
    end;
  intConSym, realConSym, stringConSym, identSym, _lparenSym, _minusSym, _plus_plusSym, 
      _minus_minusSym, _bangSym : begin
_StatementExpr(OutOp);
Expect(_semicolonSym);
    end;
  ifSym : begin
Get;
ElseOp  :=  nil;
Expect(_lparenSym);
_Expr(IfOp);
Expect(_rparenSym);
_EmbeddedStatement(IfBody);
if (fCurrentInputSymbol = elseSym) then begin
Get;
_EmbeddedStatement(ElseOp);
end;
OutOp  :=  MakeOp(zcIf,[IfOp,IfBody,ElseOp]);
    end;
  switchSym : begin
Get;
Expect(_lparenSym);
_Expr(Op);
Expect(_rparenSym);

  SwitchOp  :=  TZcOpSwitch.Create(nil);
  SwitchOp.ValueOp  :=  Op;
  OutOp  :=  SwitchOp;

Expect(_lbraceSym);
while (fCurrentInputSymbol = caseSym) OR
 (fCurrentInputSymbol = defaultSym) do begin
SwitchOp.CaseOps.Add(  MakeOp(zcNop)  );  SwitchOp.StatementsOps.Add(  MakeOp(zcNop)  );
_SwitchSection(SwitchOp);
end;
Expect(_rbraceSym);
    end;
  whileSym : begin
Get;
try
  SymTab.PushScope;
  WhileCondOp  :=  nil;  WhileBodyOp  :=  nil;
Expect(_lparenSym);
_Expr(WhileCondOp);
Expect(_rparenSym);
_EmbeddedStatement(WhileBodyOp);

     OutOp  :=  MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
   finally
     SymTab.PopScope;
   end;

    end;
  forSym : begin
Get;
try
   SymTab.PushScope;
   ForInitOp  :=nil;  ForCondOp  :=  nil;  ForIncOp  :=  nil;
Expect(_lparenSym);
if _In(symSet[3], fCurrentInputSymbol) then begin
_ForInit(ForInitOp);
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expr(ForCondOp);
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_ForInc(ForIncOp);
end;
Expect(_rparenSym);
_EmbeddedStatement(ForBodyOp);

     OutOp  :=  MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
   finally
     SymTab.PopScope;
   end;

    end;
  breakSym : begin
Get;
Expect(_semicolonSym);
OutOp  :=  MakeOp(zcBreak);
    end;
  continueSym : begin
Get;
Expect(_semicolonSym);
OutOp  :=  MakeOp(zcContinue);
    end;
  returnSym : begin
Op  :=  nil;
Get;
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expr(Op);
end;
Expect(_semicolonSym);

   if  (Op=nil)  then
   begin
     if  CurrentFunction.ReturnType<>zctVoid  then
       SynError(202)
     else
       OutOp  :=  MakeOp(zcReturn);
   end  else
   begin
     if  CurrentFunction.ReturnType=zctVoid  then
       SynError(203)
     else
       OutOp  :=  MakeOp(zcReturn,[  MakeCompatible(Op,CurrentFunction.ReturnType)  ]);
   end;

    end;
else begin SynError(94);
    end;
end;
end;

procedure TZc._SimpleType (var  Typ  :  TZcDataType);begin
if (fCurrentInputSymbol = floatSym) then begin
Get;
Typ  :=  zctFloat;
end else if (fCurrentInputSymbol = intSym) then begin
Get;
Typ  :=  zctInt;
end else if (fCurrentInputSymbol = stringSym) then begin
Get;
Typ  :=  zctString;
end else if (fCurrentInputSymbol = modelSym) then begin
Get;
Typ  :=  zctModel;
end else begin SynError(95);
end;
end;

procedure TZc._Argument (var  OutOp  :  TZcOp);begin
OutOp  :=  nil;
_Expr(OutOp);
if  OutOp=nil  then  ZError('Missing  argument');
end;

procedure TZc._Expr (var  OutOp  :  TZcOp);var  Op1,Op2  :  TZcOp;  Kind  :  TZcAssignType;
begin
Op1  :=nil;  Op2  :=  nil;
_Unary(Op1);
if _In(symSet[4], fCurrentInputSymbol) then begin
_OrExpr(Op1,OutOp);
if (fCurrentInputSymbol = _querySym) then begin
Get;
_Expr(Op1);
Expect(_colonSym);
_Expr(Op2);
if  (OutOp=nil)  or  (Op1=nil)  or  (Op2=nil)  then
   SynError(205)
else
   OutOp  :=  MakeOp(zcConditional,[OutOp,Op1,Op2]);

end;
end else if (fCurrentInputSymbol = _equalSym) OR
 (fCurrentInputSymbol = _plus_equalSym) OR
 (fCurrentInputSymbol = _minus_equalSym) OR
 (fCurrentInputSymbol = _star_equalSym) OR
 (fCurrentInputSymbol = _slash_equalSym) then begin
_AssignOp(Kind);
_Expr(Op2);
OutOp  :=  MakeAssign(Kind,Op1,  MakeCompatible(Op2,Op1.GetDataType)  );
end else begin SynError(96);
end;
end;

procedure TZc._Init (var  OutOp  :  TZcOp);begin
_Expr(OutOp);
end;

procedure TZc._LocalVar (Typ  :  TZcDataType;  var  OutOp  :  TZcOp);var  Loc  :  TZcOpLocalVar;  InitOp  :  TZcOp;
begin
Expect(identSym);

if  SymTab.ScopeContains(LexString)  then
   ZError('Name  already  defined:  '  +  LexString);

Loc  :=  TZcOpLocalVar.Create(nil);
Loc.Id  :=  LexString;
Loc.Typ  :=  Typ;

if (fCurrentInputSymbol = _equalSym) then begin
Get;
_Init(InitOp);
Loc.InitExpression:=InitOp;
end;

SymTab.Add(Loc.Id,Loc);
CurrentFunction.AddLocal(Loc);

if  Assigned(Loc.InitExpression)  then
begin
   //Generate  tree  for  initial  assignment
   if  OutOp=nil  then
     OutOp  :=  MakeOp(zcBlock);
   OutOp.Children.Add(  MakeAssign(atAssign,  MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression)  );
end;


end;

procedure TZc._LocalVarDecl (var  OutOp  :  TZcOp);var  Typ  :  TZcDataType;
begin
OutOp  :=  nil;
_Type(Typ);
_LocalVar(Typ,OutOp);
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_LocalVar(Typ,OutOp);
end;
end;

procedure TZc._Par;var  Typ  :  TZcDataType;  Arg  :  TZcOpArgumentVar;
begin
_Type(Typ);
Expect(identSym);

  if  SymTab.ScopeContains(LexString)  then
    SynError(201)
  else
  begin
    Arg  :=  TZcOpArgumentVar.Create(GlobalNames);
    Arg.Id  :=  LexString;
    Arg.Typ  :=  Typ;
    CurrentFunction.AddArgument(Arg);
    SymTab.Add(Arg.Id,Arg);
  end;

end;

procedure TZc._Statement (var  OutOp  :  TZcOp);begin
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = modelSym) then begin
OutOp  :=  nil;
_LocalVarDecl(OutOp);
Expect(_semicolonSym);
end else if _In(symSet[5], fCurrentInputSymbol) then begin
_EmbeddedStatement(OutOp);
end else begin SynError(97);
end;
end;

procedure TZc._ZcFuncBody;var  Op  :  TZcOp;
begin
while _In(symSet[2], fCurrentInputSymbol) do begin
Op:=nil;
_Statement(Op);
if  Op<>nil  then
   CurrentFunction.Statements.Add(Op);
Op  :=  nil;

end;
end;

procedure TZc._FormalParams;begin
_Par;
if (fCurrentInputSymbol = _commaSym) then begin
Get;
_FormalParams;
end;
end;

procedure TZc._Type (var  Typ  :  TZcDataType);begin
_SimpleType(Typ);
end;

procedure TZc._Zc;var
   I  :  integer;
   Func  :  TZcOpFunctionUserDefined;
   Typ  :  TZcDataType;

begin
if AllowFunctions then begin
while (fCurrentInputSymbol = voidSym) OR
 (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = modelSym) do begin
if (fCurrentInputSymbol = voidSym) then begin
Get;
Typ  :=  zctVoid;
end else begin
_Type(Typ);
end;
Expect(identSym);

if  SymTab.Contains(LexString)  then
ZError('Name  already  defined:  '  +  LexString);

Func  :=  TZcOpFunctionUserDefined.Create(GlobalNames);
Func.Id  :=  LexString;
Func.ReturnType  :=  Typ;
SymTab.Add(Func.Id,Func);
ZFunctions.Add(Func);
Self.CurrentFunction  :=  Func;
SymTab.PushScope;
try

Expect(_lparenSym);
if (fCurrentInputSymbol = floatSym) OR
 (fCurrentInputSymbol = intSym) OR
 (fCurrentInputSymbol = stringSym) OR
 (fCurrentInputSymbol = modelSym) then begin
_FormalParams;
end;
Expect(_rparenSym);
Expect(_lbraceSym);
_ZcFuncBody;
Expect(_rbraceSym);

finally
SymTab.PopScope;
end;

end;
end
else begin

   Func  :=  TZcOpFunctionUserDefined.Create(nil);
   Func.ReturnType  :=  Self.ReturnType;
   Self.CurrentFunction  :=  Func;
   SymTab.PushScope;
   try
   ZFunctions.Add(Func);

_ZcFuncBody;

   finally
   SymTab.PopScope;
   end;

end;

    if  Successful  then
    begin
      for  I:=0  to  ZFunctions.Count-1  do
        ZFunctions[I]  :=  TZcOp(ZFunctions[I]).Optimize;
    end;

end;

function TZc.GetBuildDate : TDateTime;
const
  BDate = 38846;
  Hour = 16;
  Min = 41;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TZc.GetVersion : string;
begin
  Result := '1.0.0.116';
end;

function TZc.GetVersionStr : string;
begin
  Result := '1.0.0.116';
end;

function TZc.GetVersionInfo : string;
begin
  Result := 'Comment: Zc' + #13#10 +
'Author: Ville Krumlinde' + #13#10 +
'Copyright: ';
end;

procedure TZc.SetVersion(const Value : string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TZc.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_Zc;
end;  {Parse}

procedure TZc.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 0, 4] := [];
symSet[ 0, 5] := [];
symSet[ 1, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 1, 1] := [];
symSet[ 1, 2] := [_lparenSym-32];
symSet[ 1, 3] := [];
symSet[ 1, 4] := [_minusSym-64];
symSet[ 1, 5] := [_plus_plusSym-80, _minus_minusSym-80, _bangSym-80];
symSet[ 2, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 2, 1] := [];
symSet[ 2, 2] := [_lparenSym-32, _lbraceSym-32, floatSym-32, intSym-32, 
                    stringSym-32, modelSym-32, _semicolonSym-32];
symSet[ 2, 3] := [ifSym-48, switchSym-48, whileSym-48, forSym-48, breakSym-48, 
                    continueSym-48, returnSym-48];
symSet[ 2, 4] := [_minusSym-64];
symSet[ 2, 5] := [_plus_plusSym-80, _minus_minusSym-80, _bangSym-80];
symSet[ 3, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 3, 1] := [];
symSet[ 3, 2] := [_lparenSym-32, floatSym-32, intSym-32, stringSym-32, 
                    modelSym-32];
symSet[ 3, 3] := [];
symSet[ 3, 4] := [_minusSym-64];
symSet[ 3, 5] := [_plus_plusSym-80, _minus_minusSym-80, _bangSym-80];
symSet[ 4, 0] := [];
symSet[ 4, 1] := [];
symSet[ 4, 2] := [_rparenSym-32, _commaSym-32, _semicolonSym-32];
symSet[ 4, 3] := [_colonSym-48, _querySym-48];
symSet[ 4, 4] := [_bar_barSym-64, _and_andSym-64, _barSym-64, _uparrowSym-64, 
                    _andSym-64, _bang_equalSym-64, _equal_equalSym-64, 
                    _lessSym-64, _greaterSym-64, _less_equalSym-64, 
                    _greater_equalSym-64, _less_lessSym-64, 
                    _greater_greaterSym-64, _plusSym-64, _minusSym-64, 
                    _starSym-64];
symSet[ 4, 5] := [_slashSym-80, _rbrackSym-80];
symSet[ 5, 0] := [intConSym, realConSym, stringConSym, identSym];
symSet[ 5, 1] := [];
symSet[ 5, 2] := [_lparenSym-32, _lbraceSym-32, _semicolonSym-32];
symSet[ 5, 3] := [ifSym-48, switchSym-48, whileSym-48, forSym-48, breakSym-48, 
                    continueSym-48, returnSym-48];
symSet[ 5, 4] := [_minusSym-64];
symSet[ 5, 5] := [_plus_plusSym-80, _minus_minusSym-80, _bangSym-80];
end; {InitSymSet}

end { Zc }.    
